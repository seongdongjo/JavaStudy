```
#)오더번호 자동생성 INSERT 시에(수출)
(SELECT CASE WHEN MAX(ORDER_NO) IS NULL //아래 WHERE조건으로 ORDER_NO 최대값이 존재하냐 
	THEN  //존재하지 않으면 오늘날짜!!!로 오더번호생성후 O0001 뒤에 붙힌다.
		CONCAT(#{loginJijum},CONCAT(DATE_FORMAT(NOW(),'%Y%m%d'),'O0001'))
	ELSE  //존재하면  120240502O				   			0002(+1해서)
		CONCAT(SUBSTRING(MAX(ORDER_NO),1,10),SUBSTRING(CONCAT(SUBSTRING(MAX(ORDER_NO),1,9),SUBSTRING(MAX(ORDER_NO),11,14))+1,10,13)) END //이렇게안하면 0002가아니라 2가나와서 1202405020001까지 하고 +1을 해주고 10,13까지 짜른것임
	FROM
		TRORDR A 
	WHERE 
		SUBSTRING(ORDER_NO,2,8) = (SELECT DATE_FORMAT(NOW(),'%Y%m%d')) 
		AND JIJUM = #{loginJijum} AND OR_DIVISION = 'O')
```

#) 수입오더관리 청구금계산<br>
먼저 청구금계산 로직은 거래처청구요율 메뉴에서 거래처,츨발지,도착지,수출입,type,<br>
20F,20E,40F,40E,45F,45E,적용일자~마감일자사이 같은게 있으면 해당 금액을 컨테이너의 청구금액으로 넣는다.<br>

수입오더에서 헤더를 클릭했을 때 현재 이렇게 오더번호를 넣고있다.(qcellClick함수)
```
<input type="hidden" name="headerOrderNo" id="headerOrderNo">

왜 오더번호를 넘기냐??

> 아래처럼 오더헤더에서 거래처코드를 가져와야한다. 오더디테일 테이블에는 거래처코드가 없기때문에
  이렇게 오더번호를 가져오면 오더헤더에(TRORDR)있는 오더번호에 맞는 거래처코드를 가져올 수 있다. 

    <select id="importSelectOrderCust" parameterType="TRImportTrordtVO" resultType="String">
            SELECT CUST_CODE FROM TRCGEA WHERE 
                CUST_CODE = (SELECT CUST_CODE FROM TRORDR WHERE ORDER_NO = #{orderNo})
                AND PICKUP_JY= #{jydetail1Code}
                AND RETURN_JY= #{jydetail2Code}
                AND CNTR_TYPE = #{cntrTp}
                AND IN_OUT = 'I'
                ORDER BY CUST_APLDAT DESC LIMIT 1
    </select>
```

<img src="https://github.com/seongdongjo/JavaStudy/blob/main/%EB%A1%9C%EC%A7%81%EC%A0%95%EB%A6%AC/1.PNG" width="600" height="100" /><br><br>
여기서 핵심은 수정,추가,변경사항이 없어도 청구금계산을 클릭하면 청구금액이 들어가야한다는 것이다.<br>
```
//청구금계산
	function countClamAmt() {
		var nRow = qcell_master.getIdx("row");
		if(nRow == -1) {
			alert('오더를 선택해주세요.')
			return false;
		}
		//변경이 일어났을때 청구금계산누르면 기본적으로 컨테이너번호 유무 체크 
		var notRegistCost = 0;
		var change = qcell_detail.getStates();
        //이렇게 ''선언하지않고 updateCntr+=updateArray[z].data.cntrNo; 이렇게하면
        //undefinedCNTR2222 이렇게 된다. 즉 처음에 updateCntr이 undefined라서 그럼. 
        var updateCntr = '';
        //재접근 시 기존 값 수정
		document.getElementById('updateCntr').value = '';
		if(change.i.length != 0 || change.u.length != 0){
			let insertArray = JSON.parse(document.getElementById('paramValue').value).i;
			let updateArray = JSON.parse(document.getElementById('paramValue').value).u;
			let deleteArray = JSON.parse(document.getElementById('paramValue').value).d;
			var arrI = new Array();
			var arrU = new Array();
			var arrD = new Array();

			if(insertArray.length > 0) {
				for(var k = 0; k<insertArray.length; k++) {
					if(insertArray[k].data.cntrNo == '' || insertArray[k].data.cntrNo == null) {
						alert('컨테이너 번호는 빈값이 될 수 없습니다.')
						qcell_detail.hideProgress(300); // progress 화면 출력
						return false;	
					}
					if(insertArray[k].data.cntrNo.replace(/\s| /gi,'') == '') {
						alert('컨테이너 번호는 빈값이 될 수 없습니다.')
						qcell_detail.hideProgress(300); // progress 화면 출력
						return false;					
					}
				}
			}
	
			//수정컨테이너번호담기위해
            //왜 담느냐?? -> 이미 청구금액 로직을 탄 컨테이너는 또 청구금액 로직을 태우면안된다.
            //현재 로직은 수정변화가 없다라는 분기문이 없어서 이렇게 수정변화가 있는 컨테이너는 
            //따로, 담아서 또 청구금액 로직을 안타게 하기 위해서이다.
			if(updateArray.length > 0) {
				for(var z = 0; z<updateArray.length; z++) {
						updateCntr += updateArray[z].data.cntrNo;
						if(z != updateArray.length -1) {
							updateCntr += ","
						}else {
							
						}
					}
				document.getElementById('updateCntr').value = updateCntr;
			}
			qcellChange_detail();
			var formData = decodeURIComponent($('#frm0').serialize());
			$.ajax({
				url: "/transcls/order/importOrderMng/importOrderCountClaim.do", //통신하실 URL 주소(밑에 참조)
				//data: { param: JSON.stringify(states) }, //서버에 param이라는 parameter명으로 JSON String형태로 수정 정보 전달
				async:false,
				data: formData,
				method: "POST" //post형식으로 전달
			}).success(function (data) {
				//qcell_detail.showProgress(); // progress 화면 출력
				if(data.status == "fail") {
					qcell_detail.hideProgress(300); // progress 화면 출력
					alert('에러가 발생하였습니다.')
					return false;
				}
                //data.gridList[i] 안에는 추가,수정데이터에서 청구금액만 넣은 결과이다.
				//삽입했을때의 청구금계산
					if(insertArray.length > 0) {
						for(var k = 0; k<insertArray.length; k++) {
							for(var i = 0; i<data.gridList.length; i++) {
								if(insertArray[k].data.cntrNo == data.gridList[i].cntrNo) { //내가 추가한 컨테이너번호와 가져온 컨테이너번호가 같으면 claim넣음
									qcell_detail.setCellDataEx(insertArray[k].row,'claimAmt',data.gridList[i].claimAmt)
									data.gridList.splice(i,1); //i번째부터 1개지우겠다. 지우는이유는 이미 청구금액이 그리드에 들어간것은 굳이 다시 비교할필요가 없다.
								}
							}
						}
					}
					if(updateArray.length > 0) {
						for(var z = 0; z<updateArray.length; z++) {
							for(var x = 0; x<data.gridList.length; x++) {
								//data.gridList[x]에는 청구금이 0원인 한줄이 들어가있다. 
								if(updateArray[z].data.cntrNo == data.gridList[x].cntrNo) { //컨테이너번호로 같으면 가져온다.
									qcell_detail.setCellDataEx(updateArray[z].row,'claimAmt',data.gridList[x].claimAmt)
									data.gridList.splice(x,1); //지우는이유는 이미 청구금액이 그리드에 들어간것은 굳이 다시 비교할필요가 없다.
								}
							}
						}
					}
					notRegistCost += data.count;
			}).error(function (xhr, status, error) {
				qcell_detail.hideProgress(300); // progress 화면 출력
				alert("오류가 발생하였습니다.");
				//실패시 처리
			});
		}
```
#)컨트롤러
```
/**
     * 오더관리 > 수입(detail) - 청구금계산(변경사항이있으면서 0원일때)
     * @param Map<String,Object> vo
     * @return 출력페이지정보 "selectImportOrderMng"
     * @exception Exception
     */
    @NoLogging				 
	@RequestMapping(value = "/transcls/order/importOrderMng/importOrderCountClaim.do")
	public@ResponseBody HashMap<String, Object> importOrderCountClaim(@ModelAttribute("tRImportTrOrdtVO") TRImportTrordtVO tRImportTrOrdtVO, @RequestParam Map<String,Object> vo, ModelMap model) throws Exception {
    	LoginVO user = (LoginVO) EgovUserDetailsHelper.getAuthenticatedUser();
    	HashMap<String, Object> resMap = new HashMap<String, Object>();
    	List<TRImportTrordtVO> detailCountClaim = new ArrayList<TRImportTrordtVO>();
		try {	
			tRImportTrOrdtVO.setLoginJijum(user.getJijum()); 
            //파라미터를 보면 tRImportTrOrdtVO안에는 headerOrderNo가 들어가있다.
            //detailCountClaim은 리스트를 impl에서 받아오기 위해 넘겼다. 
			int count = importOrderMngService.importCountClaim(vo,tRImportTrOrdtVO,detailCountClaim);
				Function fn = new Function();
				JSONArray jsonArr = null;
				resMap.put("gridList", detailCountClaim);
				resMap.put("count", count);
		}catch(Exception e) {
			resMap.put("status", "fail");
			e.printStackTrace();
		}
		return resMap;
	}
```
#)impl
```
/**
     * 오더관리 디테일 저장 전 청구요율에 거래처가 있는지 확인
     * @param Map<String,Object> vo
     * @return 출력페이지정보 "selectimportOrderMng"
     * @exception Exception
     */
	@SuppressWarnings({ "unchecked", "unused" })
	@Override
	public int importCountClaim(Map<String, Object> vo,TRImportTrordtVO tRImportTrOrdtVO,List<TRImportTrordtVO> gridList) throws Exception {
		
		LoginVO user = (LoginVO)EgovUserDetailsHelper.getAuthenticatedUser(); // 현재 로그인한 계정정보 가져오기
		
		Map<String,Object> paramMap = new HashMap<String,Object>();
		List<Map<String,Object>> list = new ArrayList<Map<String,Object>>();
		ObjectMapper objectMapper2 = new ObjectMapper();
		Function fn = new Function();
		
		String strParam = (String) vo.get("param"); //화면상에 form -> name 값 사용
		paramMap = fn.jsonToMap(strParam);
		int count = 0; //기간이 틀린 건수(거래처청구요율에 해당하는 값은 있지만)
		
		//수정 데이터
		list = (List<Map<String, Object>>) paramMap.get("u");
		TRImportTrordtVO gridU = new TRImportTrordtVO();
		
		String custCode = null;
		double claimAmt = 0.0;
		
		if(list.size() > 0) { 
			for(int i=0; i < list.size(); i++) {
				gridU = objectMapper2.convertValue(fn.mapToVo(list,i), TRImportTrordtVO.class);
				//한줄마다의 상,하차지에 맞는 청구요율에서 거래처코드 가져오기(한줄마다의 gridU에는 오더번호,상,하차지가있다)
                gridU.setLoginJijum(user.getJijum()); // VO에 로그인 지점 값 넣기
				gridU.setLoginId(user.getId()); // VO에 로그인 ID 값 넣기
				gridU.setLoginIp(user.getIp()); // VO에 로그인 IP 값 넣기
				custCode = importOrderMngDAO.importSelectOrderCust(gridU);
				gridU.setCustCode(custCode);
				if(custCode == null || custCode == "") {
					//청구요율에 해당하는 거래처코드 자체가 없다면
					//문제점: tRImportTrOrdtVO에 계속 custCode, 저장되는현상
				}else { //거래처청구요율에 상,하차지,(오더의)거래처코드가 있다면
					if(gridU.getClaimAmt() == 0.0) {//입력안했을 때만
						//계약기간비교해서 거래처코드를 가져온다(아래count비교를 위해)
						custCode = importOrderMngDAO.importCheckOrderCust(gridU);
						//계약기간이 지나면 count = 0;
						if(custCode == null || custCode == "") {
							//tRImportTrOrdtVO.setCustCode(gridU.getCustCode()); //거래처코드 미리 저장해놓고(메시지출력위해)
							//tRImportTrOrdtVO.setJydetail1Code(gridU.getJydetail1Code()); 
							//tRImportTrOrdtVO.setJydetail2Code(gridU.getJydetail2Code()); 
							//tRImportTrOrdtVO.setCntrTp(gridU.getCntrTp());
							count++; //기간이 오버된거 count증가
							//return count;
						}else {
							claimAmt = importOrderMngDAO.importSelectClaimAmt(gridU);
							gridU.setClaimAmt(claimAmt);
							//i가 else문을 타면 띄엄띄엄 들어가서 i안쓰고 차곡차곡넣음
							gridList.add(gridU);
						}
					}
				}
			}
		}
		//입력 데이터
				list = (List<Map<String, Object>>) paramMap.get("i");
				TRImportTrordtVO gridI = new TRImportTrordtVO();
				if(list.size() > 0) { 
					//0으로 하는 이유는 컨테이너 오더번호는 같으니 그냥 첫번째걸로 구함
					//gridI = objectMapper2.convertValue(fn.mapToVo(list,0), TRImportTrordtVO.class);
					//해당하는 오더번호에 대한 거래처 가져옴(여기서는 계약일자는 비교하지않음)
					//custCode = importOrderMngDAO.importSelectOrderCust(gridI);
					//이렇게 count분기를 하는 이유는 alert를 3가지 case로 띄우기 위해서다.
					for(int i=0; i < list.size(); i++) {
						gridI = objectMapper2.convertValue(fn.mapToVo(list,i), TRImportTrordtVO.class);
						gridI.setLoginJijum(user.getJijum()); // VO에 로그인 지점 값 넣기
						gridI.setLoginId(user.getId()); // VO에 로그인 ID 값 넣기
						gridI.setLoginIp(user.getIp()); // VO에 로그인 IP 값 넣기
                        custCode = importOrderMngDAO.importSelectOrderCust(gridI);
						gridI.setCustCode(custCode);
						if(custCode == null || custCode == "") {
						//청구요율에 해당하는 거래처코드 자체가 없다면
						}else { //거래처청구요율에 상,하차지,(오더의)거래처코드가 같다면
							custCode = importOrderMngDAO.importCheckOrderCust(gridI);
							//계약기간이 지나면 count = 0;
							if(custCode == null || custCode == "") {
								//tRImportTrOrdtVO.setCustCode(gridI.getCustCode()); //거래처코드 미리 저장해놓고(메시지출력위해)
								//tRImportTrOrdtVO.setJydetail1Code(gridI.getJydetail1Code()); 
								//tRImportTrOrdtVO.setJydetail2Code(gridI.getJydetail2Code());
								//tRImportTrOrdtVO.setCntrTp(gridI.getCntrTp());
								count++;
								//return count;
							}else {
								claimAmt = importOrderMngDAO.importSelectClaimAmt(gridI);
								gridI.setClaimAmt(claimAmt);
								gridList.add(gridI);
							}
						}
					}
				}
				return count;
	}
```
#)xml
```
<!-- 오더번호에 대한 거래처 가져오기(그리드변경사항일때) -->
	<select id="importSelectOrderCust" parameterType="TRImportTrordtVO" resultType="String">
     	SELECT CUST_CODE FROM TRCGEA WHERE 
			   CUST_CODE = (SELECT CUST_CODE FROM TRORDR WHERE ORDER_NO = #{orderNo})
			   AND PICKUP_JY= #{jydetail1Code}
			   AND RETURN_JY= #{jydetail2Code}
			   AND CNTR_TYPE = #{cntrTp}
			   AND IN_OUT = 'I'
			   ORDER BY CUST_APLDAT DESC LIMIT 1
     </select>

     <!-- 오더번호에 대한 거래처 가져오기 -->
	<select id="importCheckOrderCust" parameterType="TRImportTrordtVO" resultType="String">
     	SELECT CUST_CODE FROM TRCGEA
     	<![CDATA[ 
			   WHERE CUST_CODE = #{custCode} 
			   			  AND PICKUP_JY= #{jydetail1Code}
			   			  AND RETURN_JY= #{jydetail2Code}
			   			  AND CNTR_TYPE = #{cntrTp}
				 		  AND (SELECT DATE_FORMAT(SYSDATE(),'%Y%m%d')) >= CUST_APLDAT
				 		  AND (SELECT DATE_FORMAT(SYSDATE(),'%Y%m%d')) <= CONTRACT_TO
				 		  AND IN_OUT = 'I'
				 		  ORDER BY CUST_APLDAT DESC LIMIT 1
		]]>
     </select>

      <!-- 청구요율의 청구금액 가져오기 -->
	<select id="importSelectClaimAmt" parameterType="TRImportTrordtVO" resultType="_double">
     	SELECT
     		<choose>
				 	<when test='"40".equals(cntrSz) and "F".equals(cntrFe)'>
				 	  	C_40FULL_AMT
				 	</when>
				 	<when test='"40".equals(cntrSz) and "E".equals(cntrFe)'>
				 	  	C_40EMPTY_AMT
				 	</when>
				 	<when test='"20".equals(cntrSz) and "F".equals(cntrFe)'>
				 	  	C_20FULL_AMT
				 	</when>
				 	<when test='"20".equals(cntrSz) and "E".equals(cntrFe)'>
				 	  	C_20EMPTY_AMT
				 	</when>
				 	<when test='"45".equals(cntrSz) and "F".equals(cntrFe)'>
				 	  	C_45FULL_AMT
				 	</when>
				 	<when test='"45".equals(cntrSz) and "E".equals(cntrFe)'>
				 	  	C_45EMPTY_AMT
				 	</when>
			</choose>
			FROM TRCGEA
			<![CDATA[
				 	WHERE CUST_CODE = #{custCode}
				 		  AND PICKUP_JY= #{jydetail1Code}
			   			  AND RETURN_JY= #{jydetail2Code}
				 		  AND (SELECT DATE_FORMAT(SYSDATE(),'%Y%m%d')) >= CUST_APLDAT
				 		  AND (SELECT DATE_FORMAT(SYSDATE(),'%Y%m%d')) <= CONTRACT_TO
				 		  AND IN_OUT = 'I'
				 		  ORDER BY CUST_APLDAT DESC LIMIT 1
			]]>
			
     </select>
```
> 여기까지가 상태변화(수정,추가)일때

#)그러나, 상태변화에 따른 분기를 할수가없어서 수정데이터는 컨테이너를 담아놓고 청구금액 로직을 안타게 만들었다. 위에 로직이 있다.
```
        //변경이없을 때라고 로직을 짯지만 사실 일단 0원기준으로
		//상태변화 상관없이 디비에 그냥 접근한다. 0원기준으로 가져온다.
		//formData를 넣는이유는 검색항목에 input hidden에서 headerOrderNo를 헤더클릭할때 넣어놨다.
			var formData = decodeURIComponent($('#frm0').serialize());
			$.ajax({
				url: "/transcls/order/importOrderMng/importOrderSaveCountClaim.do", //통신하실 URL 주소
				data: formData,
				async:false,
				method: "POST" //post형식으로 전달
			}).success(function (data) {
				if(data.status == "fail") {
					//qcell_detail.hideProgress(300); // progress 화면 출력
					alert('에러가 발생하였습니다.')
					return false;
				}
					var findRow;
					//컨테이너번호만 비교하면된다. 청구금액이 0원인지는 이미 자바단에서 걸럿음
					for(var i=0; i<data.gridList.length; i++) {
						//0원인 로우정보를 가져와서 컨테이너번호기준으로 그리드에서 청구금액을 넣기 위한 해당 로우를 찾는다. 
						findRow = qcell_detail.findRow(data.gridList[i].cntrNo,1,5);
						qcell_detail.setCellDataEx(findRow,'claimAmt',data.gridList[i].claimAmt)
					}
					notRegistCost += data.saveCount
					//qcell_detail.hideProgress(300); // progress 화면 출력
			}).error(function (xhr, status, error) {
				qcell_detail.hideProgress(300); // progress 화면 출력
				alert("오류가 발생하였습니다.");
				//실패시 처리
			});
			if(notRegistCost > 0) {
				alert("거래처 청구요율에 계약기간이 유효하지 않은 데이터가 "+notRegistCost+"건 발생하였습니다.");
			}
```
#)controller
```
/**
     * 오더관리 > 수입(detail) - 청구금계산
     * @param Map<String,Object> vo
     * @return 출력페이지정보 "selectImportOrderMng"
     * @exception Exception
     */
    @NoLogging				 
	@RequestMapping(value = "/transcls/order/importOrderMng/importOrderSaveCountClaim.do")
	public@ResponseBody HashMap<String, Object> importOrderSaveCountClaim(@ModelAttribute("tRImportTrOrdtVO") TRImportTrordtVO tRImportTrOrdtVO, @RequestParam Map<String,Object> vo, ModelMap model) throws Exception {
    	LoginVO user = (LoginVO) EgovUserDetailsHelper.getAuthenticatedUser();
    	HashMap<String, Object> resMap = new HashMap<String, Object>();
    	List<TRImportTrordtVO> saveCountClaim = new ArrayList<TRImportTrordtVO>();
		try {	
			
			tRImportTrOrdtVO.setLoginJijum(user.getJijum()); 
			//기존에 저장되있는 디테일에서 청구금계산눌렀을 때
			//비어있는 saveCountClaim(리스트)를 넘기는이유는 청구금을계산해서 담기위해
			int saveCount = importOrderMngService.importSaveCountClaim(tRImportTrOrdtVO,saveCountClaim);
				Function fn = new Function();
				JSONArray jsonArr = null;
				resMap.put("gridList", saveCountClaim);
				resMap.put("saveCount", saveCount);
		}catch(Exception e) {
			resMap.put("status", "fail");
			e.printStackTrace();
		}
		return resMap;
	}
```
#)impl
```
/**
     * 오더관리 디테일 저장 전 청구요율에 거래처가 있는지 확인
     * @param TRImportTrordtVO tRImportTrOrdtVO
     * @return 출력페이지정보 "selectimportOrderMng"
     * @exception Exception
     */
	@SuppressWarnings({ "unchecked", "unused" })
	@Override
	public int importSaveCountClaim(TRImportTrordtVO tRImportTrOrdtVO,List<TRImportTrordtVO> gridList) throws Exception {
		
		LoginVO user = (LoginVO)EgovUserDetailsHelper.getAuthenticatedUser(); // 현재 로그인한 계정정보 가져오기

		int count = 0;
		List<TRImportTrordtVO> zeroCountClaimGridList = null;
		
		//저장되있는 컨테이너 중에 0원인 청구금액의 그리드에 청구금액을 변경해서 담을것이다. 
		TRImportTrordtVO zeroCountClaimGrid = new TRImportTrordtVO();
		
		String custCode = null;
		String custCodeMessage = null;
		double claimAmt = 0.0;
		String[] arr;
		//오더번호를 이용해서 청구요율에서 가져온 custCode는 상,하차,tp까지 같아야 가져온다.
		//상,하차,tp를 가져오려면 오더번호를 이용해서 디테일을 가져와야한다. 디테일이 0원인것만
        //0원짜리 청구금액 ORDT를 가져온다 지점과같이(청구요율때문에).
		zeroCountClaimGridList = importOrderMngDAO.importSelectZeroSaveDetail(tRImportTrOrdtVO);
		//아래는 document.getElementById("updateCntr") 에서 가져옴.
		if(tRImportTrOrdtVO.getUpdateCntr() != null) { //수정한컨테이너가 있다면
			arr = tRImportTrOrdtVO.getUpdateCntr().split(",");
			//수정한 컨테이너들은 제외
			for(int i = 0; i<zeroCountClaimGridList.size(); i++) {
				for(int j = 0; j<arr.length; j++) {
					if(arr[j].equals(zeroCountClaimGridList.get(i).getCntrNo())) {
						zeroCountClaimGridList.remove(i);
					}
				}
			}
		}//수정한컨테이너들은 제외한 0원 한줄
			for(int i = 0; i<zeroCountClaimGridList.size(); i++) {
				custCode = importOrderMngDAO.importSelectSaveOrderCust(zeroCountClaimGridList.get(i));
				//custCodeMessage = custCode;
				if(custCode == null || custCode == "") {
					//날짜제외 오더에서구한 거래처,상,하차지,tp가 일치하는게 없다면 청구요율에 해당하는 거래처코드 자체가 없다면 그냥 아무알람안띄움
				}else { //거래처청구요율에 상,하차지,(오더의)거래처코드가 있다면
					//계약기간비교해서 거래처코드를 가져온다
					zeroCountClaimGridList.get(i).setCustCode(custCode);
					custCodeMessage = importOrderMngDAO.importCheckSaveOrderCust(zeroCountClaimGridList.get(i));
					//계약기간이 지나면 count = 0;
					if(custCodeMessage == null || custCodeMessage == "") {
						//tRImportTrOrdtVO.setCustCode(custCode); //거래처코드 미리 저장해놓고(메시지출력위해)
						//tRImportTrOrdtVO.setJydetail1Code(zeroCountClaimGridList.get(i).getJydetail1Code()); 
						//tRImportTrOrdtVO.setJydetail2Code(zeroCountClaimGridList.get(i).getJydetail2Code()); 
						//tRImportTrOrdtVO.setCntrTp(zeroCountClaimGridList.get(i).getCntrTp());
						count++; //몇건이 기간에 안맞는지.
					}else {
						claimAmt = importOrderMngDAO.importSelectClaimAmt(zeroCountClaimGridList.get(i));
						zeroCountClaimGridList.get(i).setClaimAmt(claimAmt);
						gridList.add(zeroCountClaimGridList.get(i));
					}
				}
			}
			return count;
	}
```
#)xml
```
<!-- 오더번호에 매칭되는 디테일 가져오기(청구금계산을위해) -->
	<select id="importSelectZeroSaveDetail" parameterType="TRImportTrordtVO" resultType="TRImportTrordtVO">
     	SELECT
			A.OR_DATE
  		   ,B.ORDER_NO
 	 	   ,B.TRANS_DATE
  		   ,UPPER(B.CNTR_NO) AS cntrNo
  		   ,B.CNTR_SZ
  		   ,B.CNTR_TP
  		   ,B.CNTR_FE
  		   ,B.CNTR_SEAL
  		   ,B.CNTR_SEAL2
  		   ,B.PICKUP_JY AS jydetail1Code
  		   ,B.RETURN_JY AS jydetail2Code
  		   ,B.AREA_JY AS jydetail3Code
  		   ,(select c_kname FROM TRBACD WHERE c_head='JY' AND c_detail=B.PICKUP_JY) AS jydetail1Name
  		   ,(select c_kname FROM TRBACD WHERE c_head='JY' AND c_detail=B.RETURN_JY) AS jydetail2Name
  		   ,(select c_kname FROM TRBACD WHERE c_head='JY' AND c_detail=B.AREA_JY) AS jydetail3Name
  		   ,B.CLAIM_AMT
  		   ,B.COMBIN
  		   ,B.BACA_ID AS userId
  		   ,B.BACA_NAME AS userName
  		   ,B.REMARK
  		   ,B.INSERT_ID
           ,B.JIJUM AS loginJijum
		FROM TRORDR A, TRORDT B
		WHERE B.ORDER_NO = A.ORDER_NO  
		AND   A.OR_DIVISION = 'I' 
		AND   B.ORDER_NO = #{headerOrderNo}
		AND   B.JIJUM = #{loginJijum}
		AND   B.CLAIM_AMT = 0
     </select>

     <!-- 오더번호에 대한 거래처 가져오기(저장되있는) -->
	<select id="importSelectSaveOrderCust" parameterType="TRImportTrordtVO" resultType="String">
     	SELECT CUST_CODE FROM TRCGEA WHERE 
			   CUST_CODE = (SELECT CUST_CODE FROM TRORDR WHERE ORDER_NO = #{orderNo})
			   AND PICKUP_JY= #{jydetail1Code}
			   AND RETURN_JY= #{jydetail2Code}
			   AND CNTR_TYPE = #{cntrTp}
			   AND IN_OUT = 'I'
               AND JIJUM = #{loginJijum} //거래처청구요율은 지점기준으로 구분해야한다.
			   ORDER BY CUST_APLDAT DESC LIMIT 1
     </select>

     <!-- 위와 차이는 위에꺼는 날짜를 비교하지않고 거래처가 있는지만 비교한다. -->
     <select id="importCheckSaveOrderCust" parameterType="TRImportTrordtVO" resultType="String">
     	SELECT CUST_CODE FROM TRCGEA
     	<![CDATA[ 
			   WHERE CUST_CODE = #{custCode} 
			   			  AND PICKUP_JY= #{jydetail1Code}
			   			  AND RETURN_JY= #{jydetail2Code}
			   			  AND CNTR_TYPE = #{cntrTp}
				 		  AND (SELECT DATE_FORMAT(SYSDATE(),'%Y%m%d')) >= CUST_APLDAT
				 		  AND (SELECT DATE_FORMAT(SYSDATE(),'%Y%m%d')) <= CONTRACT_TO
				 		  AND IN_OUT = 'I'
                          AND JIJUM = #{loginJijum}
				 		  ORDER BY CUST_APLDAT DESC LIMIT 1
		]]>
     </select>
```
#)수입오더관리 ctrl+s 눌렀을 때 마스터,디테일 둘다 저장해야한다.<br>
단, 변화가 있어야한다.<br>
1. 디테일만 변화가있다하면 디테일만 저장
2. 마스터,디테일 둘다 변화가있으면 마스터먼저 저장 후 디테일 저장
3. 변화가 없으면 alert("변화된 항목이 없습니다") 띄우기

쪼개서 볼것이다.
```
	$(document).keydown(function(e) {
		var qcell_master = QCELL.getInstance("qcell_master");
		var qcell_detail = QCELL.getInstance("qcell_detail");
		//ctrl+s를 눌렸을 때
		if((e.which == '115' || e.which =='83') && (e.ctrlKey || e.metaKey)){
			e.preventDefault(); //브라우저 저장 창 띄우기 막기
```
```
	$(document).keydown(function(e) {
		var qcell_master = QCELL.getInstance("qcell_master");
		var qcell_detail = QCELL.getInstance("qcell_detail");
		if((e.which == '115' || e.which =='83') && (e.ctrlKey || e.metaKey)){
			e.preventDefault();
			//{"d":[],"i":[],"u":[]} -->JSON.parse--> {d:[],i:[],u:[]} 
			let insertArrayMaster = JSON.parse(document.getElementById('paramMaster').value).i;
			let updateArrayMaster = JSON.parse(document.getElementById('paramMaster').value).u;
			let deleteArrayMaster = JSON.parse(document.getElementById('paramMaster').value).d;
			let insertArrayDetail = JSON.parse(document.getElementById('paramDetail').value).i;
			let updateArrayDetail = JSON.parse(document.getElementById('paramDetail').value).u;
			let deleteArrayDetail = JSON.parse(document.getElementById('paramDetail').value).d;
			//아무런 변화상태가 없으면
			if(insertArrayMaster.length == 0 && updateArrayMaster.length == 0 && deleteArrayMaster.length == 0 &&
				insertArrayDetail.length == 0 && updateArrayDetail.length == 0 && deleteArrayDetail.length == 0) {
					alert('변화된 내용이 없습니다.');
				return false;
			}
```
```
//insert가 있다면 마스터 먼저 필수값 체크
if(insertArrayMaster.length > 0) {
  for(var k = 0; k<insertArrayMaster.length; k++) {
	if(insertArrayMaster[k].data.cntlCode == '' || insertArrayMaster[k].data.cntlCode == null) {
		alert('구분값은 빈값이 될 수 없습니다.')
		return false;	
	}
	if(insertArrayMaster[k].data.cntlCode.replace(/\s| /gi,'') == '') {
		alert('구분값은 빈값이 될 수 없습니다.')
		return false;					
	}
  }
}
//insert가 있다면 디테일 필수값 체크
if(insertArrayDetail.length > 0) {
	for(var k = 0; k<insertArrayDetail.length; k++) {
		if(insertArrayDetail[k].data.cntrNo == '' || insertArrayDetail[k].data.cntrNo == null) {
			alert('컨테이너 번호는 빈값이 될 수 없습니다.')
			return false;	
		}
		if(insertArrayDetail[k].data.cntrNo.replace(/\s| /gi,'') == '') {
			alert('컨테이너 번호는 빈값이 될 수 없습니다.')
			return false;					
		}
		if(insertArrayDetail[k].data.cntrNo.length > 11) {
			alert('컨테이너번호는 11자리가 초과할 수 없습니다.')
			return false;
		}
	}
}
```
```
if(confirm("지금 작업화면을 저장하시겠습니까?")) {
	//frm0 폼에는 아래항목이 추가되었다. 즉, qcellChange될때마다 각각 맞게 들어간다. 
	//<input type="hidden" id="paramDetail" name="paramDetail">
	//<input type="hidden" id="paramMaster" name="paramMaster">
	
	var formData = decodeURIComponent($('#frm0').serialize());
	var bacaLinkOrderNoList;
	$.ajax({
			url: "/transcls/order/importOrderMng/importOrderMultiUpdateAll.do", //통신하실 URL 주소
			data: formData, //서버에 param이라는 parameter명으로 JSON String형태로 수정 정보 전달
			async: false,
			method: "POST" //post형식으로 전달
		}).success(function (data) {
			if(data.status == "fail") {
				alert('에러가 발생하였습니다.')
				return false;
			}
			var gridData = data.gridList;//디테일그리드
			var gridDataHeader = data.gridListHeader; //헤더그리드
			bacaLinkOrderNoList = data.bacaLinkOrderNoList; //배차판에 등록된 오더번호 모음집(메시지띄워주기위한)
			createQCELL_master(gridDataHeader);
			//createQCELL_detail(gridData);	
			//이걸 왜 주석처리했냐면 헤더에내가 포커스를 강제로 지정할것이다.(아래참조)
			//즉, 헤더에 포커스 처리하면 디테일도 알아서 나오니까
		}).error(function (xhr, status, error) {
			alert("오류가 발생하였습니다.");
			//실패시 처리
		});
	}else {	//"화면을 저장하시겠습니까?" 취소선택시 아무로직없음		
}
```
```
if(bacaLinkOrderNoList.length > 0) {
	var messageOrderList=''; //이렇게 빈값 선언안하면 String에서  += 를 붙이면 undefined뜬다.
	qcell_master = QCELL.getInstance("qcell_master"); 
	//이렇게 또 선언한이유는 위에서 저장할때 createQcell_master를 했기때문에 
	//새로운 값이 되기때문에 다시 받아서 변수에 넣었다. - 포커스를 위해
	for(var i = 0; i<bacaLinkOrderNoList.length; i++) {
		messageOrderList+=bacaLinkOrderNoList[i]
		if(i != bacaLinkOrderNoList.length-1) {
			messageOrderList += ","
		}
	}
	alert(messageOrderList+'는 이미 배차상황판에 등록되어서 변경이 불가능합니다.')
	var sRow = document.getElementById('sRow').value
	qcell_master.focusCell(Number(sRow),6); //col은 변경가능한 곳으로 지정해줘야 포커스가 간다.
	}else {
		var sRow = document.getElementById('sRow').value
		alert('저장되었습니다.')
		qcell_master = QCELL.getInstance("qcell_master");
		//console.log(qcell_master.getCellData(1,6)) 화물관리번호가나온다.(체크박스가 0부터시작)
		qcell_master.focusCell(Number(sRow),6); //col은 변경가능한 곳으로 지정해줘야 포커스가 간다.
	}
```
#)Controller
```
/**
  * 오더관리 > 단축키 일괄저장
  * @param Map<String,Object> vo
  * @return 출력페이지정보 "selectImportOrderMng"
  * @exception Exception
*/
@NoLogging				 
@RequestMapping(value = "/transcls/order/importOrderMng/importOrderMultiUpdateAll.do")
public@ResponseBody HashMap<String, Object> importOrderMultiUpdateAll(
	@ModelAttribute("tRImportTrOrdtVO") TRImportTrordtVO tRImportTrOrdtVO, 
	@ModelAttribute("tRImportOrderMngVO") TRImportOrderMngVO tRImportOrderMngVO,
	@RequestParam Map<String,Object> vo,
	ModelMap model) throws Exception {
        	LoginVO user = (LoginVO) EgovUserDetailsHelper.getAuthenticatedUser();
        	HashMap<String, Object> resMap = new HashMap<String, Object>();
        	List<String> bacaLinkOrderNoList = new ArrayList<String>(); //빈 배열(impl에서 값받아옴)
        	try {	
    			tRImportTrOrdtVO.setLoginJijum(user.getJijum()); 
    			tRImportOrderMngVO.setLoginJijum(user.getJijum());
    			List<?> gridList = null;
    			Function fn = new Function();
    			JSONArray jsonArr = null;
    			JSONArray jsonArrHeader = null;
    		//detail일괄저장 시 tRImportTrOrdtVO가 필요, master일괄저장시 bacaLinkOrderNoList를 던진다.
    		importOrderMngService.importOrderMultiUpdateAll(vo,tRImportTrOrdtVO,bacaLinkOrderNoList);
```
```
//indexOf
자바스크립트는 if() 에서 false기준이 false, null, 0, NaN, undefined,'' 이렇게인데
즉 -1,1.. 0을 제외한 어떤 숫자가 들어가도 true라는 말이다.

const str = "abab";

document.writeln(str.indexOf('ab')); // 0
document.writeln(str.indexOf('ba')); // 1 (첫인덱스를 찾아간다)
document.writeln(str.indexOf('abc')); // -1
document.writeln(str.indexOf('AB')); // -1
```
```
encodeURIComponent는 javascript에서 string을 UTF-8로 인코딩해주는 함수이다.<br>
보통 http로 주소를 전송할 때, 넘겨야하는 변수 값 중간에 &나 #이 있으면 변수값이 제대로 전달되지 않기때문에

왜냐하면 주소에서 &는 파라미터 연결의 의미이기때문에

그래서 인코딩을 해줘야할 필요성이 생긴다. 

서버의 기본 문자 인코딩 타입이 UTF-8이라면 문제가 없이 한글이 깨지지 않지만,
그 외의 인코딩타입이 기본 문자셋이라면 한글이깨진다(MS949 등)

public void test() throws UnsupportedEncodingException {

  String a = "건강·의학";
  a = URLEncoder.encode(a, "UTF-8");
  log.info("encode : " + a);  //%EA%B1%B4%EA%B0%95%C2%B7%EC%9D%98%ED%95%99
  a = URLDecoder.decode(a, "MS949"); 
  log.info("decode : " + a);  //嫄닿컯쨌?쓽?븰
  a = URLEncoder.encode(a, "MS949"); //위에서 MS949로 디코딩된걸 다시 encode해서 
  log.info("encode : " + a);  //%EA%B1%B4%EA%B0%95%C2%B7%3F%9D%98%3F%95%99
  a = URLDecoder.decode(a, "UTF-8"); //복구할려했지만 그래도 꺠짐...
  log.info("decode : " + a);  //건강·??????
}

처음에 UTF-8로 인코딩 한 상태가 javascript에서 encodeURIComponent함수를 이용하여 인코딩한 결과와 같다.
그리고 서버에서는 MS949로 디코딩을 자동으로 수행하게 된다. (서버의 기본 캐릭터 셋이 MS949일 때)
그래서 결국 "건강·의학"이라는 글자는 "嫄닿컯쨌?쓽?븰" 이라는 알 수 없는 알 수 없는 글자로 깨지게 되고,
이를 다시 복구하기 위해 MS949로 인코딩을 해보았지만,
처음 javascript에서 encodeURIComponent 함수를 이용하여 인코딩 한 결과와 정확히 일치하지 않는다.(위에 빨간글자)
UTF-8로 인코딩한 한글 문자열을 MS949로 디코딩할 때는 이미 캐릭터의 byte값이 알 수 없는 정보로 저장되며,
다시 인코딩을 한다고 해서 원복이 되지 않는 것 같다.
```

```
URI를 인코딩해서 보낼때 어떤 함수를 사용해야 할까?
--> URI 전체를 인코딩 할때는 encodeURI()를 사용하고 URI 파라메터를 인코딩 할때는 encodeURIComponent()를 사용하면 된다.

 

encodeURI는 알파벳, 0~9의 숫자, ; , / ? : @ & = + $ #    - _ . ! ~ * ' ( ) 를 제외한 문자를 인코딩(이스케이프 처리)

encodeURIComponent는 알파벳,0~9의 숫자 - _ . ! ~ * ' ( ) 를 제외한 문자를 이스케이프 처리

 

encodeURIComponent는 / ? : @ & = + $ # 도 이스케이프 처리를 해버리는데 & ? 와 같이 uri에서 특수한 기능을 하는 문자는( ex. &는 uri에서 다음 파라메터를 나타냄) 인코딩 하면 안 되므로 path 전체를 인코딩 할때는 encodeURI를 사용.

그리고 파라미터 값에 & 등의 특수문자가 값으로 들어갈 때는 인코딩 해줘야 하므로 파라미터 값에는 encodeURIComponet 사용

 

예시)

https://javascript.com?name=co&ding 

파라메터로 들어가는 name의 value에 &이 들어가므로 encodeURIComponent를 사용하여 인코딩 해줘야 한다.

+

파라메터 값에 & 등의 특수한 기능을 하는 문자가 들어가는 경우 encodeURI로 전체를 인코딩하는 경우 문제가 생길 수 있으므로 파라메터가 표함되지 않은 path부분("http://javascript.com?name=")은 값자체로 넘겨주고 파라메터만 encodeURIComponent를 사용해서 인코딩하는 방법을 추천합니다.

const name = "co&ding";		//uri의 파라메터 name으로 들어갈 값
const uri = "https://javascript.com?name=" + encodeURIComponent(name); //파라메터 값만 인코딩
```
<img src="https://github.com/seongdongjo/JavaStudy/blob/main/%EB%A1%9C%EC%A7%81%EC%A0%95%EB%A6%AC/2.PNG" width="600" height="100" /><br><br>



```
한글이 깨지는 현상은 인코딩을 두번해주면된다.(서버의 인코딩이 UTF-8이 아니면)
content = encodeURIComponent(content); 
name =encodeURIComponent(name); 

var params = "name= "+encodeURIComponent(name)+"&content="+encodeURIComponent(content)+"&board_idx="+encodeURIComponent(board_idx);
```
```

String a = "test&한글";
System.out.println("originA= "+a); //test&한글
a = URLEncoder.encode(a, "UTF-8"); //인코딩 2번해준다.
a = URLEncoder.encode(a, "UTF-8"); 
System.out.println("a= "+a); //a= test%2526%25ED%2595%259C%25EA%25B8%2580
a = URLDecoder.decode(a, "MS949");
System.out.println("a= "+a); //a= test%26%ED%95%9C%EA%B8%80
a = URLDecoder.decode(a, "UTF-8");
System.out.println(a); //originA= test&한글

```
```
$('#frm0').serialize() 를 보면 기본적으로 encodeURIComponent()함수처리(인코딩)는 해주는데,
- _ . ! ~ * ' ( ) 문자들은 제외하고 인코딩해주는걸 볼수있다. 그렇기때문에 VO에 담길때 디코딩되서 잘담긴다.
허나, - _ . ! ~ * ' ( ) 문자들은 희한하게 VO에 보면 &apos&#40&#41 이렇게 거꾸로 인코딩이 되어 들어가있다.

그래서 serialize()를 분석해보니까 remark%22%3A%22'() -> remark":"'() 
즉, - _ . ! ~ * ' ( )는 인코딩을 안한걸 볼수가 있다. 

근데 왜 &apos이런형식으로 vo에 담길까? -> 바로 자바단에서 filter에 <, >, ', (, ) 들은
replace써서 바꾸게끔 되있어서 vo에 담기기전에 변환되서 담기기때문에 &apos형식으로 바뀐다.
이거는 xss 보안취약점때문에 그런거같다.

실제로 
console.log(encodeURIComponent('(')) 이렇게 해보면 그냥 ( 이렇게 결과가 나온다.(encodeURI도마찬가지)

vo에 담긴걸 보면 ' ( ) 문자들만 희한하게 인코딩? 실제로 검색해보니 특수코드 HTML로 
되서들어가는걸볼수있다 인코딩이아니라
입력: ;,/?:@&=+$#-_.!~*&apos;&#40;&#41;
"remark":";,/?:@&=+$#-_.!~*&apos;&#40;&#41;","insertIp":"0:0:0:0:0:0:0:1",

그렇다면 현재 또 문제는 (주)청솔 이렇게넣으면 DB단에서 REPLACE(%41%42) 머 이렇게를 써서 해야하는 번거러움이있다.




//ajax로 data를 보낼때 문제가 %같은 문자가 들어가면 에러가난다는것이였는데
//$('#frm0').serialize() 이거 자체로 UTF-8 인코딩이다. -> 이걸 그대로 넘겨주면된다.
//decodeURIComponent($('#frm0').serialize()) 이렇게하면 인코딩한걸 디코딩한다. 여기까지는 문제없는데
//서버에 넘어갈때 서버측에서 디코딩을해서 자동으로 vo에 담는데 %할증이라는 문자가 들어가있으면 서버는 자동으로 VO에 담을려고할때 디코딩을 할려고하면서 %문자가 디코딩이 안되기때문에 vo에 안담기면 에러발생.


var formData = decodeURIComponent($('#frm0').serialize());
		var formData1 = encodeURIComponent($('#frm0').serialize())
		console.log($('#frm0').serialize())
		console.log(encodeURIComponent($('#frm0').serialize()))
		console.log(encodeURI($('#frm0').serialize()))
		$.ajax({
			url: "/transcls/car/carMng/carMngMultiUpdate.do", //통신하실 URL 주소
			data: $('#frm0').serialize(),
```
```
serialize를 쓰면 아래처럼

schCarCode=1001&schCarName=쌍용
이렇게되는데
여기서 %나 &같은 문자가 들어가면
schCarCode=10&01&schCarName=쌍%용
schCarCode=10%2601&schCarName=쌍%25용

이렇게 바뀐다. 쉽게 serialize는 한마디로 encodeURIComponent() 인코딩처리를 해준다!!!
인코딩되어서 vo에 담길때는 디코딩되기때문에 문자그대로 담기는걸 볼수가있다. 
즉, -_.!~*; , / ? : @ & = + $ # % 이 문자들은 그대로 나오고 '(&apos) ( )  들은 인코딩처리한다.
```

```
그럼, %문자는 진짜 디코딩에서 에러가 발생하는 걸까?..

String a = "!@#$^&*()_+-=";
a = URLDecoder.decode(a, "UTF-8");
System.out.println(a);

//결과 +는 디코딩이 되어서 공백으로 처리된걸볼수있다)
!@#$^&*()_ -=  



String a = "!@#$^&*()_+%-=";
a = URLDecoder.decode(a, "UTF-8");
System.out.println(a);

//결과 (%가 들어가면 디코딩에서 바로 에러발생)
Exception in thread "main" java.lang.IllegalArgumentException: URLDecoder: Illegal hex characters in escape (%) pattern - Error at index 1 in: "-="
	at java.base/java.net.URLDecoder.decode(URLDecoder.java:232)
	at java.base/java.net.URLDecoder.decode(URLDecoder.java:142)
	at byteLength.ByteLegth.main(ByteLegth.java:18)
```
---
```
#)대시보드 로직

아래와 쿼리와 같이 20231101을 어제로 가정, 20231102를 오늘로 가정할때
그래프로 표현하려면 selectBachaId에서 가져온 해당날짜(어제,오늘)에 올린 모든유저들을 가져온다(지점1번만)
왜냐하면 짝을 맞추기위해서 (어제올린사람이 오늘안올릴수있으니 일단 어제,오늘 유저다 받고 안올렸으면 0으로채우면되니까)

어제: 위에서 가져온 유저리스트를 기준으로(selectBachaId) 어제리스트의(selectBachaCont) id를 비교하여
	  해당 id가 다르면 어제리스트에 id,count추가

오늘: 위에서 가져온 유저리스트를 기준으로(selectBachaId) 오늘리스트의(selectBachaCountToday) id를 비교하여 해당 id가 다르면 오늘리스트에 id,count추가

즉, userList =      [CSL1004, CSL1006, DWE1005]
  bachaDash =      [CLS1004, CSL1006, DWE1005]
  bachaDashToday = [CLS1004, CSL1006, DWE1005]
이렇게 userList가 나와야되고 count가0 이여도 나와야한다. 그래야 데이터가 유저에 맞게 안밀리고 찍히기 때문이다.


//어제
<select id="selectBachaCount" parameterType="LoginVO" resultType="TRMainVO">
	<![CDATA[
    	SELECT INSERT_ID AS bachaInsertId, BA_DATE, COUNT(*) AS bachaCount FROM TRBACA
		WHERE JIJUM = #{jijum}
		 AND BA_DATE = '20231101'
		GROUP BY INSERT_ID, BA_DATE
		HAVING COUNT(*) > 0
    ]]>
</select>

//오늘
<select id="selectBachaCountToday" parameterType="LoginVO" resultType="TRMainVO">
    <![CDATA[
    	SELECT INSERT_ID AS bachaInsertId, BA_DATE, COUNT(*) AS bachaCount FROM TRBACA
		WHERE JIJUM = #{jijum}
		 AND BA_DATE = '20231102'
		GROUP BY INSERT_ID, BA_DATE
		HAVING COUNT(*) > 0
]]>
</select>
<select id="selectBachaId" parameterType="LoginVO" resultType="TRMainVO">
    <![CDATA[
    	SELECT DISTINCT(INSERT_ID) AS bachaInsertId FROM TRBACA
		WHERE JIJUM = #{jijum}
		 AND BA_DATE BETWEEN '20231101' AND '20231102'
		GROUP BY INSERT_ID, BA_DATE
		HAVING COUNT(*) > 0
    ]]>
</select>
```
```
#)대시보드 배차 로직-컨트롤러

TRMainVO tempVO = new TRMainVO();
tempVO.setBachaCount(0); //배차횟수가 없으면 COUNT를 0으로 맞춰서 그래프에 찍힐수있도록 하기위해
List<TRMainVO> bachaId = mainService.selectBachaId(user);
List<TRMainVO> bachaDash = mainService.selectBachaCount(user);
List<TRMainVO> bachaDashToday = mainService.selectBachaCountToday(user);

//맨 밑쪽에 보면
//if(bachaDash.size()-1 < i) 하는 이유는
예를들어 userList = [CSL1005,CSL1006]
	    bachaDash = []
		bachaDashToday = [CSL1005,CSL1006] 일때
bachaDash 사이즈는 0이고 여기서 bachaDash.size-1은 -1이 나오면서 i=0이기때문에 해당 분기문을 탄다.
즉, bachaDash에 tempVO를 넣는것이다

또, bachaDash사이즈가 0이 아닐때도 마찬가지이다. 

//if(!bachaId.get(i).getBachaInsertId().equals(bachaDash.get(i).getBachaInsertId())) 하는 이유
userList는 bachaDash와 bachaDashToday를 합친것이다. 날짜별이나 정렬을 안해도되는이유는 이 사람이
어제올리든오늘올리든 그거를 정렬하는게 아니라 어제든오늘이든 id를 넣어주면 출력될떄는
어제든오늘이든 정렬상관없이 같이 찍히니까

즉, userList에 어제,오늘 담겨있는 id들과 하나씩비교(각각 어제리스트, 오늘리스트)하면서 없으면 채우는 방식이다.

bachaId는 어제,오늘전체 id
bachaDash는 어제
bachaDashToday는 오늘

if(bachaId.size() > 0) { 
		for(int i = 0; i<bachaId.size(); i++) {
			if(bachaDash.size()-1 < i) { //사이즈보다 가져오려고하는 인덱스가 클때 
							tempVO.setBachaInsertId(bachaId.get(i).getBachaInsertId());
							bachaDash.add(i, tempVO); //어제에 넣는다.
			}
			if(bachaDashToday.size()-1 < i) { //사이즈보다 가져오려고하는 인덱스가 클때 
							tempVO.setBachaInsertId(bachaId.get(i).getBachaInsertId());
							bachaDashToday.add(i, tempVO);
			}
			if(!bachaId.get(i).getBachaInsertId().equals(bachaDash.get(i).getBachaInsertId())) {
							tempVO.setBachaInsertId(bachaId.get(i).getBachaInsertId());
							bachaDash.add(i, tempVO);
			}
			if(!bachaId.get(i).getBachaInsertId().equals(bachaDashToday.get(i).getBachaInsertId())) {
							tempVO.setBachaInsertId(bachaId.get(i).getBachaInsertId());
							bachaDashToday.add(i, tempVO);
			}
		}
	}
	
	resMap.put("bachaDash", bachaDash);
	resMap.put("bachaId", bachaId);
	resMap.put("bachaDashToday", bachaDashToday);
```
```
//바 차트 간단한 예시
<div>
	<canvas id="myChart"></canvas>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  const ctx = document.getElementById('myChart');

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange'], //x축 표시
      datasets: [{
        label: '# of Votes',
        data: [12, 19, 3, 5, 2, 3],
        borderWidth: 1
      }]
    },
    options: {
      scales: {
        y: {
          beginAtZero: true
        }
      }
    }
  });
</script>
```
```
//대시보드 매출액현황-연간 매출,비용,수익 합 테이블
<select id="selectYearMaechulList" resultType="TRMainMaechulTableVO">
    	SELECT CONCAT(SUBSTR(ACC_YYMM,1,4),'년') AS ACC_YYMM, SUM(A.SALE_AMT) AS CREDIT_SUM, SUM(A.COST_AMT) AS DEBTOR_SUM, 
                 SUM(A.SALE_AMT) - SUM(A.COST_AMT) AS SUIK_SUM
      FROM(
         SELECT ACC_YYMM,  //작년은 마감테이블에서
                CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN (CREDIT_AMT - DEBTOR_AMT) ELSE 0 END AS SALE_AMT,
                CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN 0 ELSE (DEBTOR_AMT - CREDIT_AMT) END AS COST_AMT
           FROM TRMMBA
          WHERE ACC_YYMM LIKE CONCAT(REPLACE(SUBSTR(ADDDATE(DATE_FORMAT(NOW(),'%Y-%m-%d'), INTERVAL -1 YEAR),1,4),'-',''),'%') 
            AND ACC_YYMM NOT IN(CONCAT(REPLACE(SUBSTR(ADDDATE(DATE_FORMAT(NOW(),'%Y-%m-%d'), INTERVAL -1 YEAR),1,4),'-',''),'00')) 
            AND ( ACCO_CODE BETWEEN '501' AND '504'
               OR ACCO_CODE BETWEEN '601' AND '602'
               OR ACCO_CODE BETWEEN '701' AND '748' )
               
         UNION ALL  //올해는 trslip 테이블에서
         SELECT SUBSTR(SLIP_DATE,1,6) AS ACC_YYMM,
                CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN (CREDIT_AMT - DEBTOR_AMT) ELSE 0 END AS SALE_AMT,
                CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN 0 ELSE (DEBTOR_AMT - CREDIT_AMT) END AS COST_AMT
            FROM TRSLIP
          WHERE SLIP_DATE LIKE CONCAT(SUBSTR(DATE_FORMAT(NOW(),'%Y%m%d'),1,4),'%')
            AND ( ACCO_CODE BETWEEN '501' AND '504'
               OR ACCO_CODE BETWEEN '601' AND '602'
               OR ACCO_CODE BETWEEN '701' AND '748' )
         ) A //A로 별칭
      GROUP BY SUBSTR(ACC_YYMM,1,4)
</select>
```
```
//대시보드-월간 매출,비용,수익, 합 테이블(전월,당월)
//전월은 마감테이블에서가져오고 501~504는 대변만 금액이있다.601~748까지는 차변금액만있는데
//719(지급임차료),731(지급수수료(장비))는 대변(CRE)에 들어가있고 차변은 0원.그래서 그거는 마이너스하고있다.
<select id="selectMonthMaechulList" resultType="TRMainMaechulTableVO">
    	SELECT CONCAT(CONCAT(SUBSTR(ACC_YYMM,1,4),'년'),CONCAT(SUBSTR(ACC_YYMM,5,6),'월')) AS ACC_YYMM, 
		 SUM(A.SALE_AMT) AS CREDIT_SUM, 
		 SUM(A.COST_AMT) AS DEBTOR_SUM, 
       SUM(A.SALE_AMT) - SUM(A.COST_AMT) AS SUIK_SUM
      FROM(
         SELECT ACC_YYMM,
                CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN (CREDIT_AMT - DEBTOR_AMT) ELSE 0 END AS SALE_AMT,
                CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN 0 ELSE (DEBTOR_AMT - CREDIT_AMT) END AS COST_AMT
           FROM TRMMBA
          WHERE ACC_YYMM = REPLACE(SUBSTR(ADDDATE(DATE_FORMAT(NOW(),'%Y-%m-%d'), INTERVAL -1 MONTH),1,7),'-','')
            AND ( ACCO_CODE BETWEEN '501' AND '504'
               OR ACCO_CODE BETWEEN '601' AND '602'
               OR ACCO_CODE BETWEEN '701' AND '748' )
               
         UNION ALL //당월은 TRSLIP에서
         SELECT SUBSTR(SLIP_DATE,1,6) AS ACC_YYMM, 
                CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN (CREDIT_AMT - DEBTOR_AMT) ELSE 0 END AS SALE_AMT,
                CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN 0 ELSE (DEBTOR_AMT - CREDIT_AMT) END AS COST_AMT
            FROM TRSLIP
          WHERE SLIP_DATE LIKE CONCAT(SUBSTR(DATE_FORMAT(NOW(),'%Y%m%d'),1,6),'%')
            AND ( ACCO_CODE BETWEEN '501' AND '504'
               OR ACCO_CODE BETWEEN '601' AND '602'
               OR ACCO_CODE BETWEEN '701' AND '748' )
         ) A
      GROUP BY SUBSTR(ACC_YYMM,1,6)
</select>
```
```
//대시보드-매출,비용,수익 차트
<select id="selectMaechulChartList" resultType="TRMainMaechulChartVO">
    	SELECT  CONCAT(CONCAT(SUBSTR(ACC_YYMM,1,4),'/'),SUBSTR(ACC_YYMM,5,6)) AS ACC_YYMM, 
    			SUM(A.SALE_AMT) AS CREDIT_SUM, 
    			SUM(A.COST_AMT) AS DEBTOR_SUM, 
            	SUM(A.SALE_AMT) - SUM(A.COST_AMT) AS SUIK_SUM
		FROM (
			SELECT ACC_YYMM,
					 CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN (CREDIT_AMT - DEBTOR_AMT) ELSE 0 END AS SALE_AMT,
                CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN 0 ELSE (DEBTOR_AMT - CREDIT_AMT) END AS COST_AMT
           FROM TRMMBA
			 WHERE ACC_YYMM BETWEEN REPLACE(SUBSTR(ADDDATE(DATE_FORMAT(NOW(),'%Y-%m-%d'), INTERVAL -11 MONTH),1,7),'-','') AND 
			                        REPLACE(SUBSTR(ADDDATE(DATE_FORMAT(NOW(),'%Y-%m-%d'), INTERVAL  -1 MONTH),1,7),'-','') AND
			   	 ACC_YYMM NOT IN(CONCAT(REPLACE(SUBSTR(DATE_FORMAT(NOW(),'%Y-%m-%d'),1,4),'-',''),'00'))
			   AND ( ACCO_CODE BETWEEN '501' AND '504'
			      OR ACCO_CODE BETWEEN '601' AND '602'
			      OR ACCO_CODE BETWEEN '701' AND '748' )
			UNION ALL
			SELECT SUBSTR(SLIP_DATE,1,6) AS ACC_YYMM, 
					 CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN (CREDIT_AMT - DEBTOR_AMT) ELSE 0 END AS SALE_AMT,
                CASE WHEN ACCO_CODE BETWEEN '501' AND '504' THEN 0 ELSE (DEBTOR_AMT - CREDIT_AMT) END AS COST_AMT
			   FROM TRSLIP
			 WHERE SLIP_DATE LIKE CONCAT(SUBSTR(DATE_FORMAT(NOW(),'%Y%m%d'),1,6),'%')
			   AND ( ACCO_CODE BETWEEN '501' AND '504'
			      OR ACCO_CODE BETWEEN '601' AND '602'
			      OR ACCO_CODE BETWEEN '701' AND '748' )
			 ) A
		GROUP BY ACC_YYMM
    </select>
```
```
//대시보드 - 매출 로직
 /** 메인 화면 **/
@RequestMapping(value="/transcls/main/selectMainInfo.do")
public String selectBasicCodeMng(ModelMap model, HttpServletRequest request) throws Exception {
	
    LoginVO user = (LoginVO)EgovUserDetailsHelper.getAuthenticatedUser();
	Boolean isAuthenticated = EgovUserDetailsHelper.isAuthenticated();
	
	if(!isAuthenticated) {	//KISA 보안취약점 조치 (2018-12-10, 이정은)
        return "redirect:/uat/uia/egovLoginUsr.do";
    }
	
	try {
		
		String dashboardYn = mainService.selectDashboardYn(user);
		
		
		//매출액현황(테이블)
		//ACC_YYMM, CREDIT_SUM, DEBTOR_SUM, SUIK_SUM을 받아온다.
		//년도나 월에 데이터가 없으면 아무것도 안찍힌다.
		//그러면 어떻게 데이터를 채우냐?? 아래에 날짜는 직접넣는다. simpleDateFormat으로
		List<TRMainMaechulTableVO> yearMaechulList = mainService.selectYearMaechulList();
		List<TRMainMaechulTableVO> monthMaechulList = mainService.selectMonthMaechulList();
		List<String> chartYear = new ArrayList<String>();
		List<String> chartMonth = new ArrayList<String>();
		//그래프에는 오늘이 20240131이라고하면
		//202302 202303 .. 202401 까지 11개월전과 당월까지 그래프에 나타내야한다.
		SimpleDateFormat sdfYear = new SimpleDateFormat("yyyy년");
		SimpleDateFormat sdfMonth = new SimpleDateFormat("yyyy년MM월");
		Calendar cYear = Calendar.getInstance();
		Calendar cMonth = Calendar.getInstance();
		
		String increaseYearMaePercent = null;
		String increaseYearCostPercent = null;
		String increaseYearSuikPercent = null;
		String increaseMonthMaePercent = null;
		String increaseMonthCostPercent = null;
		String increaseMonthSuikPercent = null;
		String strToday = null;
		//아래와 같이 오늘기준으로 전월, 전년을 구하는 이유는 쿼리에서 전월,전년에 대한 값이 없으면 0원으로 넣어줘야하기때문에
		//[2024년01월]
		chartMonth.add(sdfMonth.format(cMonth.getTime()));
		cMonth.add(Calendar.MONTH, -1);
		strToday = sdfMonth.format(cMonth.getTime());
		chartMonth.add(0, strToday); //[2023년12월,2024년01월]
		
		//[2024년]
		chartYear.add(sdfYear.format(cYear.getTime())); //올해먼저넣고 [2024년]
		cYear.add(Calendar.YEAR, -1);
		strToday = sdfYear.format(cYear.getTime());
		chartYear.add(0, strToday); //[2023년,2024년]


		for(int j=0; j<2; j++) { //전년
				//j는 무조건 있는 요소까지만 진행(빈년도는 0으로채움) 
				if(j>=yearMaechulList.size()) {
					TRMainMaechulTableVO tempVO = new TRMainMaechulTableVO();
					tempVO.setCreditSum(0);
					tempVO.setDebtorSum(0);
					tempVO.setSuikSum(0);
					tempVO.setAccYymm(chartYear.get(j));
					yearMaechulList.add(j, tempVO);
				} //무조건 chartYear기준으로 넣는다.
				if(!chartYear.get(j).equals(yearMaechulList.get(j).getAccYymm())) {
					TRMainMaechulTableVO tempVO = new TRMainMaechulTableVO();
					tempVO.setCreditSum(0);
					tempVO.setDebtorSum(0);
					tempVO.setSuikSum(0);
					tempVO.setAccYymm(chartYear.get(j));
					yearMaechulList.add(j, tempVO);
				}
			}	

	//증감율계산
	for(int k=0; k<1; k++) {
		//전년,올해 0원일때는 증감율 : 0
		//k가 0일때는 2023년 CREDIT_SUM,DEBTOR_SUM,SUIK_SUM이 VO에 들어가있다.
		//k가 1일때는 2024년 ~
		if(yearMaechulList.get(k).getCreditSum()==0 || yearMaechulList.get(k).getDebtorSum() == 0 || yearMaechulList.get(k).getSuikSum()==0) {
			//매출기준금액이 0원일때는 증감율이 계산안된다.	
			//매출전년이 0원이면서 당년이 0원이면
			if(yearMaechulList.get(k).getCreditSum()==0 && yearMaechulList.get(k).getDebtorSum() != 0 && yearMaechulList.get(k).getDebtorSum() != 0) {
				if(yearMaechulList.get(k+1).getCreditSum()==0) {
					yearMaechulList.get(k).setIncreaseMaePercent("0");
					yearMaechulList.get(k+1).setIncreaseMaePercent("0");
				}else {
					increaseYearMaePercent = String.valueOf(Math.floor((double)(yearMaechulList.get(k+1).getCreditSum()-yearMaechulList.get(k).getCreditSum())/yearMaechulList.get(k).getCreditSum()*100*100)/100.0);
					yearMaechulList.get(k).setIncreaseMaePercent(increaseYearMaePercent);
					yearMaechulList.get(k+1).setIncreaseMaePercent(increaseYearMaePercent);
				}
			}
			//전월 비용(debtorSum)이 0원  
			if(yearMaechulList.get(k).getDebtorSum() == 0 && yearMaechulList.get(k).getCreditSum()!=0 && yearMaechulList.get(k).getSuikSum()!=0) {
				if(yearMaechulList.get(k+1).getDebtorSum()==0) {
					yearMaechulList.get(k).setIncreaseCostPercent("0");
					yearMaechulList.get(k+1).setIncreaseCostPercent("0");
				}else {
					increaseYearCostPercent = String.valueOf(Math.floor((double)(yearMaechulList.get(k+1).getDebtorSum()-yearMaechulList.get(k).getDebtorSum())/yearMaechulList.get(k).getDebtorSum()*100*100)/100.0);
					yearMaechulList.get(k).setIncreaseCostPercent(increaseYearCostPercent);
					yearMaechulList.get(k+1).setIncreaseCostPercent(increaseYearCostPercent);
				}
			}//수익기준금액이 0원일때는 증감율이 계산안된다.
			if(yearMaechulList.get(k).getSuikSum()==0 && yearMaechulList.get(k).getCreditSum()!=0 && yearMaechulList.get(k).getDebtorSum() != 0) {
				if(yearMaechulList.get(k+1).getSuikSum()==0) {
					yearMaechulList.get(k).setIncreaseSuikPercent("0");
					yearMaechulList.get(k+1).setIncreaseSuikPercent("0");
				}
				else {
					increaseYearSuikPercent = String.valueOf(Math.floor((double)(yearMaechulList.get(k+1).getSuikSum()-yearMaechulList.get(k).getSuikSum())/yearMaechulList.get(k).getSuikSum()*100*100)/100.0);
					yearMaechulList.get(k).setIncreaseSuikPercent(increaseYearSuikPercent);
					yearMaechulList.get(k+1).setIncreaseSuikPercent(increaseYearSuikPercent);
				}
			}
		//분모가 0이되는 케이스는 위에서 막았으니 여기서 나머지 계산
		}else {
			//증감율계산
			increaseYearMaePercent = String.valueOf(Math.floor((double)(yearMaechulList.get(k+1).getCreditSum()-yearMaechulList.get(k).getCreditSum())/yearMaechulList.get(k).getCreditSum()*100*100)/100.0);
			increaseYearCostPercent = String.valueOf(Math.floor((double)(yearMaechulList.get(k+1).getDebtorSum()-yearMaechulList.get(k).getDebtorSum())/yearMaechulList.get(k).getDebtorSum()*100*100)/100.0);
			increaseYearSuikPercent = String.valueOf(Math.floor((double)(yearMaechulList.get(k+1).getSuikSum()-yearMaechulList.get(k).getSuikSum())/yearMaechulList.get(k).getSuikSum()*100*100)/100.0);
			yearMaechulList.get(k).setIncreaseMaePercent(increaseYearMaePercent);
			yearMaechulList.get(k).setIncreaseCostPercent(increaseYearCostPercent);	
			yearMaechulList.get(k).setIncreaseSuikPercent(increaseYearSuikPercent);	
			yearMaechulList.get(k+1).setIncreaseMaePercent(increaseYearMaePercent);	
			yearMaechulList.get(k+1).setIncreaseCostPercent(increaseYearCostPercent);	
			yearMaechulList.get(k+1).setIncreaseSuikPercent(increaseYearSuikPercent);	
		}
	  }


	  for(int j=0; j<2; j++) { //전월,당월
				//j는 무조건 있는 요소까지만 진행(빈년도는 0으로채움)
				if(j>=monthMaechulList.size()) {
					TRMainMaechulTableVO tempVO = new TRMainMaechulTableVO();
					tempVO.setCreditSum(0);
					tempVO.setDebtorSum(0);
					tempVO.setSuikSum(0);
					tempVO.setAccYymm(chartMonth.get(j));
					monthMaechulList.add(j, tempVO);
				}
				if(!chartMonth.get(j).equals(monthMaechulList.get(j).getAccYymm())) {
					TRMainMaechulTableVO tempVO = new TRMainMaechulTableVO();
					tempVO.setCreditSum(0);
					tempVO.setDebtorSum(0);
					tempVO.setSuikSum(0);
					tempVO.setAccYymm(chartMonth.get(j));
					monthMaechulList.add(j, tempVO);
				}
			}
			//증감율계산
			for(int k=0; k<1; k++) {
				//전월(k=0),당월(k=1) 0원일때는 증감율 : 0
				//전월합계(매출,비용,수익)금액이 0원이 하나라도 있으면(분모가 0이되서 나눌수가없다)
				if(monthMaechulList.get(k).getCreditSum()==0 || monthMaechulList.get(k).getDebtorSum() == 0 || monthMaechulList.get(k).getSuikSum()==0) {
					
					//그냥 %라고 적히는게 안좋아서 일단 다 0으로 세팅 후에 아래로직대로 넣으면된다.
			
					monthMaechulList.get(k).setIncreaseMaePercent("0");
					monthMaechulList.get(k+1).setIncreaseMaePercent("0");
					monthMaechulList.get(k).setIncreaseCostPercent("0");
					monthMaechulList.get(k+1).setIncreaseCostPercent("0");
					monthMaechulList.get(k).setIncreaseSuikPercent("0");
					monthMaechulList.get(k+1).setIncreaseSuikPercent("0");
					//매출기준금액이 0원일때는 증감율이 계산안된다.	
					//매출전월이 0원이면서 당월이 0원이면
					if(monthMaechulList.get(k).getCreditSum()==0 && monthMaechulList.get(k).getDebtorSum() != 0 && monthMaechulList.get(k).getDebtorSum() != 0) {
						if(monthMaechulList.get(k+1).getCreditSum()==0) {
							monthMaechulList.get(k).setIncreaseMaePercent("0");
							monthMaechulList.get(k+1).setIncreaseMaePercent("0");
						}else {
							increaseMonthMaePercent = String.valueOf(Math.floor((double)(monthMaechulList.get(k+1).getCreditSum()-monthMaechulList.get(k).getCreditSum())/monthMaechulList.get(k).getCreditSum()*100*100)/100.0);
							monthMaechulList.get(k).setIncreaseMaePercent(increaseMonthMaePercent);
							monthMaechulList.get(k+1).setIncreaseMaePercent(increaseMonthMaePercent);
						}
					}
					//전월 비용(debtorSum)이 0원  
					if(monthMaechulList.get(k).getDebtorSum() == 0 && monthMaechulList.get(k).getCreditSum()!=0 && monthMaechulList.get(k).getSuikSum()!=0) {
						if(monthMaechulList.get(k+1).getDebtorSum()==0) {
							monthMaechulList.get(k).setIncreaseCostPercent("0");
							monthMaechulList.get(k+1).setIncreaseCostPercent("0");
						}else {
							increaseMonthCostPercent = String.valueOf(Math.floor((double)(monthMaechulList.get(k+1).getDebtorSum()-monthMaechulList.get(k).getDebtorSum())/monthMaechulList.get(k).getDebtorSum()*100*100)/100.0);
							monthMaechulList.get(k).setIncreaseCostPercent(increaseMonthCostPercent);
							monthMaechulList.get(k+1).setIncreaseCostPercent(increaseMonthCostPercent);
						}
					}//수익기준금액이 0원일때는 증감율이 계산안된다.
					if(monthMaechulList.get(k).getSuikSum()==0 && monthMaechulList.get(k).getCreditSum()!=0 && monthMaechulList.get(k).getDebtorSum() != 0) {
						if(monthMaechulList.get(k+1).getSuikSum()==0) {
							monthMaechulList.get(k).setIncreaseSuikPercent("0");
							monthMaechulList.get(k+1).setIncreaseSuikPercent("0");
						}
						else {
							increaseMonthSuikPercent = String.valueOf(Math.floor((double)(monthMaechulList.get(k+1).getSuikSum()-monthMaechulList.get(k).getSuikSum())/monthMaechulList.get(k).getSuikSum()*100*100)/100.0);
							monthMaechulList.get(k).setIncreaseSuikPercent(increaseMonthSuikPercent);
							monthMaechulList.get(k+1).setIncreaseSuikPercent(increaseMonthSuikPercent);
						}
					}
				//분모가 0이되는 케이스는 위에서 막았으니 여기서 나머지 계산
				}else {
					//증감율계산
					increaseMonthMaePercent = String.valueOf(Math.floor((double)(monthMaechulList.get(k+1).getCreditSum()-monthMaechulList.get(k).getCreditSum())/monthMaechulList.get(k).getCreditSum()*100*100)/100.0);
					increaseMonthCostPercent = String.valueOf(Math.floor((double)(monthMaechulList.get(k+1).getDebtorSum()-monthMaechulList.get(k).getDebtorSum())/monthMaechulList.get(k).getDebtorSum()*100*100)/100.0);
					increaseMonthSuikPercent = String.valueOf(Math.floor((double)(monthMaechulList.get(k+1).getSuikSum()-monthMaechulList.get(k).getSuikSum())/monthMaechulList.get(k).getSuikSum()*100*100)/100.0);
					monthMaechulList.get(k).setIncreaseMaePercent(increaseMonthMaePercent);
					monthMaechulList.get(k).setIncreaseCostPercent(increaseMonthCostPercent);	
					monthMaechulList.get(k).setIncreaseSuikPercent(increaseMonthSuikPercent);	
					monthMaechulList.get(k+1).setIncreaseMaePercent(increaseMonthMaePercent);	
					monthMaechulList.get(k+1).setIncreaseCostPercent(increaseMonthCostPercent);	
					monthMaechulList.get(k+1).setIncreaseSuikPercent(increaseMonthSuikPercent);	
				}
			  }
			//복화/상하차 현황(테이블)
			TRMainInOutVO mainInOutVO = mainService.selectMainInOutList();
			
			//DEPOT현황(테이블)
			TRMainDepotInOutVO mainDepotInOutVO = mainService.selectMainDepotInOutList();
			TRMainDepotInOutVO mainDepotStockVO = mainService.selectMainDepotStockList();
			mainDepotInOutVO.setYesterdayStock(mainDepotStockVO.getYesterdayStock());
			mainDepotInOutVO.setTodayStock(mainDepotStockVO.getTodayStock());
			
			model.addAttribute("dashboardYn", dashboardYn);
			model.addAttribute("mainDepotInOutVO", mainDepotInOutVO);
			model.addAttribute("yearMaechulList", yearMaechulList);
			//model.addAttribute("thisYearMaechulList", yearMaechulList.get(1));
			model.addAttribute("monthMaechulList", monthMaechulList);
			//model.addAttribute("thisMonthMaechulList", monthMaechulList.get(1));
			model.addAttribute("chartYear", chartYear);
			model.addAttribute("chartMonth", chartMonth);
			model.addAttribute("mainInOutVO", mainInOutVO);
			
		}catch(Exception e) {
			e.printStackTrace();
		}
		
    	return "egovframework/transcls/main/selectMainInfo";
    }		
```
---
```
//왜 두개의 식이 차이가 날까
//첫번째꺼는 long(정수)으로 빼고 나누기 까지하면 0이 나오고 그후에 double을 씌우니까 0.0으로나온다. 
System.out.println((double)((64621900L-21989243616L)/21989243616L));//0.0
//두번째꺼는 빼고 double로 형변환후에 나눈다.
System.out.println((double)(64621900L-21989243616L)/21989243616L);//-0.9970..

#)참고
// 64621900L-21989243616L = -21924621716
// (64621900L-21989243616L)/21989243616L = 0
// (double)(64621900L-21989243616L) = -2.1924621E~ //E가 되면 -2. 으로 찍히고 범위를 안넘어가면 -2192462.0 이렇게 찍힌다.
```
```
#)참고
SELECT DATE_FORMAT(NOW(), '%Y%m%d') FROM DUAL //20240213

//ADDDATE하는 순간에는 (-)하이픈이 붙여서 나온다.
SELECT ADDDATE(DATE_FORMAT(NOW(), '%Y%m%d'),INTERVAL -11 MONTH) FROM DUAL //2023-03-13(11개월전)

```
#)전표등록 로직
```
//전표등록관리 첫페이지 그리드조회(쓰이지는 않음, 검색해서 조회하기때문에)
//전표데이터 형식은 아래와같다.
SLIP_NO가 20230607003 이라면 이안에 소분류로 SLIP_SEQ가 여러개다.
SLIP_SEQ(전표순번) 001,002,003..

<!-- 첫 페이지 그리드 조회 -->
<select id="selectSlipMng" parameterType="TRSlipMngVO" resultType="egovMap">
	SELECT
	   //현재 createQcell에는 없지만 행추가시 
	   //qcell.setCellDataEx(qcell.getRows('data'),'connTime',getyyyymmddhhmmss())하기 위해서는 이렇게 쿼리에서 가져와야한다.
	  '00000000000000' AS CONN_TIME <!-- 행추가시 시간을 담기위한 -->
	  ,'N' AS CONN_YN //미처리 전표처리 팝업을 띄워서 연계했는지 안했는지 구분하기위해(행추가시에만 미처리전표처리가능하기때문에)
					  //전표등록처리되있으면 연계처리못한다.그래서 조회할때 다 N으로 박아도된다. 행추가시에는 짜피 N이 들어가니까
					  //연계처리다하면 Y로 바뀐다.
	  ,A.SLIP_NO
	  ,A.SLIP_SEQ
	  ,A.SLIP_DATE
	  ,A.SLIP_DIV
	  ,A.CHADAE_DIV
	  ,A.ACCO_CODE 
	  ,A.CUST_CODE as custCode1 //전표에서의 거래처코드팝업이라서 뒤에 1을 붙였다.
	  ,A.DEBTOR_AMT
	  ,A.CREDIT_AMT
	  ,A.REMARK
	  ,A.SLIP_FINISH_YN
	  ,A.SLIP_PRINT_YN
	  ,B.ACCO_NAME //Left outer할때 출력
	  ,B.ACCO_ATTRIBUTE //Left outer할때 출력
	  ,C.CUST_NAME as custName1 //Left outer할때 출력
	  ,'R' AS DATA_DIV
	FROM
	  TRSLIP A
	  LEFT OUTER JOIN TRACCO B ON (A.ACCO_CODE = B.ACCO_CODE)
	  LEFT OUTER JOIN TRCUTA C ON (A.CUST_CODE = C.CUST_CODE)
	WHERE
	  SLIP_DATE = (SELECT DATE_FORMAT(NOW(),'%Y%m%d'))
	ORDER BY A.SLIP_NO, A.SLIP_SEQ
</select>
```
```
//전표검색조회
<select id="searchSlipMng" parameterType="TRSlipMngVO" resultType="egovMap">
	SELECT
	  '' AS CONN_TIME <!-- 행추가시 시간을 담기위한 -->	
	  ,'N' AS CONN_YN <!-- 연계처리컬럼은 N으로 다 표시(어차피 등록된 전표는 연계처리 수정못함)-->
	  ,A.SLIP_NO
	  ,A.SLIP_SEQ
	  ,A.SLIP_DATE
	  ,A.SLIP_DIV
	  ,A.CHADAE_DIV
	  ,A.ACCO_CODE 
	  ,A.CUST_CODE as custCode1
	  ,A.DEBTOR_AMT
	  ,A.CREDIT_AMT
	  ,A.REMARK
	  ,A.SLIP_FINISH_YN
	  ,A.SLIP_PRINT_YN
	  ,B.ACCO_NAME 
	  ,B.ACCO_ATTRIBUTE
	  ,C.CUST_NAME as custName1
	  ,'R' AS DATA_DIV
	FROM
	  TRSLIP A
	  LEFT OUTER JOIN TRACCO B ON (A.ACCO_CODE = B.ACCO_CODE)
	  LEFT OUTER JOIN TRCUTA C ON (A.CUST_CODE = C.CUST_CODE)
	WHERE
	  SLIP_DATE BETWEEN REPLACE(#{schSlipDateFr},'-','') AND REPLACE(#{schSlipDateTo},'-','')
	ORDER BY A.SLIP_NO, A.SLIP_SEQ
</select>
```
```
//1. 전표등록시에는 체크한것끼리 전표일자가 같아야한다.
//2. 전표등록 시 입력한 전표일에 대한 일전표마감 check를 해야한다.(하나라도있으면 마감처리알림)
<select id="countRegisteredSlipMng" parameterType="String" resultType="String">
	//여기서 param은 전표등록하려는 전표일자이다.
	select count(*) as cnt from trddba where acc_ymd = #{param}
</select>

일전표마감은 별도 메뉴가 있다. 전표마감{일/월} 에서 일전표마감 처리를 한다.
즉, 전표등록관리에서 전표등록을 하면 마감은 일전표마감에서 전표마감처리를 하면 아래처럼된다.

UPDATE TRSLIP SET SLIP_FINISH_YN = 'Y'
WHERE SLIP_DATE BETWEEN REPLACE('2024-04-16','-','') AND REPLACE('2024-04-17','-','')


//3. 전표구분(SLIP_DIV)이 'T'(대체) 일때는 차변금액합계와 대변금액합계가 다르면 alert띄워준다.
//나머지 입금,출금은 하나만 등록해도 되야한다.

//4. 전표등록 전 전표번호추출
<select id="selectNewSlipNo" parameterType="String" resultType="String">
						//+1을 하고 3자리 0채우기  //max가 null이면 0 //최대	   //001
		SELECT CONCAT(#{slipDate},LPAD(IFNULL(MAX(SUBSTRING(SLIP_NO,9,3)),0)+1,3,'0')) FROM TRSLIP WHERE SUBSTRING(SLIP_NO,1,8) = #{slipDate}
</select>

//5. 전표등록 전 connYn이  Y,N인지 따라서 달라진다(즉, 연계처리를 했냐)
//연계처리에 대한 부분 먼저 일단 보자
```
```
//전표등록 - 연계처리로직
//미처리전표조회 버튼 클릭 시
function notRegistjunpyoPopup(obj,row,col) {
	var qcell = QCELL.getInstance('qcell');
	if(qcell.getRowData(row).accoCode == null || qcell.getRowData(row).accoCode == '') {
		alert('계정과목은 빈 값이 될 수 없습니다.')
		return false;
	}//전표등록이 안되있는 경우만 미처리전표팝업 open
	if(qcell.getRowData(row).slipNo == null || qcell.getRowData(row).slipNo == ''){
		//팝업호출 시 차대구분,계정과목,거래처코드 파라미터로 전달
		qcell.showProgress(); // progress 화면 출력
		//아래를 보면 미처리전표팝업 조회시 아래와 같이 차대구분,계정과목,거래처코드를 던진다.

		junpyoPopup(qcell.getRowData(row).chadaeDiv,qcell.getRowData(row).accoCode,qcell.getRowData(row).custCode1)
	}

//전표팝업호출
function junpyoPopup(chadae,acco,cust) {
	var date = new Date();
	var today = getToday2();
	var junSlipDateFr = date.getFullYear()-2+"-01-01"; //2년전날짜(검색항목에 세팅) 
	var junSlipDateTo = getToday2(); //오늘날짜(검색항목에 세팅)
	document.getElementById('disposeMoney').value = '' //입력항목에 처리금액
	document.getElementById('chadaeDiv').value = chadae //히든컬럼에
	document.getElementById('accoCode').value = acco //히든컬럼에
	document.getElementById('custCode').value = cust //히든컬럼에
	document.getElementById('junSlipDateFr').value = junSlipDateFr //검색항목
	document.getElementById('junSlipDateTo').value = junSlipDateTo //검색항목
	var formData = decodeURIComponent($('#junpyoSearchForm').serialize());
	let junpyoQcell;
	 $.ajax({  //이 쿼리는 밑에 적어놨으니 참조 
		url: "/transcls/cost/slipMng/selectJunpyoPopupMng.do",
		type: "POST",
		//dataType : "json",
		data: formData,
		success: function(data){
			qcell.hideProgress(300); // progress 화면 숨기기
			$(".junpyoModal").dialog({ //모달을 띄우겠다
                modal: true,
                height: 609,
                width: "50%",
                buttons: {
                    "닫기": function(){
                        $(this).dialog("close");
                    }
                }
	 		});
			if(data.status == "fail") {
				alert('에러가 발생하였습니다.')
				return false;
			}
   		if(typeof junpyoQcell === "undefined" || typeof junpyoQcell !== "object"){
            QCELL.create({
                id          : "junpyoQcell",
                parentid    : "junpyoSheetarea",
                rowheaders : ["checkbox","sequence"], // state : 행추가, 데이터변경, 행삭제 시 해당 rowheader 영역에 신호등 표현
    			rowheaderstitle : ['','순번'],
    			emptymessage: "조회된 데이터가 없습니다.",
    			selectmode: 'row',
                columns     : [
                    {width:"13%",   key:"slipNo",     title:["전표번호"],   styleclassname: {data: "align-center"}},
                    {width:"11%",   key:"slipDate",     title:["전표일자"],     styleclassname: {data: "align-center"}},
                    {width:"12%",   key:"accoName",     title:["계정과목"],     styleclassname: {data: "align-center"}},
                    {width:"20%",   key:"custName",     title:["거래처"],     styleclassname: {data: "align-center"}},
                    {width:"12%",   key:"slipAmt",     title:["전표금액"],     resize: true, styleclassname: {data: "align-right"}, options: {format: {type: "number", rule:"#,###"}}},
                    {width:"12%",   key:"balanceAmt",     title:["잔액"],     resize: true, styleclassname: {data: "align-right"}, options: {format: {type: "number", rule:"#,###"}}},
                    {width:"20%",   key:"remark",     title:["적요"],     styleclassname: {data: "align-center"}},
                ],
                data        : {"input":data.gridList},
            });
            junpyoQcell = QCELL.getInstance("junpyoQcell");
   		}
	},
		error: function(){
			alert("오류가 발생하였습니다.");
		}
	})
}
```
```
#)컨트롤러 미처리전표팝업조회
/transcls/cost/slipMng/selectJunpyoPopupMng.do

//검색 시에도 동일한 쿼리로 동작한다.
//팝업조회할때 그리드에 숨긴항목으로 SLIP_AMT, BALANCE_AMT, CONN_SLIP_DIV가 있다.(CASE WHEN쪽)
//Select 하는 순간에 그리드에 column을 지정안해도 넣기때문에(SLIP_AMT, BALANCE_AMT, CONN_SLIP_DIV)


<select id="selectJunpyoPopupMng" parameterType="TRSlipMngVO" resultType="egovMap">
		SELECT 
		 A.SLIP_NO
 		,A.SLIP_SEQ
 		,A.SLIP_DATE
 		,A.REMARK
 		,A.CONN_SLIP_AMT
 		,A.CONN_SLIP_AMT1
 		,A.CONN_SLIP_AMT2
 		,A.CONN_SLIP_NO
 		,A.CONN_SLIP_NO1
 		,A.CONN_SLIP_NO2
 		,A.ACCO_CODE
 		,A.CUST_CODE
 		,B.ACCO_NAME
 		,C.CUST_NAME		//차변(1)일 경우 차변금액, 대변(2)일때 대변금액을 SLIP_AMT로 지정한다. 이걸 나중에 TRSLTP에 넣을것이다(미처리전표팝업 시 그리드에 숨겨놓음)
		,CASE WHEN #{chadaeDiv} = '1' THEN A.DEBTOR_AMT ELSE A.CREDIT_AMT END AS SLIP_AMT
							//차변(1)일 경우 차변금액, 대변(2)일때 대변금액 빼기 각연계금액합 = 잔액 (미처리전표팝업 시 그리드에 숨겨놓음)
		,CASE WHEN #{chadaeDiv} = '1' THEN A.DEBTOR_AMT ELSE A.CREDIT_AMT END - (A.CONN_SLIP_AMT + A.CONN_SLIP_AMT1 + A.CONN_SLIP_AMT2) AS BALANCE_AMT	
							//(미처리전표팝업 시 그리드에 숨겨놓음)
		//이게 나중에 미처리전표 확인클릭 시 trsltp테이블의 slipConnSeq에(ex: 1,2,3) 들어간다.
		,CASE WHEN A.CONN_SLIP_NO = '' THEN '1' ELSE (CASE WHEN A.CONN_SLIP_NO1 = '' THEN '2' ELSE '3' END) END AS CONN_SLIP_DIV
	FROM TRSLIP A
		LEFT OUTER JOIN TRACCO B ON (A.ACCO_CODE = B.ACCO_CODE)
		LEFT OUTER JOIN TRCUTA C ON (A.CUST_CODE = C.CUST_CODE)
	WHERE A.SLIP_DATE BETWEEN REPLACE(#{junSlipDateFr},'-','') AND REPLACE(#{junSlipDateTo},'-','')
		AND A.CHADAE_DIV = #{chadaeDiv}
		AND A.ACCO_CODE = #{accoCode}
		//거래처코드는 그리드에서 가져오는것이고
		<if test='custCode != null and custCode != "" and custCode != "undefined"'>AND A.CUST_CODE = #{custCode}</if>
		//거래처구분은 미처리전표팝업에 검색항목으로 있다.
		<if test='custGubun != null and custGubun != ""'>AND A.CUST_CODE LIKE CONCAT('%',#{custGubun},'%')</if>
		AND A.SLIP_YN = 'N' //연계되지않은
		AND (A.CONN_SLIP_NO = '' OR A.CONN_SLIP_NO1='' OR A.CONN_SLIP_NO2 = '')
	ORDER BY A.SLIP_NO DESC, A.SLIP_SEQ ASC
</select>
```
```
//미처리전표팝업 화면을 보면
//입력항목에 라디오버튼으로 전체,분할 이렇게 나오는데
전체선택 시: 
- 팝업에서 연계하려는 전표들을 체크박스로 선택하고(여러개 선택가능) 확인버튼 누르면 
  차변,대변에 따라서(전표등록관리에서 차대구분) 금액이 알아서 그리드에 들어간다. 
  단, 입력했던 차변,대변금액은 덮어써진다(차대구분에 따라서).

분할선택 시: 
- 한건만 선택가능하며, 얼만큼 분할할지 처리금액을 입려항목에 적는데
  분할하려는 금액보다 같거나 크면 안된다. 확인 버튼 누르면
  차변,대변에 따라서(전표등록관리에서 차대구분) 금액이 알아서 그리드에 들어간다. 
  단, 입력했던 차변,대변금액은 덮어써진다(차대구분에 따라서).

//확인버튼을 누르면 TRSLTP라는 임시테이블에 들어가는데 임시테이블에 같은유저에 같은 acco_time이
있다면 지우고 체크한 전표데이터가 들어간다.
또, 아래 SLIP_CONN_SEQ를 보면 1이 들어가있는데 이거는 내가 미처리전표팝업에서 연계하고싶은
전표 한줄(처리구분이분할일때만가능) 또는 여러줄(처리구분이 전체일때만)에 대해서 확인을 누르면
해당 한줄에 대한 전표에 CONN_SLIP_NO가 빈값이면 1
				      CONN_SLIP_NO가 값이있고 CONN_SLIP_NO1 가 빈값이면 2
					  CONN_SLIP_NO,CONN_SLIP_NO1이 값이있고 NO2가 빈값이면 3

예) 미처리전표팝업에서 분할로 처리금액을 999로 입력하였다.
SLIP_NO 	SLIP_SEQ ACCO_CODE CUST_CODE ACCO_TIME 		USER_ID SLIP_AMT SLIP_CONN_SEQ SLIP_YN
20231225001 001		 103        S0002     20240111151719    cls       999     1   N (분할일경우)

//근데 acco_time은 언제들어갈까? -> 확인버튼을 누르면 들어간다.
```
```
//미처리전표팝업에서 확인버튼을 눌렀을때
function junpyoCreate() {
	var junpyoQcell = QCELL.getInstance('junpyoQcell'),
	qcell = QCELL.getInstance('qcell'),
	nRow = junpyoQcell.getIdx('row'),
	nHeaderRow = junpyoQcell.attr('headerrows'),
	chks = junpyoQcell.getRowheaderChecked(0); // 첫번째 열이 checkBox
	disposeMoney = document.getElementById('disposeMoney').value
	totAmt = 0;
	if(chks.length < 1){
		return false;
	} 
	//분할을 선택했지만 건수가 2개이상 클릭 시
	if($('input[name=dispose]:checked').val() == 'D' && chks.length > 1) {
		alert('분할처리는 2건 이상 처리할 수 없습니다.')
		return false;
	}

	/*1. 체크한 그리드의 잔액 가져오기**/	
	for(var i=0; i<=chks.length-1; i++) { //체크한 잔액보다 입력한 처리금액(disposemoney)이 큰 경우
		if(junpyoQcell.getCellDataEx(chks[i],"balanceAmt") <= uncomma(disposeMoney)) {
			alert('분할처리금액은 미처리 잔액보다 크거나 같을 수 없습니다.')
			return false;
		}
	}

	/*1. 분할처리일때 input금액은 빈값이 될 수없다**/
	if($('input[name=dispose]:checked').val() == 'D' && document.getElementById('disposeMoney').value.replace(/\s| /gi,'') == '') {
			alert('분할 선택 시 처리금액은 빈값이 될 수 없습니다.')
			return false;
		}

	/*2. 임시테이블(TRSLTP) 데이터 삭제**/
	deleteTrsltp(qcell.getCellDataEx(qcell.getIdx('row'),'connTime'))

	//위에서 삭제 후 임시테이블에 넣기
	//임시테이블에 넣기 전에 임시테이블에 해당 데이터가 있는지 확인이 필요
	for(var i=0; i<=chks.length-1; i++) {//TRSLTP에서 키인 SLIP_NO, SLIP_SEQ가 충돌하는지 확인
		if(checkTrsltpSlipMng(junpyoQcell.getCellDataEx(chks[i],"slipNo"),junpyoQcell.getCellDataEx(chks[i],"slipSeq")) != '0') {
			alert('전표번호['+junpyoQcell.getCellDataEx(chks[i],"slipNo")+']는 이미연계처리 중입니다.')
			return false;
		}
	}
	for(var i=0; i<=chks.length-1; i++) {
		//임시테이블에 넣기위해 accoTime에 connTime값넣는다.
		junpyoQcell.setCellDataEx(chks[i],'accoTime',qcell.getCellDataEx(qcell.getIdx('row'),'connTime'))
		//임시테이블에 넣기위해 slipYn에 다가 전체,분할에따라 Y,N을 넣는다.
		junpyoQcell.setCellDataEx(chks[i],'slipYn',$('input[name=dispose]:checked').val() == 'A' ? 'Y' : 'N')
		if($('input[name=dispose]:checked').val() == 'A') { //전체일때
			insertTrsltp(junpyoQcell.getRowData(chks[i])); //전체니까 그냥 체크한것 다 임시테이블에 넣는다.
			totAmt += junpyoQcell.getCellDataEx(chks[i],'balanceAmt');//호출했던 그리드에 합계금액을 넘겨주기 위한 합계구하기
		}else { //분할일때는 input의 처리금액 - 여기는 어차피 한건만 되니까 닫아도됨
			//처리금액을 미처리그리드의 slipAmt에 넣음. 
			junpyoQcell.setCellDataEx(chks[i],'slipAmt',document.getElementById('disposeMoney').value)
			insertTrsltp(junpyoQcell.getRowData(chks[i])); //한건만
		}
	}

	//전표등록관리화면 그리드에서 전표연계여부 connYn에 대입
	var selectedRow = qcell.getIdx('row')
	//분할이면서 0원일때
	if($('input[name=dispose]:checked').val() == 'D' && document.getElementById('disposeMoney').value == '0') {
		//확인 누를 때 넘어오는 금액이 0원이면 N처리
		qcell.setCellDataEx(qcell.getIdx('row'),'connYn','N')
		//아래세줄은 포커스를 주기위한 임시로직
		goToCell(qcell.getIdx('row')+1,3)
		qcell.deleteRow(qcell.getIdx('row')+1)
		qcell.focusCell(selectedRow, 3);
	//전체이면서 합이 0원일때
	}else if($('input[name=dispose]:checked').val() == 'A' && totAmt == 0) {
		//확인 누를 떄 넘어오는 금액이 0원이면 N처리
		qcell.setCellDataEx(qcell.getIdx('row'),'connYn','N')
		goToCell(qcell.getIdx('row')+1,3)
		qcell.deleteRow(qcell.getIdx('row')+1)
		qcell.focusCell(selectedRow, 3);
	//그외는 Y로 넣기(팝업이 닫힐 때 넘어오는 금액이 0보다 크다면)
	//0보다 크다라는 의미는 연계하겠다라는 의미니까
	}else {
		qcell.setCellDataEx(qcell.getIdx('row'),'connYn','Y') 
		goToCell(qcell.getIdx('row')+1,3)
		qcell.deleteRow(qcell.getIdx('row')+1)
		qcell.focusCell(selectedRow, 3);
	}

	//전표등록관리화면 그리드에서 위에서 계산한 합계금액을 표출
	//차변일때
	if(document.getElementById('chadaeDiv').value == '1') {
		if($('input[name=dispose]:checked').val() == 'A') { //전체
			qcell.setCellDataEx(selectedRow,'debtorAmt',totAmt)
		}
		else { //분할
			qcell.setCellDataEx(selectedRow,'debtorAmt',document.getElementById('disposeMoney').value)
		}
	//대변일때
	}else {
		if($('input[name=dispose]:checked').val() == 'A') { //전체
			qcell.setCellDataEx(selectedRow,'creditAmt',totAmt)
		}
		else {//분할
			qcell.setCellDataEx(selectedRow,'creditAmt',document.getElementById('disposeMoney').value)
		}
	}
	qcell.setCellDisable(selectedRow,15,true) //차변 비활성화
	qcell.setCellDisable(selectedRow,16,true) //대변 비활성화
	$(".junpyoModal").dialog("close");
}
```
```
//checkTrsltpSlipMng 함수
function checkTrsltpSlipMng(slipNo,slipSeq) {
	var count;
	$.ajax({
			url: "/transcls/cost/slipMng/checkTrsltpSlipMng.do", //통신하실 URL 주소
			//data: { param: JSON.stringify(states) }, //서버에 param이라는 parameter명으로 JSON String형태로 수정 정보 전달
			data: {"slipNo":slipNo,"slipSeq":slipSeq},
			async: false,
			method: "POST" //post형식으로 전달
		}).success(function (data) {
			count = data
		}).error(function (xhr, status, error) {
			alert("오류가 발생하였습니다.");
			//실패시 처리
		});
		return count;
}
<!-- 임시테이블 건수 조회 -->
<select id="checkTrsltpSlipMng" parameterType="TRSlipMngVO" resultType="String">
	SELECT COUNT(*) AS CNT FROM TRSLTP WHERE SLIP_NO=#{slipNo} AND SLIP_SEQ=#{slipSeq}
</select>


<insert id="insertTrsltp" parameterType="TRSltpMngVO">			
		  INSERT INTO TRSLTP
				( 
				   SLIP_NO <!--전표번호 -->
				  ,SLIP_SEQ <!--전표순번-->
				  ,ACCO_CODE
				  ,CUST_CODE
				  ,ACCO_TIME
				  ,USER_ID
				  ,SLIP_AMT
				  ,SLIP_CONN_SEQ
				  ,SLIP_YN
				)
			VALUES (
			 	  #{slipNo}
			 	  ,#{slipSeq}
			 	  ,#{accoCode}
			 	  ,#{custCode}
			 	  ,#{accoTime}
			 	  ,#{loginId}
			 	  ,#{slipAmt}
			 	  ,#{connSlipDiv}
			 	  ,#{slipYn}
				  )
</insert>


<!-- 임시테이블 삭제(전표등록 시) -->
<delete id="deleteTrsltp"  parameterType="TRSltpMngVO">
		DELETE FROM TRSLTP
	    WHERE ACCO_TIME = #{accoTime} AND USER_ID = #{loginId}
</delete>
```
```
//전표등록
function registBtn() {
	var checkRowIndex = qcell.getRowheaderChecked(0);
	var temp;
	var slipDate;

	var sumDeb = 0 //대변합
	var sumCre = 0 //차변합
	//로직설명
	/* check: 0 1     체크한 길이가 2  i는 0까지
   		 1 2 i=0
	check: 0 1 2   길이가 3  i는 1까지
	    1 2  i=0
	    2 3  i=1
	check: 0 1 2 3  길이가 4  i는 2까지
	    1 2  i=0
	    2 3  i=1
	    3 4  i=2
	check: 0 1 2 3 4 길이가 5  i는 3까지
	    1 2  i=0
	    2 3  i=1
	    3 4  i=2	
	    4 5  i=3	 */
	//체크했는지 먼저체크(길이)   
	//체크한 것들 중에서 전표일자가 서로 다를경우
	if(checkRowIndex.length > 0) {
		for(var i=0; i<=checkRowIndex.length-2; i++) {
			temp = qcell.getCellDataEx(checkRowIndex[i],"slipDate");
			if(temp == qcell.getCellDataEx(checkRowIndex[i+1],"slipDate")) {
				
			}
			else {
				alert('전표일자가 다릅니다.\n전표등록 처리를 할 수 없습니다.')
				return false;
			}
		}
		
		//전표등록 체크
		for(var i=0; i<=checkRowIndex.length-1; i++) { //체크한 길이 만큼 반복
			//전표번호는 비어있지만 전표일자가 있는경우 - 행추가
			if(qcell.getCellDataEx(checkRowIndex[i],"slipNo") == null || qcell.getCellDataEx(checkRowIndex[i],"slipNo") == "") {
				if(qcell.getCellDataEx(checkRowIndex[i],"slipDate") != null || qcell.getCellDataEx(checkRowIndex[i],"slipDate") != "") {
					
				}
				else {
					alert('전표일자를 선택해주세요.');
					return false;
				}
				
			}
			else { //여기는 slipNo가 null이 아니니까 전표가 등록되었다는 뜻이다.
				alert('이미 전표등록 처리된 데이터가 있습니다.')
				return false;
			}
		}
		
		//전표등록 시에 계정과목 빈값확인
		for(var i=0; i<=checkRowIndex.length-1; i++) { //체크한 길이 만큼 반복
			//전표번호는 비어있지만 전표일자가 있는경우 - 행추가
			if(qcell.getCellDataEx(checkRowIndex[i],"accoCode") == null || qcell.getCellDataEx(checkRowIndex[i],"accoCode") == "") {
				alert('계정과목은 빈값이 될 수 없습니다.')
				return false;
			}
		}
		
		//일전표마감에대한 중복체크
		if(checkRegistered(qcell.getCellDataEx(checkRowIndex[0],"slipDate")) > 0) {
			alert('전표일자['+qcell.getCellDataEx(checkRowIndex[0],"slipDate")+']에 대한 마감처리가되었습니다. \n전표등록 처리를 할 수 없습니다.')
			return false;
		}
		
		
		
		//차변합계 <> 대변합계 체크
		for(var i = 0; i<=checkRowIndex.length-1; i++) {
			//대체일때 차변합계, 대변합계 비교
			if(qcell.getCellDataEx(checkRowIndex[i],"slipDiv") == "T") {//대체일때
				if(qcell.getCellDataEx(checkRowIndex[i],"chadaeDiv") == "1") {//차변일때
					sumDeb += parseInt(qcell.getCellDataEx(checkRowIndex[i],"debtorAmt"))
				}
				else if(qcell.getCellDataEx(checkRowIndex[i],"chadaeDiv") == "2"){ //대변일때
					sumCre += parseInt(qcell.getCellDataEx(checkRowIndex[i],"creditAmt"))
				}
			}
		}
		if(sumDeb != sumCre) {
			alert('대차차액이 발생 되었습니다.\n전표등록 처리를 할 수 없습니다.')
			return false;
		}
		
		//전표등록처리
		insertTrslip()
		
		//연계전표처리(connYn이 Y인것만)
		//updateTrslip()
		
	} //if(checkRowIndex.length > 0) 종료
}   

//미처리전표는 하고싶은 사람만 하면되고 그 후에 전표등록
function insertTrslip() {
	var formData = decodeURIComponent($('#frm0').serialize()); //input id="param" name="param"
	$.ajax({
		url: "/transcls/cost/slipMng/insertRegisteredSlipMng.do", //통신하실 URL 주소
		//data: { param: JSON.stringify(states) }, //서버에 param이라는 parameter명으로 JSON String형태로 수정 정보 전달
		data: formData,
		async: false,
		method: "POST" //post형식으로 전달
	}).success(function (data) {
		if(data.status == "fail") {
			alert('에러가 발생하였습니다.')
			return false;
		}
		var gridData = data.gridList;
		createQCELL(gridData);
		qcell.hideProgress(300);
	}).error(function (xhr, status, error) {
		alert("오류가 발생하였습니다.");
		qcell.hideProgress(300);
		//실패시 처리
	});
}

#)컨트롤러 (전표등록)
try {
			 Function fn = new Function(); 
			 //paramMap = fn.jsonToMap(param);
			 slipMngService.insertRegisteredSlipMng(vo);
			 slipMngService.deleteTrsltpAll(tRSltpMngVO);
			 List<?> gridList = slipMngService.searchSlipMng(tRSlipMngVO);
			 JSONArray jsonArr = fn.listToJson(gridList);
			 
			 resMap.put("gridList", jsonArr);
			 
			
		}catch(Exception e) {
			e.printStackTrace();
		}


#)impl
public void insertRegisteredSlipMng(Map<String, Object> vo) throws Exception {
		
		LoginVO user = (LoginVO)EgovUserDetailsHelper.getAuthenticatedUser(); // 현재 로그인한 계정정보 가져오기
		
		Map<String,Object> paramMap = new HashMap<String,Object>();
		List<Map<String,Object>> list = new ArrayList<Map<String,Object>>();
		ObjectMapper objectMapper2 = new ObjectMapper();
		
		Function fn = new Function();
		
		String strParam = (String) vo.get("param"); //화면상에 form -> name 값 사용
		paramMap = fn.jsonToMap(strParam);
		
		//입력 데이터
		list = (List<Map<String, Object>>) paramMap.get("i");
		String slipDate = (String) ((Map<String, Object>) list.get(0).get("data")).get("slipDate");
		String newSlipNo = slipMngDAO.selectNewSlipNo(slipDate); //한번만 검색하면됨
		Map<String, String> slipNoSeqMap = new HashMap<>(); 
		Map<String, String> gridListMap = new HashMap<>();
		String newSlipSeq;
		
		TRSlipMngVO gridI = new TRSlipMngVO();
		
		//체크한 값 하나하나 반복
		for(int i=0; i < list.size(); i++) {
			gridI = objectMapper2.convertValue(fn.mapToVo(list,i), TRSlipMngVO.class);
			gridI.setNewSlipNo(newSlipNo);
			newSlipSeq = slipMngDAO.selectNewSlipSeq(newSlipNo); //순번은 계속 증가, slip_no는 고정
			gridI.setLoginJijum(user.getJijum()); // VO에 로그인 지점 값 넣기
			gridI.setLoginId(user.getId()); // VO에 로그인 ID 값 넣기
			gridI.setLoginIp(user.getIp()); // VO에 로그인 IP 값 넣기
			slipMngDAO.insertRegisteredSlipMng(gridI);
			if("Y".equals(gridI.getConnYn())) { //연계전표를 전표등록할 경우
				//부여받았던 전표순번을 구해서
				//전표순번이랑, 전표번호랑(위에)
				//[{slipNo:~ ...},{slipNo:~...}, ...]
				//임시테이블에는 SLIP_YN이 있다.
				List<Map<String,String>> gridList = slipMngDAO.selectTrsltp(gridI);
				gridListMap.put("newSlipNo", newSlipNo);
				gridListMap.put("newSlipSeq", newSlipSeq);

				for(int j = 0; j<gridList.size(); j++) {
					gridList.get(j).put("newSlipNo", newSlipNo);
					gridList.get(j).put("newSlipSeq", newSlipSeq);
					slipMngDAO.updateLinkTrslip(gridList.get(j));
				}
			}
		}


//쿼리
<!--전표등록을 위한 전표번호추출-->
<select id="selectNewSlipNo" parameterType="String" resultType="String">
	SELECT CONCAT(#{slipDate},LPAD(IFNULL(MAX(SUBSTRING(SLIP_NO,9,3)),0)+1,3,'0'))FROM TRSLIP WHERE SUBSTRING(SLIP_NO,1,8) = #{slipDate}
</select>

<!--전표등록을 위한 전표번호추출-->
<select id="selectNewSlipSeq" parameterType="String" resultType="String">
	SELECT LPAD(IFNULL(MAX(SLIP_SEQ),0)+1,3,'0') FROM TRSLIP WHERE SLIP_NO = #{newSlipNo}
</select>

<insert id="insertRegisteredSlipMng" parameterType="TRSlipMngVO">			
		  INSERT INTO TRSLIP
				( 
				   SLIP_NO <!--전표번호 -->
				  ,SLIP_SEQ <!--전표순번-->
				  ,SLIP_DATE <!--전표일자-->
				  ,SLIP_DIV <!--전표구분(입금,출금,대체) -->
				  ,CHADAE_DIV <!--차대구분(차변,대변)-->
				  ,ACCO_CODE <!--계정과목코드-->
				  ,CUST_CODE <!--거래처코드-->
				  ,DEBTOR_AMT <!--차변금액-->
				  ,CREDIT_AMT <!--대변금액-->
				  ,REMARK <!--적요-->
				  ,SLIP_YN <!--전표처리구분-->
				  ,SLIP_FINISH_YN <!--전표마감구분-->
				  ,SLIP_PRINT_YN <!--전표출력여부-->
				  ,CONN_SLIP_NO<!--연계전표번호-->
				  ,CONN_SLIP_SEQ <!--연계순번-->
				  ,INSERT_DATE
				  ,INSERT_ID
				  ,INSERT_IP
				  ,UPDATE_DATE
				  ,UPDATE_ID
				  ,UPDATE_IP
				)
			VALUES (
			 	   #{newSlipNo} <!-- 20231128002 001 -->
			 	  ,(SELECT LPAD(IFNULL(MAX(A.SLIP_SEQ),0)+1,3,'0') FROM TRSLIP A WHERE A.SLIP_NO = #{newSlipNo})
			 	  ,#{slipDate}
			 	  ,#{slipDiv}
			 	  ,#{chadaeDiv}
			 	  ,#{accoCode}
			 	  ,<choose>
			 	  	<when test='custCode1 != null and custCode1 != "" and custCode1 == "undefined"'>
			 	  		''
			 	  	</when>
			 		<otherwise>
			 			#{custCode1}
			 		</otherwise>
			 	  </choose>
			 	  ,#{debtorAmt}
			 	  ,#{creditAmt}
			 	  ,#{remark}
			 	  ,'N'
			 	  ,'N'
			 	  ,'N'
			 	  ,''
			 	  ,''
			 	  ,SYSDATE()
			 	  ,#{loginId}
			 	  ,#{loginIp}
			 	  ,SYSDATE()
			 	  ,#{loginId}
			 	  ,#{loginIp}
				  )
	</insert>

<!-- 임시테이블조회 (팝업생성시간,로그인id) -->
<select id="selectTrsltp" parameterType="TRSlipMngVO" resultType="egovMap">
	SELECT *
	FROM
	  TRSLTP
	WHERE
	  ACCO_TIME = #{connTime} AND USER_ID = #{loginId}
</select>

<update id="updateLinkTrslip" parameterType="map">
UPDATE TRSLIP
	   SET
	   	   SLIP_YN = CASE WHEN #{slipYn} = 'Y' THEN 'Y' ELSE 'N' END
	   	  ,CONN_SLIP_NO = CASE WHEN #{slipConnSeq} = '1' THEN #{slipNo} ELSE ''END
	   	  ,CONN_SLIP_SEQ = CASE WHEN #{slipConnSeq} = '1' THEN #{slipSeq} ELSE '' END
	   	  ,CONN_SLIP_AMT = CASE WHEN #{slipConnSeq} = '1' THEN #{slipAmt} ELSE 0 END
	   	  ,CONN_SLIP_NO1 = CASE WHEN #{slipConnSeq} = '2' THEN #{slipNo} ELSE '' END
	   	  ,CONN_SLIP_SEQ1 = CASE WHEN #{slipConnSeq} = '2' THEN #{slipSeq} ELSE '' END
	   	  ,CONN_SLIP_AMT1 = CASE WHEN #{slipConnSeq} = '2' THEN #{slipAmt} ELSE 0 END
	   	  ,CONN_SLIP_NO2 = CASE WHEN #{slipConnSeq} = '3' THEN #{slipNo} ELSE '' END
	   	  ,CONN_SLIP_SEQ2 = CASE WHEN #{slipConnSeq} = '3' THEN #{slipSeq} ELSE '' END
	   	  ,CONN_SLIP_AMT2 = CASE WHEN #{slipConnSeq} = '3' THEN #{slipAmt} ELSE 0 END
	 WHERE
		SLIP_NO = #{newSlipNo} AND SLIP_SEQ = #{newSlipSeq}
</update>

//이후에 임시테이블 데이터 삭제
<!-- 임시테이블 삭제(전표등록 시) -->
<delete id="deleteTrsltpAll"  parameterType="TRSltpMngVO">
	DELETE FROM TRSLTP
	WHERE USER_ID = #{loginId}
</delete>
```
```
#)전표삭제
//[행삭제]
function delBtn(){
	var qcell = QCELL.getInstance('qcell'),
		nRow = qcell.getIdx('row'),
		nHeaderRow = qcell.attr('headerrows'),
		chks = qcell.getRowheaderChecked(0); // 첫번째 열이 checkBox
	if(chks.length < 1){
		alert('삭제할 행을 선택하여 주십시오.');
		return false;
	} 
	
	/*1. 전표마감구분(SLIP_FINISH_YN)이 Y인 경우**/	
	for(var i=0; i<=chks.length-1; i++) { //체크한 길이 만큼 반복
		if(qcell.getCellDataEx(chks[i],"slipFinishYn") == 'Y') {
				alert('전표번호['+qcell.getCellDataEx(chks[i],"slipNo")+']에 대한 일마감처리가 되었습니다.\n삭제할 수 없습니다.');
				return false;		
		}
		/*2. 삭제하려는 전표번호에 대한 전표순번에서 더 큰값이 있는지 체크**/
		if(parseInt(checkMaxSlipSeq(qcell.getCellDataEx(chks[i],"slipNo"), qcell.getCellDataEx(chks[i],"slipSeq"))) > 0) {
			alert('전표번호['+qcell.getCellDataEx(chks[i],"slipNo")+']에 대한 전표순번['+qcell.getCellDataEx(chks[i],"slipSeq")+']보다 큰 순번의 Data가 존재합니다.\n삭제할 수 없습니다.')
			return false;
		}
		
	}	
	
	/*3. 연계처리된 전표번호 존재여부 check**/
	//넘어온 전표번호는 중복제거 안해도된다. 어차피 위에서 순차적으로 선택해도 큰 순번의 Data가 존재한다고 뜨니까 결국 하나만 선택해서 삭제 또는
	//전표번호가 다르면서 맨끝 순번을 선택하는 경우밖에 없으니 체크한 전표번호가 겹치지 않는다.
	for(var i=0; i<=chks.length-1; i++) { //체크한 길이 만큼 반복
		if(checkConnSlipNo(qcell.getCellDataEx(chks[i],"slipNo")) != "") {
			alert('전표번호['+qcell.getCellDataEx(chks[i],"slipNo")+']에 대해 연계처리한 전표번호가 존재합니다.\n삭제할 수 없습니다.')
			return false;
		}
	}

//삭제를 위해서 위의 조건이 다 통과되면 진행	
	for(var i = 0; i <= chks.length-1; i++){
		if(confirm('전표번호['+qcell.getCellDataEx(chks[i],"slipNo")+'] 전표순번['+qcell.getCellDataEx(chks[i],"slipSeq")+']에 전표를 삭제하시겠습니까?')) {
			
		}else{
			return false;
		}
		qcell.setRowState(chks[i], "d"); //삭제한다고하면 바로안지우고 상태변화만시키면된다.
	}
		//qcell.deleteRow(nRow);
		qcellChange();



/* 삭제하려는 전표번호에 대한 전표순번에서 더 큰값이 있는지 체크**/
function checkMaxSlipSeq(slipNo,slipSeq) {
	var count;
	//var formData = decodeURIComponent($('#frm0').serialize());		
	$.ajax({
		url: "/transcls/cost/slipMng/checkMaxSlipSeq.do", //통신하실 URL 주소
		//data: { param: JSON.stringify(states) }, //서버에 param이라는 parameter명으로 JSON String형태로 수정 정보 전달
		data: {"slipNo": slipNo, "slipSeq" : slipSeq},
		async: false,
		method: "POST" //post형식으로 전달
	
	}).success(function (data) {
		count = data;
		/* var gridData = data.gridList;
		createQCELL(gridData);
		qcell.hideProgress(300); */
	}).error(function (xhr, status, error) {
		alert("오류가 발생하였습니다.");
		//실패시 처리
	});
	return count;
}

/* 삭제하려는 전표번호에 대한 연계처리됐는지 체크**/
function checkConnSlipNo(slipNo) {
	//var formData = decodeURIComponent($('#frm0').serialize());	
	var connSlipno;
	$.ajax({
		url: "/transcls/cost/slipMng/checkConnSlipNo.do", //통신하실 URL 주소
		//data: { param: JSON.stringify(states) }, //서버에 param이라는 parameter명으로 JSON String형태로 수정 정보 전달
		data: {"slipNo": slipNo},
		async: false,
		method: "POST" //post형식으로 전달
	
	}).success(function (data) {
		connSlipno = data;
	}).error(function (xhr, status, error) {
		alert("오류가 발생하였습니다.");
		//실패시 처리
	});
	return connSlipno;
}
```
```
//쿼리
<!--일전표마감 count조회 -->
<select id="checkMaxSlipSeq" parameterType="String" resultType="String">
	SELECT COUNT(*) AS CNT FROM TRSLIP WHERE SLIP_NO = #{slipNo} AND SLIP_SEQ = #{slipSeq} + 1 
</select>

<!--전표번호에대한 연계전표번호 check -->
//결과가 하나라도 나오면 alert('~에 대해 연계처리한 전표번호가 존재합니다. 삭제할 수 없습니다');
<select id="checkConnSlipNo" parameterType="String" resultType="String">
	SELECT CONCAT(MAX(CONN_SLIP_NO),MAX(CONN_SLIP_NO1),MAX(CONN_SLIP_NO2)) AS CONN_SLIPNO FROM TRSLIP WHERE SLIP_NO=#{slipNo}
</select>
```
```
#)컨트롤러- 일괄저장  impl
//삭제 데이터
list = (List<Map<String, Object>>) paramMap.get("d");
TRSlipMngVO gridD = new TRSlipMngVO();

for(int i=0; i < list.size(); i++) {
	gridD = objectMapper2.convertValue(fn.mapToVoStyle(list,i), TRSlipMngVO.class);
	gridD.setLoginId(user.getId()); // VO에 로그인 ID 값 넣기
	gridD.setLoginIp(user.getIp()); // VO에 로그인 IP 값 넣기
	gridD.setLoginJijum(user.getJijum());
	slipMngDAO.slipMngDeleteGrid(gridD);
	slipMngDAO.slipMngUpdateSlip(gridD); //연계처리된 전표내역 update
	slipMngDAO.slipMngUpdateSlip1(gridD); //연계처리된 전표내역 update
	slipMngDAO.slipMngUpdateSlip2(gridD); //연계처리된 전표내역 update
	if("1".equals(gridD.getChadaeDiv()) && "107".equals(gridD.getAccoCode())){
		slipMngDAO.slipMngUpdateTax1(gridD);
	}
	if("2".equals(gridD.getChadaeDiv()) && "301".equals(gridD.getAccoCode())){
		slipMngDAO.slipMngUpdateTax2(gridD);
	}	
}

//수정 데이터
list = (List<Map<String, Object>>) paramMap.get("u");
TRSlipMngVO gridU = new TRSlipMngVO();

for(int i=0; i < list.size(); i++) {
	gridU = objectMapper2.convertValue(fn.mapToVoStyle(list,i), TRSlipMngVO.class);
	gridU.setLoginId(user.getId()); // VO에 로그인 ID 값 넣기
	gridU.setLoginIp(user.getIp()); // VO에 로그인 IP 값 넣기
	gridU.setLoginJijum(user.getJijum());
	slipMngDAO.slipMngUpdateGrid(gridU);
}
```
```
#)xml
<!--위에 조건들 체크 후 전표삭제-->
    <delete id="slipMngDeleteGrid"  parameterType="TRSlipMngVO">
		DELETE FROM TRSLIP
	     WHERE SLIP_NO = #{slipNo} AND SLIP_SEQ = #{slipSeq}
	</delete>
-----------------------
<!-- 위에서 삭제 후에 연계처리된 전표내역 update 수정 -->
//삭제하려는 전표번호순번에 해당하는 연계정보들 다 빈값으로 
	<update id="slipMngUpdateSlip" parameterType="TRSlipMngVO"> 
		UPDATE TRSLIP
		   SET
		   	   SLIP_YN = 'N'
		   	  ,CONN_SLIP_NO = ''
		   	  ,CONN_SLIP_SEQ = ''
		   	  ,CONN_SLIP_AMT = 0
		 WHERE CONN_SLIP_NO=#{slipNo} AND CONN_SLIP_SEQ = #{slipSeq}
	</update>
	<update id="slipMngUpdateSlip1" parameterType="TRSlipMngVO"> 
		UPDATE TRSLIP
		   SET
		   	   SLIP_YN = 'N'
		   	  ,CONN_SLIP_NO1 = ''
		   	  ,CONN_SLIP_SEQ1 = ''
		   	  ,CONN_SLIP_AMT1 = 0
		 WHERE CONN_SLIP_NO1=#{slipNo} AND CONN_SLIP_SEQ1 = #{slipSeq}
	</update>
	<update id="slipMngUpdateSlip2" parameterType="TRSlipMngVO"> 
		UPDATE TRSLIP
		   SET
		   	   SLIP_YN = 'N'
		   	  ,CONN_SLIP_NO2 = ''
		   	  ,CONN_SLIP_SEQ2 = ''
		   	  ,CONN_SLIP_AMT2 = 0
		 WHERE CONN_SLIP_NO2=#{slipNo} AND CONN_SLIP_SEQ2 = #{slipSeq}
	</update>
----------------------------
<!--위에 작업 이후에 차대구분과 계정과목에 따라서 별도 처리가 필요하다 -->
//impl에서 삭제 시 같이 처리하고있다 분기를(if) 통해. 차대구분이 1(차변)이면서 ACCO_CODE가 107(외상매출금)인 경우
<update id="slipMngUpdateTax1" parameterType="TRSlipMngVO"> 
		UPDATE TRCTAX
		   SET
		   	   TAX_FINISH_YN = 'N'
		   	  ,SLIP_NO = ''
		 WHERE SLIP_NO=#{slipNo}
	</update>
//impl에서 차대구분이 1(차변)이면서 ACCO_CODE가 301(외상매입금)인 경우
	<update id="slipMngUpdateTax2" parameterType="TRSlipMngVO"> 
		UPDATE TRCATX
		   SET
		   	   TAX_FINISH_YN = 'N'
		   	  ,SLIP_NO = ''
		 WHERE SLIP_NO=#{slipNo}
	</update>
```
```
#)매출계산서 전표발생
//매출계산서전표발생 클릭
function maeclBtn() {
	var taxDiv = '매출';
	if(document.getElementById('schSlipDate').value == ''){
		alert('전표일자가 입력되지 않았습니다.\n'+taxDiv+'세금계산서에 대한 자동전표생성처리를 할 수 없습니다.')
		return false;
	}
	else {
		if(confirm('전표일['+document.getElementById('schSlipDate').value+']에 해당하는\n'+taxDiv+'세금계산서에 대한 자동전표생성처리 하시겠습니까?')) {
			if(checkRegistered(document.getElementById('schSlipDate').value.replaceAll('-','')) > 0) { //해당날짜에 이미 마감되어있는지 체크
				alert('전표일자['+document.getElementById('schSlipDate').value+']에 대한 마감처리가 되었습니다.\n전표등록 처리를 할 수 없습니다.')
				return false;
			}
			else{
				//전표미발행 세금계산서 건수 조회
				if(checkMaecl(document.getElementById('schSlipDate').value.replaceAll('-','')) <= 0) {
					alert('해당전표일자에 대한 전표미발행된'+taxDiv+'세금계산서 DATA가 없습니다.')
					return false;
				}
				else { //건수가 1건이상 있으면
					//전표생성
					createMaecl(document.getElementById('schSlipDate').value.replaceAll('-',''))
				}
				
			}
		}else {
			return false;
		}
	}
}

/*입력한 전표일에 대한 일전표 마감체크**/
//즉 해당 날짜에 TRDDBA에 데이터가 있으면 전표등록 처리를 할 수가 없다.
//SELECT COUNT(*) AS CNT FROM TRDDBA WHERE ACC_YMD = #{param}
function checkRegistered(registDate) {
	var count;
	
	$.ajax({
		url: "/transcls/cost/slipMng/countRegisteredSlipMng.do",
		data: {
			param: registDate
		},
		async: false,
		method: "POST"
	}).success(function(data) {
		count = data;
	}).error(function(xhr,status,error) {
		alert('오류가 발생하였습니다.');
	});
	return count;
}


/*매출세금계산서건수조회**/
	function checkMaecl(schSlipDate) {
		//var formData = decodeURIComponent($('#frm0').serialize()); //input id="param" name="param"
		var count;
		$.ajax({
			url: "/transcls/cost/slipMng/checkMaeclSlipMng.do", //통신하실 URL 주소
			//data: { param: JSON.stringify(states) }, //서버에 param이라는 parameter명으로 JSON String형태로 수정 정보 전달
			data: {"schSlipDate":schSlipDate},
			async: false,
			method: "POST" //post형식으로 전달
		}).success(function (data) {
			count = data
			
			/* var gridData = data.gridList;
			createQCELL(gridData);
			qcell.hideProgress(300); */
		}).error(function (xhr, status, error) {
			alert("오류가 발생하였습니다.");
			qcell.hideProgress(300);
			//실패시 처리
		});
		return count;
	}

<!--전표미발행 매출세금계산서 건수-->
<select id="checkMaeclSlipMng" parameterType="TRSlipMngVO" resultType="String">
	SELECT COUNT(*) AS CNT FROM TRCTAX WHERE ISSUE_DATE=#{schSlipDate} AND TAX_FINISH_YN='N' ORDER BY TAX_NO
</select>

//위에서 건수가 0이면 alert('해당전표일자에 대한 전표미발행된'+taxDiv+'세금계산서 DATA가 없습니다.')
//건수가 있으면 createMaecl(document.getElementById('schSlipDate').value.replaceAll('-',''))
//건수가 있으면 지점,세금계산서번호,거래처코드, 품명1, 품명2, 품명3, 품명4, 총공급가액, 총세액 변수를 담는다.(gridList)

<!--매출세금계산서생성-->
function createMaecl(schSlipDate) { //인자는 20231123 형태로온다.
	qcell.showProgress();
	$.ajax({
		url: "/transcls/cost/slipMng/selectMaeclSlipMng.do",
		data: {
			"schSlipDate" : schSlipDate //이걸 VO로 받음
		},
		async: false,
		method: "POST"
	}).success(function(data) {
		qcell.hideProgress(300);
		if(data.status == "fail") {
			alert('에러가 발생하였습니다.');
			return false;
		}
		var gridData = data.gridList;
		createQCELL(gridData);
	}).error(function(xhr,status,error) {
		alert('오류가 발생하였습니다.');
		qcell.hideProgress(300);
	});
}

#)컨트롤러 transcls/cost/slipMng/selectMaeclSlipMng.do
//아래 gridList는 매출세금계산서 생성할때 쓰인다.(taxAmt,taxVat 등)
List<TRCtxMngVO> gridList = slipMngService.selectMaeclSlipMng(tRSlipMngVO); //여기 VO에는 세금계산서처리 전표일자가 담긴다.
<!--전표미발행 매출세금계산서 조회-->
    <select id="selectMaeclSlipMng" parameterType="TRSlipMngVO" resultType="TRCtxMngVO">
		SELECT JIJUM, TAX_NO, CUST_CODE, ITEM1, ITEM2, ITEM3, ITEM4, TAX_AMT, TAX_VAT FROM TRCTAX WHERE ISSUE_DATE=#{schSlipDate} AND TAX_FINISH_YN='N' ORDER BY TAX_NO
    </select>
//위에서 넣은 값을(gridList) 아래에 던진다.(컨트롤러)
slipMngService.createMaeclSlipMng(gridList,tRSlipMngVO.getSchSlipDate());

//createMaeclSlipMng (Impl)에서 보면 새 전표번호를 생성해야하는데
public void createMaeclSlipMng(List<TRCtxMngVO> gridList, String schSlipDate) {
	TRCtxMngVO vo = new TRCtxMngVO();
	LoginVO user = (LoginVO)EgovUserDetailsHelper.getAuthenticatedUser(); // 현재 로그인한 계정정보 가져오기
	for(int i = 0; i<gridList.size(); i++) {
		vo = gridList.get(i);
		vo.setSchSlipDate(schSlipDate);
		vo.setNewSlipNo(slipMngDAO.selectNewSlipNo(schSlipDate)); //아래 참조
		vo.setLoginId(user.getId());
		vo.setLoginIp(user.getIp());
		vo.setLoginJijum(user.getJijum());
		slipMngDAO.createMaeybSlipMng(vo); //아래 참조
	} 
}

#)slipMngDAO.selectNewSlipNo(schSlipDate)의 쿼리 내용
SELECT CONCAT(#{slipDate},LPAD(IFNULL(MAX(SUBSTRING(SLIP_NO,9,3)),0)+1,3,'0')) FROM TRSLIP WHERE SUBSTRING(SLIP_NO,1,8) = #{slipDate}

#)slipMngDAO.createMaeybSlipMng
public void createMaeybSlipMng(TRCtxMngVO vo) throws Exception {
	insert("slipMngDAO.createMaeybSlipMng",vo);
	insert("slipMngDAO.createMaeybSlipMng2",vo);
	insert("slipMngDAO.createMaeybSlipMng3",vo);
	update("slipMngDAO.updateMaeybSlipMng",vo);
}


//위에서 구한 데이터를 던지는 이유는 전표DATA를 3개 생성해야하는데 아래에서 쓰인다.(전표번호 하나에 대해서 전표순번3개)
매출전표를 생성할때는
전표순번: 001은 차대구분(CHADAE_DIV): '1', 계정과목(ACCO_CODE) :'107'(외상매출금), 
       차변금액(DEBTOR_AMT): 총공급가액,  대변금액(CREDIT_AMT): 0,
       적요(REMARK): 품명1이 '운송료'이고 품명2가 값이 없을 경우 '운송료', 품명2가 값이 있을 경우 '운송료 외', 
                    품명1이 '관리비'인 경우 '관리비', 품명1이 '배차대행서비스'인 경우 '배차대행서비스', 그 외 ''
전표순번: 002,  차대구분(CHADAE_DIV): '2',  계정과목(ACCO_CODE): 품명1이 '운송료'인 경우 '501'(수입운송료), '관리비','배차대행서비스'인 경우 '504'(관리비수입), 
             차변금액(DEBTOR_AMT): 0, 대변금액(CREDIT_AMT): 총공급가액,  적요(REMARK) : 품명1+'/'+품명2+'/'+품명3+'/'+품명4
전표순번: 003,  차대구분(CHADAE_DIV): '2',  계정과목(ACCO_CODE): '305'(예수부과세),
             차변금액(DEBTOR_AMT): 0, 대변금액(CREDIT_AMT): 총세액,  적요(REMARK) : ''

<!-- 전표미발행 매출세금계산서 전표등록(전표순번001) -->
    <insert id="createMaeclSlipMng" parameterType="TRCtxMngVO">			
		  INSERT INTO TRSLIP
				( 
				   SLIP_NO <!--전표번호 -->
				  ,SLIP_SEQ <!--전표순번-->
				  ,SLIP_DATE <!--전표일자-->
				  ,SLIP_DIV <!--전표구분(입금,출금,대체) -->
				  ,CHADAE_DIV <!--차대구분(차변,대변)-->
				  ,ACCO_CODE <!--계정과목코드-->
				  ,DEBTOR_AMT <!--차변금액-->
				  ,CREDIT_AMT <!--대변금액-->
				  ,REMARK <!--적요-->
				  ,SLIP_YN <!--전표처리구분-->
				  ,SLIP_FINISH_YN <!--전표마감구분-->
				  ,SLIP_PRINT_YN <!--전표출력여부-->
				  ,CONN_SLIP_NO<!--연계전표번호-->
				  ,CONN_SLIP_SEQ <!--연계순번-->
				  ,INSERT_DATE
				  ,INSERT_ID
				  ,INSERT_IP
				  ,UPDATE_DATE
				  ,UPDATE_ID
				  ,UPDATE_IP
				)
			VALUES (
			 	  #{newSlipNo}
			 	  ,'001'
			 	  ,#{schSlipDate}
			 	  ,'T'
			 	  ,'1'
			 	  ,'107'
			 	  ,#{taxAmt}
			 	  ,0
			 	  ,(CASE 
			 	  		WHEN #{item1} = '운송료' THEN
			 	  			CASE WHEN #{item2} = '' OR #{item2} IS NULL THEN '운송료'
			 	  				 ELSE '운송료 외'
			 	  				 END
			 	  		WHEN #{item1} = '관리비' THEN '관리비'
			 	  		WHEN #{item1} = '배차대행서비스' THEN '배차대행서비스'
			 	  		ELSE '그 외'
			 	  	END)
			 	  ,'N'
			 	  ,'N'
			 	  ,'N'
			 	  ,''
			 	  ,''
			 	  ,SYSDATE()
			 	  ,#{loginId}
			 	  ,#{loginIp}
			 	  ,SYSDATE()
			 	  ,#{loginId}
			 	  ,#{loginIp}
				  )
	</insert>
	<!-- 전표미발행 매출세금계산서 전표등록(전표순번002) -->
    <insert id="createMaeclSlipMng2" parameterType="TRCtxMngVO">			
		  INSERT INTO TRSLIP
				( 
				   SLIP_NO <!--전표번호 -->
				  ,SLIP_SEQ <!--전표순번-->
				  ,SLIP_DATE <!--전표일자-->
				  ,SLIP_DIV <!--전표구분(입금,출금,대체) -->
				  ,CHADAE_DIV <!--차대구분(차변,대변)-->
				  ,ACCO_CODE <!--계정과목코드-->
				  ,DEBTOR_AMT <!--차변금액-->
				  ,CREDIT_AMT <!--대변금액-->
				  ,REMARK <!--적요-->
				  ,SLIP_YN <!--전표처리구분-->
				  ,SLIP_FINISH_YN <!--전표마감구분-->
				  ,SLIP_PRINT_YN <!--전표출력여부-->
				  ,CONN_SLIP_NO<!--연계전표번호-->
				  ,CONN_SLIP_SEQ <!--연계순번-->
				  ,INSERT_DATE
				  ,INSERT_ID
				  ,INSERT_IP
				  ,UPDATE_DATE
				  ,UPDATE_ID
				  ,UPDATE_IP
				)
			VALUES (
			 	  #{newSlipNo}
			 	  ,'002'
			 	  ,#{schSlipDate}
			 	  ,'T'
			 	  ,'2'
			 	  ,(CASE 
			 	  		WHEN #{item1} = '운송료' THEN '501'
			 	  		WHEN #{item1} = '관리비' THEN '504'
			 	  		WHEN #{item1} = '배차대행서비스' THEN '504'
			 	  	END)
			 	  ,0
			 	  ,#{taxAmt}
			 	  ,CONCAT(#{item1},'/',#{item2},'/',#{item3},'/',#{item4})
			 	  ,'N'
			 	  ,'N'
			 	  ,'N'
			 	  ,''
			 	  ,''
			 	  ,SYSDATE()
			 	  ,#{loginId}
			 	  ,#{loginIp}
			 	  ,SYSDATE()
			 	  ,#{loginId}
			 	  ,#{loginIp}
				  )
	</insert>
	<!-- 전표미발행 매출세금계산서 전표등록(전표순번003) -->
    <insert id="createMaeclSlipMng3" parameterType="TRCtxMngVO">			
		  INSERT INTO TRSLIP
				( 
				   SLIP_NO <!--전표번호 -->
				  ,SLIP_SEQ <!--전표순번-->
				  ,SLIP_DATE <!--전표일자-->
				  ,SLIP_DIV <!--전표구분(입금,출금,대체) -->
				  ,CHADAE_DIV <!--차대구분(차변,대변)-->
				  ,ACCO_CODE <!--계정과목코드-->
				  ,DEBTOR_AMT <!--차변금액-->
				  ,CREDIT_AMT <!--대변금액-->
				  ,REMARK <!--적요-->
				  ,SLIP_YN <!--전표처리구분-->
				  ,SLIP_FINISH_YN <!--전표마감구분-->
				  ,SLIP_PRINT_YN <!--전표출력여부-->
				  ,CONN_SLIP_NO<!--연계전표번호-->
				  ,CONN_SLIP_SEQ <!--연계순번-->
				  ,INSERT_DATE
				  ,INSERT_ID
				  ,INSERT_IP
				  ,UPDATE_DATE
				  ,UPDATE_ID
				  ,UPDATE_IP
				)
			VALUES (
			 	  #{newSlipNo}
			 	  ,'003'
			 	  ,#{schSlipDate}
			 	  ,'T'
			 	  ,'2'
			 	  ,'305'
			 	  ,0
			 	  ,#{taxVat}
			 	  ,''
			 	  ,'N'
			 	  ,'N'
			 	  ,'N'
			 	  ,''
			 	  ,''
			 	  ,SYSDATE()
			 	  ,#{loginId}
			 	  ,#{loginIp}
			 	  ,SYSDATE()
			 	  ,#{loginId}
			 	  ,#{loginIp}
				  )
	</insert>
	//매출테이블 쪽에 위에서 생성했던 전표번호를 넣어주고 TAX_FINISH도 Y로 바꿔야한다.
	<update id="updateMaeclSlipMng" parameterType="TRCtxMngVO"> 
		UPDATE TRCTAX
		   SET
		   	   TAX_FINISH_YN = 'Y'
		   	  ,SLIP_NO = #{newSlipNo}
		   	  ,UPDATE_DATE = SYSDATE()
			  ,UPDATE_ID = #{loginId}
			  ,UPDATE_IP = #{loginIp}
		 WHERE JIJUM = #{loginJijum} AND TAX_NO = #{taxNo}
	</update>
	


매입전표를 생성할 때는
- 전표순번: 001,  차대구분(CHADAE_DIV): '2', 계정과목(ACCO_CODE) :'301'(외상매입금), 
               차변금액(DEBTOR_AMT): 0,  대변금액(CREDIT_AMT): 총공급가액,
               적요(REMARK): 품명1이 '운송료'이고 품명2가 값이 없을 경우 '운송료', 품명2가 값이 있을 경우 '운송료 외', 
                            품명1이 '관리비'인 경우 '관리비', 품명1이 '배차대행서비스'인 경우 '배차대행서비스', 그 외 ''
  전표순번: 002,  차대구분(CHADAE_DIV): '1',  계정과목(ACCO_CODE): '601'(지급운송료), 
               차변금액(DEBTOR_AMT): 총공급가액, 대변금액(CREDIT_AMT): 0,  적요(REMARK) : 품명1+'/'+품명2+'/'+품명3+'/'+품명4
  전표순번: 003,  차대구분(CHADAE_DIV): '1',  계정과목(ACCO_CODE): '136'(선납부과세),
               차변금액(DEBTOR_AMT): 총세액, 대변금액(CREDIT_AMT): 0,  적요(REMARK) : ''
```
```
//json과 일반 list의 차이이다. 그래서 listToJson으로 변환해야된다 컨트롤러단에
var combo_data1 = [  {'label': '선택', 'value': ''}
					    ,{'label': '수리비', 'value': 'SR'}
					    ,{'label': '유류대', 'value': 'JK'}
					    ,{'label': '가불금', 'value': 'GB'}
					    ,{'label': '지입', 'value': 'ZI'} ];
// 적요항목
var comboDataSr = [{label=01-우성정비, value=01}, {label=02-우성상사, value=02}, {label=03-기동정비, value=03}, {label=04-동국자동차, value=04}, {label=05-우성상회, value=05}
```

```
큐셀에서 엑셀업로드 할때 나는 클릭을 할 때 동작하게끔 했다. 
<li class="txt" style="width: 300px;">
	<input type="file" onclick="settingCardBox()" id="uploadFile" name="uploadFile">
</li>

function settingCardBox() {
	var cardSelect = document.getElementById("selectCardBox"); //비씨,하나인지 선택
    // select element에서 선택된 option의 value가 저장된다.
    var selectValue = cardSelect.options[cardSelect.selectedIndex].value;
	//큐셀이 있어야 만들지
    document.getElementById("selectCardBox").value = selectValue;
    if(selectValue == 'bc') { //업로드 파일이 변경되는지 캐치
    	QBOX.$("#uploadFile").change(function (e) {  //파일을 업로드 하지않고 취소했을때 즉, 파일이 없을때
    		if(document.querySelector('#uploadFile').value == '') {
    			
    		}else { //input에 파일이 있을 때
				//다시 만드는 이유는 엑셀문서와 컬럼 순서를 맞추기위해 컬럼을 remove해야한다.
				//근데 excelUpload라이브러리는 createQCELL을 하지않고 만들어진 qcell_Bc를 가지고
				//엑셀데이터를 그대로 그리드에 뿌려준다.
				//그 말은 즉슨, 만들어진 그리드라고 하면 컬럼을 remove한것을 의미한다.
				//즉, 컬럼이 업로드할때마다 계속 삭제되면 안되니까 업로드할때마다 새로운 큐셀을 만들어주고
				//컬럼을 remove 해준다.
    			createQCELL_Bc(initData) 
    			var properties = {
    	                event: e,
    	                headerrows: 1,
    	                progressui: true
    	        	};
    	        //createQCELL_Bc(gridData);
    	        qcell_Bc.excelUpload(properties);	
    		}
        });
    }else {
    	QBOX.$("#uploadFile").change(function (e) {
    		if(document.querySelector('#uploadFile').value=='') {
    			
    		}else {
    				createQCELL_Hana(initData)
                	var properties = {
                	event: e,
                	headerrows: 10,
                	progressui: true,
            	}; //순서는 엑셀을 그리드에 다 띄우고 qcell_Ha.bind("exceluploadlocend",function)을 탄다. 
            	qcell_Ha.excelUpload(properties); 
    		}
        });
    }
}

#)그리드생성
param으로 searchBtn, junpyo를 구분한 이유는 
search하고 그리드를 재생성해서 띄워주기 때문에 createQCELL_Bc(gridData,"searchBtn") 를 통해
먼저 removeColumn 다해주고 gridData를 그리드에 넣는다.
removeRow를 안한이유는 엑셀업로드할때만 들어가면된다. 실제 검색할때는 디비에 있는 요소를 가져오기 떄문에
row를 지울필요가없다. 실데이터니까

junpyo도 마찬가지이다. 

즉, 엑셀업로드할 때만 엑셀에 하단 필요없는 로우가 있기때문에 지운것이다.(removeRows)

function createQCELL_Hana(gridData,param){
	QCELL.create({
		id : 'qcell_Ha',
    	parentid : 'sheetarea',
    	..중략
    	columns : [ 	 //1,2,3,4   		
    		 {key: 'no', width: "70px", title: ['순번'], type: "input", styleclassname: { "data": "align-right" }}
    		,{key: 'no1', width: "70px", title: ['순번'], type: "input", styleclassname: { "data": "align-right" }}
    		..중략
		],
		merge: {"header": "row"}, // 행 title이 같은것은 병합
	});
	qcell_Ha = QCELL.getInstance("qcell_Ha");
	//전표체크일떄와 업로드할때와 컬럼삭제의 동작이 겹치면 안된다. 이중으로 삭제되기때문에
	//왜냐하면 전표체크때도 createQcell을 하고, 업로드할때도 createQcell을 호출하기때문에
	if(param == "searchBtn") {
		alert('search')
		qcell_Ha.removeColumn(2);
	    qcell_Ha.removeColumn(2);
	    qcell_Ha.removeColumn(2);
	    qcell_Ha.removeColumn(2);
	    qcell_Ha.removeColumn(3);
	    qcell_Ha.removeColumn(4);
	    qcell_Ha.removeColumn(6);
	    qcell_Ha.removeColumn(8);
	    qcell_Ha.removeColumn(10);
	    qcell_Ha.removeColumn(14);
	    qcell_Ha.removeColumn(15);
	}
	if(param == "junpyo") {
		//removeRows를 먼저해야 console에 찍을 때 행삭제된것을 볼 수 있다.
		//qcell_Ha.removeRows(4); //removeColumn과 다르게 removeRows는 전에 행삭제했던(엑셀업로드시) 그대로 가져오고있다.
		qcell_Ha.removeColumn(2);
	    qcell_Ha.removeColumn(2);
	    qcell_Ha.removeColumn(2);
	    qcell_Ha.removeColumn(2);
	    qcell_Ha.removeColumn(3);
	    qcell_Ha.removeColumn(4);
	    qcell_Ha.removeColumn(6);
	    qcell_Ha.removeColumn(8);
	    qcell_Ha.removeColumn(10);
	    qcell_Ha.removeColumn(14);
	    qcell_Ha.removeColumn(15);
	}
	qcell_Ha.bind("exceluploadlocend",function(event) {
	    	qcell_Ha.removeRows(4);
			qcell_Ha.removeColumn(2);
	    	qcell_Ha.removeColumn(2);
	    	qcell_Ha.removeColumn(2);
	    	qcell_Ha.removeColumn(2);
	    	qcell_Ha.removeColumn(3);
	    	qcell_Ha.removeColumn(4);
	    	qcell_Ha.removeColumn(6);
	    	qcell_Ha.removeColumn(8);
	    	qcell_Ha.removeColumn(10);
	    	qcell_Ha.removeColumn(14);
	   		qcell_Ha.removeColumn(15);
	});
} // createQCELL() 끝


```


