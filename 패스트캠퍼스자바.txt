A -> 65 인코딩
65-> A 디코딩

각 나라별 문자세트가 다르니 호환이 안된다 그래서, 하나의 코드표로 통일하자 -> 유니코드(2byte표현)
-> 16비트 (2의 16승)

'a' -> 2byte 문자 -> 16bit -> 표현값개수 65536개 -> 문자라서 첫번째자리를 부호에 사용하지않기때문에 65536개이다.
short도 2byte이지만 부호가 표현되야하니 -32768~32767
"a" -> 문자열

//char는 자바에서 유니코드(2byte 문자체계)를 사용하므로 2byte이다
//c언어는 아스키코드를 사용하기 때문에 1byte크기를 갖는다.

유니코드란?

세계 각 국의 언어를 통일된 방법으로 표현할 수 있게 제안된 국제적인 코드 규약이다.
컴퓨터가 미국에서 개발되어져 영어를 바탕으로 정의되어 있다.
영어는 26자의 알파벳과 몇 가지 특수 문자를 표현하기에 1 byte로 충분했기 때문에
문자가 1 byte로 표현되고 있지만,
동양 3국의 한글, 한자 또는 일어 등과 같은 문자는 1 byte로는 표현이 불가능하기에
2 byte로 문자를 표현하는 유니코드가 만들어 졌다.

=======================================================================


//강제로
char ch1='A';
System.out.println((int)ch1);

int ch3 = 67;
System.out.println((char)ch3);


//변하지 않는 값은 + 공통적으로 쓰이는 -> final int max_num = 100;
//max_num = 20; 은 불가능

========================================================================
#)map 사용
public static void main(String[] args) {
	HashMap<String,Integer> map = new HashMap<String,Integer>();
	
	//키는 String, value는 Integer
	map.put("Soraka",450);
	map.put("Garen",4800);
	map.put("Garen",450); //중복된 key는 선언은 가능하지만 젤 마지막 선언된것이 덮어씌운다
	
	System.out.println("Map value: " + map.get("Garen"));  //450
	System.out.println("Map value: " + map.size());  //2
	
	map.replace("Garen", 160); //Key값의 내용을 변경
	
	System.out.println("Key Exist: " + map.containsKey("Garen")); //key가 존재하는지 확인
	System.out.println("Value Exist: " + map.containsValue(160)); //value가 존재하는지 확인
	
	System.out.println("Map Empty: " + map.isEmpty()); //map의 크기가 0인지 확인
	
	map.remove("Garen");
}

=========================================================================
#)HashMap은 Map인터페이스에 속해있는 컬렉션이다.따라서, map인터페이스의 기본 기능들을 전부구현할 수 있다
#)map의 keyset메서드 사용
public class Sample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("people", "사람");
        map.put("baseball", "야구");
        System.out.println(map.keySet());  // 키출력 --> [baseball, people] 출력
    }
}
==========================================================================
for(String key : map.keySet()) {
	System.out.println("Value: " + map.get(key));
}

==============================================================================
#)jackson이란
Java Object를 JSON으로 변환하거나 JSON을 Java Object로 변환하는데 사용할 수 있는 Java 라이브러리입니다.

==============================================================================
package ch03;

public class FunctionTest {
	public static int addNum(int num1, int num2) {
		int result;
		result = num1 + num2;
		return result;
	}
	
	public static void sayHello(String greeting) {
		System.out.println(greeting);
	}
	public static int calcSum() {
		int sum = 0;
		int i;
		for(i = 0; i<=100; i++) {
			sum += i; 
		}
		return sum;
	}
	
	public static void main(String[] args) {
		int n1=10;
		int n2=20;
		
		int total = addNum(n1,n2);
		System.out.println(total);
		
		sayHello("안녕하세요");
		
		total = calcSum();
		System.out.println(total);
	}
}

//스택: 함수가 호출될 때 지역변수들이 사용하는 메모리
//스택: 함수의 수행이 끝나면 자동으로 반환되는 메모리

=====================================================================================
package ch04;

public class Student {
	public int studentID;
	public String studentName;
	public String address;
	
	public void showStudentInfo() {
		System.out.println(studentID + "학번의 이름은" + studentName + "이고 주소는" + address + "입니다.");
	}
	
	public String getStudentName() {
		return studentName;
	}
	
	public void setStudentName(String name) {
		studentName = name;
	}
}
----------------
package ch04;

public class MainStudent {
	public static void main(String[] args) {
		Student studentLee = new Student(); //인스턴스라고한다, 같은 패키지내에서는 import 안한다
		Student studentKim = new Student();
		
		//인스턴스들은(studentLee, studentKim) 동적메모리(Heap)에 할당된다.
		//c나 c++에서는 사용한 동적메모리를 프로그래머가 해제시켜야한다.(free, delete)
		//자바에서는 가비지컬렉터가 주기적으로 사용하지 않는 메모리를 수거한다.
		//하나의 클래스로부터 여러개의 인스턴스가 생성되고 각각 다른 메모리 주소를 가지게 된다.
		
		studentLee.studentID = 12345;
		studentLee.setStudentName("Lee");
		studentLee.address = "서울 강남구";
		
		studentLee.showStudentInfo();
		
		System.out.println(studentKim); //ch04.Student@36aa7bc2 -> 객체의 위치를 가리키는(Heap에 있는 인스턴스를 가리킨다) 주소값이다. (물리적 메모리주소가 아니라 JVM이 준 가상 주소)
		//그래서 studentKim. (점.)을 찍음으로써 접근
		System.out.println(studentLee);
		
		//인스턴스 : new 키워드를 사용하여 클래스를 메모리에 생성한 상태(힙)
		//참조변수: 메모리에 생성된 인스턴스를 가리키는 변수(스택)
		//참조값: 생성된 인스턴스의 메모리 주소값
	}
}
=========================================================================================
package ch06;

public class Student { //멤버변수는 알아서 초기화된다. null, 0
	public int studentNumber;
	public String studentName;
	public int grade;
	
	public Student() {
		System.out.println("생성자");
	}
	
	public Student(int studentNumber, String studentName, int grade) {
		this.studentNumber = studentNumber; //변수이름이 다르면 this붙일필요가없다
		this.studentName = studentName;
		this.grade = grade;
	}
	
	public String showStudentInfo() {
		int i; //i는 초기화되지 않는다.(지역변수라서)
		return studentName + "학생의 학번은" + studentNumber + "이고, " + grade + "학년 입니다.";
	}
}
----------------
package ch06;

public class StudentMain {
	public static void main(String[] args) {
		Student studentLee = new Student();
		Student studentKim = new Student(123456, "Kim", 3);
		
		System.out.println(studentKim.showStudentInfo()); 
		
		System.out.println(studentLee.showStudentInfo()); //null,0~
	}
}
============================================================================================
package ch09;

public class Student {
	int studentId;
	String studentName;
	
	Subject korea; //class내에서 쓸수있도록(전역변수? 느낌)
	Subject math;
	
	Student(int studentId, String studentName) {
		this.studentId = studentId;
		this.studentName = studentName;
		
		korea = new Subject();
		math = new Subject();
	}
	
	public void setKoreaSubject(String name, int score) {
		korea.subjectName = name;
		korea.score = score;
	}
	
	public void setMathSubject(String name, int score) {
		math.subjectName = name;
		math.score = score;
	}
	
	public void showScoreInfo() {
		int total = korea.score + math.score;
		System.out.println(studentName + "학생의 총점은" + total + "점 입니다.");
	}
}
-------------------
package ch09;

public class Subject {
	String subjectName;
	int score;
	int subjectId;
}
-------------------
package ch09;

public class SubjectMain {
	public static void main(String[] args) {
		Student studentLee = new Student(100, "Lee");
		studentLee.setKoreaSubject("국어", 100);
		studentLee.setMathSubject("수학", 99);
		
		Student studentKim = new Student(200, "Kim");
		studentKim.setKoreaSubject("국어", 80);
		studentKim.setMathSubject("수학", 100);
		
		studentLee.showScoreInfo();
		studentKim.showScoreInfo();
	}
}
=======================================================================================
package ch10;

public class BirthDay {
	private int day; //같은 클래스내에서만 접근 -> private
	private int month;
	private int year;
	
	private boolean isVaild; //기본값이 false
	
	public int getDay() {
		return day;
	}
	public void setDay(int day) {
		this.day = day;
	}
	public int getMonth() {
		return month;
	}
	public void setMonth(int month) {
		if(month < 1 || month > 13) {
			isVaild = false;
		}
		else {
			isVaild = true;
			this.month = month;
		}
	}
	public int getYear() {
		return year;
	}
	public void setYear(int year) {
		this.year = year;
	}
	
	public void showDate() {
		if(isVaild) { //true이면
			System.out.println(year + "년 " + month + "월 " + day + "일 입니다.");
		}
		else {
			System.out.println("유효하지 않은 날짜입니다.");
		}
	}
}
----------------
package ch10;

public class BirthDayMain {
	public static void main(String[] args) {
		BirthDay date = new BirthDay();
		date.setYear(2019);
		
		//private를 쓰는이유는 
		//date.month = 100 이렇게 범위를 벗어난값을 바로 대입가능하기 때문이다.
		//그래서 setter를 통해 제약을 걸었다.
		
		//date.setMonth(13);  month가 1~12사이가 아닌것은 처리 xx, BirthDay클래스에서 처리했다, 유효하지 않은 날짜라고 뜬다.
		date.setDay(30);
	}
}
=========================================================================
package ch11;

public class MakeReport {

	StringBuffer buffer = new StringBuffer(); //append메서드로 String을 연결한다
	
	private String line = "===========================================\n";
	private String title = "  이름\t   주소 \t\t  전화번호  \n";
	private void makeHeader()
	{
		buffer.append(line);
		buffer.append(title);
		buffer.append(line);
	}
	
	private void generateBody()
	{
		buffer.append("James \t");
		buffer.append("Seoul Korea \t");
		buffer.append("010-2222-3333\n");
		
		buffer.append("Tomas \t");
		buffer.append("NewYork US \t");
		buffer.append("010-7777-0987\n");
	}
	
	private void makeFooter()
	{
		
		buffer.append(line);
	}
	
	public String getReport()
	{
		makeHeader();
		generateBody();
		makeFooter();
		return buffer.toString();
	}
}
-----------------
package ch11;

public class MainReport {

	public static void main(String[] args) {

		MakeReport report = new MakeReport();
		String builder = report.getReport();
		
		System.out.println(builder);
	}

}
====================================================================
package ch12;

public class Person {
	String name;
	int age;
	
	public Person() {
		//age = 10;
		//name = "test"
		//this위에 쓰면 안된다. 객체가 만들어지기 전이기 때문에
		this("no name", 1);
	}
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	public void showPerson() {
		System.out.println(name + ", " + age);
	}
	public Person getPerson() { 
		return this; //객체자신을 반환
	}
	
	public static void main(String[] args) {
		Person person = new Person();
		person.showPerson(); //no name, 1
		
		System.out.println(person);  //ch12.Person@1175e2db
		
		Person person2 = person.getPerson(); //person2도 person을 바라본다.
		System.out.println(person2); //ch12.Person@1175e2db 같다.  this == main의 Person 이 같은 Heap공간의 Person을 가리킨다
		
	}
}
===============================================================================
package ch14;

public class Student {
	String studentName;
	int money;
	
	public Student(String studentName, int money) {
		this.studentName = studentName;
		this.money = money;
	}
	
	public void takeBus(Bus bus) {
		bus.take(1000); //버스를타면 1000원을 지불
		this.money -= 1000;
	}
	
	public void takeSubway(Subway subway) {
		subway.take(1200);
		this.money -= 1200;
	}
	
	public void showInfo() {
		System.out.println(studentName + "님의 남은 돈은 " + money + "원 입니다.");
	}
	
}
--------------
package ch14;

public class Subway {
	int lineNumber;
	int passengerCount; //승객수
	int money;
	
	public Subway(int busNumber) {
		this.lineNumber = busNumber;
	}
	
	public void take(int money) {
		this.money = money;
		passengerCount++;
	}
	
	public void showsubwayInfo() {
		System.out.println(lineNumber + "번의 승객 수는 " + passengerCount + "명 이고, 수입은 " + money + "원 입니다.");
	}
}
---------------
package ch14;

public class TakeTransTest {

	public static void main(String[] args) {
		Student studentJ = new Student("James", 5000);
		Student studentT = new Student("Tomas", 10000);
		
		Bus bus100 = new Bus(100);  //버스넘버
		Bus bus500 = new Bus(500);
		
		studentJ.takeBus(bus100); //studentJ가 bus100을 탔다.
		
		Subway greenSubway = new Subway(2); //lineNumber
		studentT.takeSubway(greenSubway);
		
		studentJ.showInfo();
		studentT.showInfo();
		
		bus100.showBusInfo();
		greenSubway.showsubwayInfo();
	}

	/*
	 * James님의 남은 돈은 4000원 입니다. 
	 * Tomas님의 남은 돈은 8800원 입니다. 
	 * 100번의 승객 수는 1명 이고, 수입은
	 * 1000원 입니다. 2번의 승객 수는 1명 이고, 수입은 1200원 입니다.
	 */
}
========================================================================
package ch16;

public class Employee {
	//static변수는 프로그램이 실행되면서 메모리에 로드될때 같이 적재된다. (객체 생성 전)
	public static int serialNum = 1000; //public이라서 외부에서 클래스.serialNum 접근가능하다
	
		private int employeeId;
		private String employeeName;
		private String department;
			
		public Employee()
		{
			serialNum++;
			employeeId = serialNum;
		}
		
		public int getEmployeeId() {
			return employeeId;
		}
		public void setEmployeeId(int employeeId) {
			this.employeeId = employeeId;
		}
		public String getEmployeeName() {
			return employeeName;
		}
		public void setEmployeeName(String employeeName) {
			this.employeeName = employeeName;
		}
		public String getDepartment() {
			return department;
		}
		public void setDepartment(String department) {
			this.department = department;
		}
}
--------------
package ch16;

public class EmployeeTest {

	public static void main(String[] args) {
		Employee employeeLee = new Employee();
		employeeLee.setEmployeeName("이순신");
				
		Employee employeeKim = new Employee();
		employeeKim.setEmployeeName("김유신");
				
		System.out.println(employeeLee.getEmployeeName() + "," + employeeLee.getEmployeeId());
		System.out.println(employeeKim.getEmployeeName() + "," + employeeKim.getEmployeeId());
		
		System.out.println(Employee.serialNum); //static변수는 클래스로 바로 접근 가능
	}
}
===================================================================
package ch17;

public class Employee {
	private static int serialNum = 1000; //private로 고쳤다 -> getter로 가져와야한다
		
		private int employeeId;
		private String employeeName;
		private String department;
			
		public Employee()
		{
			serialNum++;
			employeeId = serialNum;
		}
		
		public static int getSerialNum() {
			return serialNum;
		}
	
		public static void setSerialNum(int serialNum) { //serialNum을 직접 변경할 때
			int i = 0;
			
		//	employeeName = "Lee";  //오류발생 static이라서
			Employee.serialNum = serialNum; //공통으로 쓰는 static값 변경
		}
	
		public int getEmployeeId() {
			return employeeId;
		}
		public void setEmployeeId(int employeeId) {
			this.employeeId = employeeId;
		}
		public String getEmployeeName() {
			return employeeName;
		}
		public void setEmployeeName(String employeeName) {
			this.employeeName = employeeName;
		}
		public String getDepartment() {
			return department;
		}
		public void setDepartment(String department) {
			this.department = department;
		}
}
----------------
package ch17;

public class EmployeeTest {

	public static void main(String[] args) {
		Employee employeeLee = new Employee();
		employeeLee.setEmployeeName("이순신");
				
		Employee employeeKim = new Employee();
		employeeKim.setEmployeeName("김유신");
				
		System.out.println(employeeLee.getEmployeeName() + "," + employeeLee.getEmployeeId());
		System.out.println(employeeKim.getEmployeeName() + "," + employeeKim.getEmployeeId());
		
		System.out.println(Employee.getSerialNum()); //SerialNum은 private라서 getter로 가져옴
	}
}
---------------------
package ch17;

public class EmployeeTest2 {

	public static void main(String[] args) {
		System.out.println(Employee.getSerialNum());
		Employee.setSerialNum(1003);
		System.out.println(Employee.getSerialNum());
	}

}
================================================================================
package singleton18;

public class Company {
	//싱글톤 패턴: 프로그램에서 인스턴스가 단 한 개만 생성되어야 하는 경우 사용하는 디자인 패턴
	//Timezone같은 시간은 인스턴스를 각각 가질수없다. (동일한시간을 가져야하니까)
	//회사라는 객체는 하나여야만한다.(사원도 또 늘어나니까)
	//이런경우 싱글톤패턴이 필요
	
	//static은 프로그램실행될 때 메모리에 로드된다. 따라서 한번만 만든다.
	private static Company instance = new Company(); //유일한 객체를 한번만 미리만들어놓는다.
	
	//컴파일러가 기본으로 생성하는 외부에서 Company를 마음대로 new할 수 없도록
	private Company() {}
	
	//클래스로 바로 접근할수있게끔 static까지 
	public static Company getInstance() {
		if(instance == null) {
			instance = new Company();
		}
		return instance;
	}
}
---------------
package singleton18;

import java.util.Calendar;

public class CompanyTest {
	public static void main(String[] args) {
		Company company1 = Company.getInstance(); //static이라 클래스로 접근
		Company company2 = Company.getInstance();
		
		System.out.println(company1); //값이 같다.
		System.out.println(company2);
		
		Calendar calendar = Calendar.getInstance(); //이것도 마찬가지
		
	}
}
=======================================================================
package singletontest;

public class CarFactory {
	private static CarFactory instance = new CarFactory();
		
		private CarFactory() {}
		
		public static CarFactory getInstance() {
			if(instance == null) {
				instance = new CarFactory();
			}
			return instance;
		}
		
		//공장안에서 Car를 만들기 때문에
		public Car createCar() { //반환은 Car
			
			Car car = new Car(); 
			return car;
		}
}
---------------
package singletontest;

public class Car {
	private static int serialNum = 10000;
	private int carNum;
	
	public Car() {
		serialNum++;
		carNum = serialNum;
	}

	public int getCarNum() {
		return carNum;
	}

	public void setCarNum(int carNum) {
		this.carNum = carNum;
	}
	
	
}
----------------
package singletontest;

public class CarFactoryTest {

	public static void main(String[] args) {
		CarFactory factory = CarFactory.getInstance();
		Car mySonata = factory.createCar();
		Car yourSonata = factory.createCar();
		
		System.out.println(mySonata.getCarNum());
		System.out.println(yourSonata.getCarNum());
	}

}
=================================================================
package taxi;

public class Student {
	String studentName;
	int grade;
	int money;
	
	public Student(String studentName, int money) {
		this.studentName = studentName;
		this.money = money;
	}
	
	public void takeTaxi(Taxi taxi) {
		taxi.take(10000);  //taxi객체 money증가
		this.money -= 10000;
	}
	
	public void showInfo() {
		System.out.println(studentName + "님의 남은 돈은 " + money + "원 입니다.");
	}
}
----------------
package taxi;

public class Student {
	String studentName;
	int grade;
	int money;
	
	public Student(String studentName, int money) {
		this.studentName = studentName;
		this.money = money;
	}
	
	public void takeTaxi(Taxi taxi) {
		taxi.take(10000);  //taxi객체 money증가
		this.money -= 10000;
	}
	
	public void showInfo() {
		System.out.println(studentName + "님의 남은 돈은 " + money + "원 입니다.");
	}
}
-----------------
package taxi;

public class Taxi {
	String companyName;
	int money;
	
	public Taxi(String companyName) {
		this.companyName = companyName;
	}
	
	public void take(int money) {
		this.money += money;
	}
	
	public void showTaxiInfo() {
		System.out.println(companyName + "택시 수입은 " + money + "원 입니다.");
	}
}
========================================================================================
#)배열
int[] arr1 = new int[10];
int arr2[] = new int[10];
int[] arr3 = new int[] {10,20,30};
int[] arr4 = {10,20,30};

int[] arr5;
arr5 = new int[] {10,20,30};

for(int i = 0, num=1; i<arr.length; i++) {
	arr[i] = num++;
}

//처음부터 끝까지 돌릴때
for(int num : arr) {
	total += num;
}
--------------
//length를 활용하여 오류나는경우 -> length는 5인데 실제데이터는 3개만 들어가있다.
double[] dArr = new double[5];

dArr[0] = 1.1;
dArr[1] = 1.1;
dArr[2] = 1.1;

double mtotal = 1;
for(int i = 0; i<dArr.lengthl i++) {
	mtotal *= dArr[i];
}
--------------
//해결법: 요소의 개수에 대한 변수(count)를 유지
double[] dArr = new double[5];
int count = 0;
dArr[0] = 1.1; count++;
dArr[1] = 1.1; count++;
dArr[2] = 1.1; count++;

double mtotal = 1;
for(int i = 0; i<count; i++) {
	mtotal *= dArr[i];
}
----------------
package ch20;

public class CharArrayTest {
	public static void main(String[] args) {
		char[] alphabets = new char[26];
		char ch = 'A';
		
		for(int i =0; i<alphabets.length; i++) {
			alphabets[i] = ch++;
		}
		for(char alpha : alphabets) {
			System.out.println(alpha + ", " + (int)alpha);
		}
	}
}
==========================================================================================
package ch21;

public class Book {
	private String title;
	private String author;
	
	public Book() {}
	public Book(String title, String author) {
		this.title = title;
		this.author = author;
	}
	
	public String getTitle() {
		return title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public String getAuthor() {
		return author;
	}
	public void setAuthor(String author) {
		this.author = author;
	}
	
	public void showInfo() {
		System.out.println(title + ", " + author);
	}
	
}
------------------
package ch21;

public class BookTest {

	public static void main(String[] args) {
		Book[] library = new Book[5]; //null로 초기화, new한다고 Book개게가 만들어지는게 아니다.
		
		library[0] = new Book("태백산맥1", "조정래"); //객체를 만들어서 넣어야한다. 
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		for(Book book : library) {
			System.out.println(book); //ch21.Book@36aa7bc2  처럼 각기다른 5개 나옴
			book.showInfo();
		}
		
		
	}

}
--------------------
package ch21;

public class ObjectCopyTest {
	public static void main(String[] args) {
		Book[] library = new Book[5]; //null로 초기화, new한다고 Book개게가 만들어지는게 아니다.
		Book[] copyLibrary = new Book[5];
		
		library[0] = new Book("태백산맥1", "조정래"); //객체를 만들어서 넣어야한다. 
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		System.arraycopy(library, 0, copyLibrary, 0, 5); //library 0번쨰부터 복사해서 copyLibrary의 0에서5까지 넣어라(주소가 같은 상태이다)
	
		//기존 book
		for(Book book : library) {
			System.out.println(book);  //주소가같다.
			book.showInfo();
		}
		
		//복사한
		for(Book book : copyLibrary) { //주소가같다.
			System.out.println(book); 
			book.showInfo();
		}
		
		//주소가같아서 library0번째만 바꿧는데 copyLibrary도 같이 바뀐다.
		library[0].setAuthor("박완서");
		library[0].setTitle("나목");
		
	}
	//이런게 얕은복사이다.
}
-------------------
package ch21;

public class ObjectCopyTest2 {
	public static void main(String[] args) {
		Book[] library = new Book[5]; 
		Book[] copyLibrary = new Book[5];
		
		library[0] = new Book("태백산맥1", "조정래");
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		//깊은 복사 방식
		copyLibrary[0] = new Book();
		copyLibrary[1] = new Book();
		copyLibrary[2] = new Book();
		copyLibrary[3] = new Book();
		copyLibrary[4] = new Book();
		
		for(int i =0; i<library.length; i++) {
			copyLibrary[i].setAuthor(library[i].getAuthor());
			copyLibrary[i].setTitle(library[i].getTitle());
		}
		
		
		//주소가같아서 library0번째만 바꿧는데 copyLibrary[0]는 안바뀐다.
		library[0].setAuthor("박완서");
		library[0].setTitle("나목");
		
				//기존 book
				for(Book book : library) {
					System.out.println(book);  //주소가다르다
					book.showInfo();
				}
				
				//복사한
				for(Book book : copyLibrary) { //주소가 다르다
					System.out.println(book); 
					book.showInfo();
				}
	}
}
==============================================================================
package ch22;

public class TwoDimensionTest {
	public static void main(String[] args) {
		int[][] arr = { {1,2,3}, {4,5,6,7}};
		//int[][] arr = new int[3][4];
		
		int i, j;
		
		for(i =0; i<arr.length; i++) {
			for(j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j] + " ");
			}
			System.out.println(", \t" + arr[i].length);
			System.out.println();
		}
	}
}
/* 결과
 * 1 2 3 , 3
 * 
 * 4 5 6 7 , 4
 */
 ==========================================================
 package ch23;

import java.util.ArrayList;

import ch21.Book;

public class ArrayListTest {

	public static void main(String[] args) {
		//기존 배열방식은 길이가 고정이라서 배열의 길이가 커지면 배열을 재할당하고 복사해야했다.
		//ArrayList는 동적
		
		ArrayList<Book> library = new ArrayList<Book>(); //book객체를 가리키는 주소가 array형식으로 만들겠다.
				
				library.add(new Book("태백산맥1", "조정래"));
				library.add(new Book("태백산맥2", "조정래"));
				library.add(new Book("태백산맥3", "조정래"));
				library.add(new Book("태백산맥4", "조정래"));
				library.add(new Book("태백산맥5", "조정래"));
				
				for(int i =0; i<library.size(); i++) {
					library.get(i).showInfo();
				}
			}

}
==============================================================
package ch24;

public class Subject {
	private String name; //과목이름
	private int scorePoint; //점수
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getScorePoint() {
		return scorePoint;
	}
	public void setScorePoint(int scorePoint) {
		this.scorePoint = scorePoint;
	}
}
----------------
package ch24;

import java.util.ArrayList;

public class Student {
	int studentID;
	String studentName;
	ArrayList<Subject> subjectList; //이게 Has-A 방식 (subject를 상속받는게아니라) -> 클래스가 다른 클래스를 포함하는 관계
		
	public Student(int studentID, String studentName){
		this.studentID = studentID;
		this.studentName = studentName;
		
		subjectList = new ArrayList<Subject>();
	}
	
	public void addSubject(String name, int score){
		Subject subject = new Subject();
		
		subject.setName(name);
		subject.setScorePoint(score);
		subjectList.add(subject);
	}
	
	public void showStudentInfo()
	{
		int total = 0;
		
		for(Subject s : subjectList){
			
			total += s.getScorePoint();
			System.out.println("학생 " + studentName + "의 " + s.getName() + " 과목 성적은 " + 
			        s.getScorePoint() + "입니다.");
		}
			
		System.out.println("학생 " + studentName + "의 총점은 " + total + " 입니다.");
	}
}
-----------------
package ch24;

public class StudentTest {
	public static void main(String[] args) {
		Student studentLee = new Student(1001, "Lee");
		
		studentLee.addSubject("국어", 100);
		studentLee.addSubject("수학", 50);
		
		Student studentKim = new Student(1002, "Kim");
		
		studentKim.addSubject("국어", 70);
		studentKim.addSubject("수학", 85);
		studentKim.addSubject("영어", 100);
		
		studentLee.showStudentInfo();
		System.out.println("======================================");
		studentKim.showStudentInfo();
	}
}
==================================================================================
package ch2;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //가격의 1퍼센트를 기존 보너스포인트에 쌓는다.
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}

-----------------
package ch2;

//만약에 VIPCustomer 클래스없이 Customer로만 만들려면 if문돌려서 gold,silver 분류해서 할인율, 또 요구조건이 생기면 계속 if문 쓰면 너무 번거롭다.
//그래서 VIPCustomer로 별도로 뺸다.
public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio; //VIP에만 있는 변수
	
	public VIPCustomer() { //생성자
		//super();
		customerGrade = "VIP";//덮어쓰기    //오류 발생 -> extends를 해야한다(protected라서), private은 extends해도 안됨.
		bonusRatio = 0.05; //덮어쓰기 마찬가지 
		salesRatio = 0.1;
	}
	
	public int getAgentID() { //안씀
		return agentID;
	}
}

---------------------
package ch2;

public class CustomerTest {
	public static void main(String[] args) {
		Customer customerLee = new Customer();
		customerLee.setCustomerName("이순신");
		customerLee.setCustomerID(10010);
		customerLee.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee.showCustomerInfo());
			
			
		VIPCustomer customerKim = new VIPCustomer();  //new VIPCustomer()를 호출하면 Customer()생성자가 먼저 호출된다.
		customerKim.setCustomerName("김유신"); //부모의 메서드
		customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim.showCustomerInfo()); //vip로 생성자만들었으니 잘나온다.
	}
}
이순신님의 등급은 SILVER이며, 보너스 포인트는 1000입니다
김유신님의 등급은 VIP이며, 보너스 포인트는 10000입니다
=============================================================================
package ch3;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public Customer(int customerID, String customerName) {
		this.customerID = customerID;
		this.customerName = customerName;
		
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //가격의 1퍼센트를 기존 보너스포인트에 쌓는다, 현재는 vip는 계산이안됨,vip에서 bonusratio를 재정의해도 calcPrice에서 찾아가지못함.
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}
-------------------
package ch3;

public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio; //VIP에만 있는 변수
	
	public VIPCustomer() {
		//super();
		customerGrade = "VIP"; 
		bonusRatio = 0.05;
		salesRatio = 0.1;
	}
	
	public VIPCustomer(int customerID, String customerName) {
		super(customerID, customerName);
		customerGrade = "VIP"; //덮어쓰기 super()에서 정의된 customerGrade를   
		bonusRatio = 0.05; //마찬가지로 덮어쓰기
		salesRatio = 0.1;
		//아직 보너스포인트, 가격은 정의안함
	}
	
	public int getAgentID() {
		return agentID;
	}
}
----------------------
package ch3;

public class CustomerTest {
	public static void main(String[] args) {
		Customer customerLee = new Customer(); //디폴트 생성자
		customerLee.setCustomerName("이순신");
		customerLee.setCustomerID(10010);
		customerLee.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee.showCustomerInfo());
		
		Customer customerLee2 = new Customer(10030, "홍길동");
		//customerLee.setCustomerName("홍길동");
		//customerLee.setCustomerID(10010);
		customerLee2.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee2.showCustomerInfo());
			
			
		VIPCustomer customerKim = new VIPCustomer();  //new VIPCustomer()를 호출하면 Customer()생성자가 먼저 호출된다.
		customerKim.setCustomerName("김유신"); //부모의 메서드
		customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim.showCustomerInfo());
		
		VIPCustomer customerKim2 = new VIPCustomer(10040, "강지은"); 
		//customerKim.setCustomerName("김유신"); //부모의 메서드
		//customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim2.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim2.showCustomerInfo());
	}
	
	//업캐스팅
	//Customer customerLee = new VIPCustomer(); 
	//customerLee.  으로 쓸수있는걸보면 Customer만 쓸수있다.(오버라이딩된거, 부모의 멤버변수만 쓸수있다)
}
==========================================================================================
package ch4;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	/*public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
		
		System.out.println("Customer() 생성자 호출");
	}*/
	
	public Customer(int customerID, String customerName) {
		this.customerID = customerID;
		this.customerName = customerName;
		
		customerGrade = "SILVER";
		bonusRatio = 0.01;
		//System.out.println("Customer(int, String) 생성자 호출");
	}
	
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}
---------------------
package ch4;

public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio;
	
	/*public VIPCustomer() {
		customerGrade = "VIP";    //오류 발생, why? customer에서 기본생성자를 주석처리 했기때문에
		bonusRatio = 0.05;
		salesRatio = 0.1;
		
		System.out.println("VIPCustomer() 생성자 호출");
	}
	*/
	
	public VIPCustomer(int customerID, String customerName) {
		super(customerID, customerName);
		
		customerGrade = "VIP";
		bonusRatio = 0.05;
		salesRatio = 0.1;
		
		//System.out.println("VIPCustomer(int, String) 생성자 호출");
	}
	
	
	//오버라이딩의 조건은 함수명, 매개변수, 타입까지 다 같아야한다.
	@Override
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price - (int)(price * salesRatio);
	}



	public int getAgentID() {
		return agentID;
	}
	
	@Override
	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade +  
				"이며, 보너스 포인트는 " + bonusPoint + "입니다(vip)";  //여기쓰인 변수들은 부모의 변수를 쓰고있다.
	}
}
---------------------
package ch4;

public class CustomerTest {
	public static void main(String[] args) {
			//함수의 이름이 주소값이다.
		 	//메서드는 명령어의 set이고 프로그램이 로드되면 메서드 영역(코드영역)에 명령어 set이 위치
			//해당 메서드가 호출되면 명령어 set이 있는 주소를 찾아 명령어가 실행됨
			//이때 메서드에서 사용하는 변수들은 스택메모리에 위치한다
			//따라서 다른 인스턴스라도 같은 메서드의 코드는 같으므로 같은 메서드가 호출됨
			//인스턴스가 생성되면 변수는 힙메모리에 따로 생성되지만, 메서드 명령어 set은 처음 한번만 로드됨
		
			//가상메소드란
			//상속에서 상위클래스와 하위 클래스에 같은 이름의 메서드((재정의함수)가 존재할 때 호출되는 메소드는 인스턴스에 따라 결정된다.
			//선언한 클래스형이 아닌 생성된 인스턴스의 메서드를 호출하는것
			//그떄, 인스턴스의 메서드가 호출되는 기술을 가상메서드라고한다.
		
			//같은 객체의 인스턴스를 여러개 생성한다고 해서 메소드도 여러개 생성되지 않는다.
			//즉, new Customer 를 여러번한다고 해서 a라는 메서드가 여러개 생성되지 않는다.(하나를 공유(메모리주소로))
			//예외적으로 사용하는 지역변수는 stack에 생성되서 잡힘
		
			Customer customerLee = new Customer(10010, "이순신");
			customerLee.bonusPoint = 1000;
			System.out.println(customerLee.showCustomerInfo());
			
			VIPCustomer customerKim = new VIPCustomer(10020, "김유신");
			customerKim.bonusPoint = 10000;
			System.out.println(customerKim.showCustomerInfo());
			
			int priceLee = customerLee.calcPrice(10000); //구입가격대입
			int priceKim = customerKim.calcPrice(10000); //구입가격대입
			
			System.out.println(customerLee.showCustomerInfo() + " 지불금액은 " + priceLee + "원 입니다.");
			System.out.println(customerKim.showCustomerInfo() + " 지불금액은 " + priceKim + "원 입니다.");
			
			//업캐스팅
			Customer customerNo = new VIPCustomer(10030, "나몰라"); 
			customerNo.bonusPoint = 10000;
			int priceNo = customerNo.calcPrice(10000); //오버라이딩한 VIPCustomer를 찾아간다.
			System.out.println(customerNo.showCustomerInfo() + " 지불금액은 " + priceNo  + "원 입니다."); //오버라이딩한 show를 찾아간다
			
			//나몰라님의 등급은 VIP이며, 보너스 포인트는 10500입니다 지불금액은 9000원 입니다.
		}
}
=============================================================================================
package ch6;

import java.util.ArrayList;
//정보은닉, 상속과 더불어 다형성은 객체지향 프로그래밍의 가장 큰 특징 중 하나이다.
class Animal{
	
	public void move() {
		System.out.println("동물이 움직입니다.");
	}
	
	public void eating() {
		
	}
}

class Human extends Animal{
	@Override
	public void move() {
		System.out.println("사람이 두발로 걷습니다.");
	}
	
	public void readBooks() {
		System.out.println("사람이 책을 읽습니다.");
	}
}

class Tiger extends Animal{
	@Override
	public void move() {
		System.out.println("호랑이가 네 발로 뜁니다.");
	}
	
	public void hunting() {
		System.out.println("호랑이가 사냥을 합니다.");
	}
}


class Eagle extends Animal{
	@Override
	public void move() {
		System.out.println("독수리가 하늘을 날아갑니다.");
	}
	
	public void flying() {
		System.out.println("독수리가 날개를 쭉 펴고 멀리 날아갑니다");
	}
}

public class AnimalTest {
	public static void main(String[] args) {

		Animal hAnimal = new Human();
		Animal tAnimal = new Tiger();
		Animal eAnimal = new Eagle();
		
		//출력방법 1
		AnimalTest test = new AnimalTest(); //밑에 moveAnimal함수쓸려고 갹체 생성
		test.moveAnimal(hAnimal);
		test.moveAnimal(tAnimal);
		test.moveAnimal(eAnimal);
		
		
		//출력방법2
		ArrayList<Animal> animalList = new ArrayList<Animal>();
		animalList.add(hAnimal);
		animalList.add(tAnimal);
		animalList.add(eAnimal);
		
		for(Animal animal : animalList) {
			animal.move();
		}
	}	
	//main밖에서 함수정의해야한다.
	public void moveAnimal(Animal animal) {
		animal.move(); //이런게 다형성이다. 같은 move라는 메서드이지만 출력결과는 다르다.
		
	}
	
}
===========================================================================================
package ch6;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer()
	{
		initCustomer();
	}

	public Customer(int customerID, String customerName){
		this.customerID = customerID;
		this.customerName = customerName;
		
		initCustomer();
	}
	
	private void initCustomer() //회원등급과 보너스포인트비율을 초기화
	{
		customerGrade = "SILVER";
		bonusRatio = 0.01;	
	}
	
	public int calcPrice(int price){
		bonusPoint += price * bonusRatio;
		return price;
	}
	
	public String showCustomerInfo(){
		return customerName + " 님의 등급은 " + customerGrade + "이며, 보너스 포인트는 " + bonusPoint + "입니다.";  
	}
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}
}
---------------
package ch6;

public class GoldCustomer extends Customer{

	double saleRatio;
		
		public GoldCustomer(int customerID, String customerName){
			super(customerID, customerName);
		
			customerGrade = "GOLD"; //부모의 멤버변수니까 showInfo는 오버라이딩 안했음. 
			bonusRatio = 0.02;   	//부모의 멤버변수
			saleRatio = 0.1;		//내꺼
		
		}
		@Override
		public int calcPrice(int price){
			bonusPoint += price * bonusRatio;
			return price - (int)(price * saleRatio);
		}
}
-------------------
package ch6;

public class VIPCustomer extends Customer{
	private int agentID;
	double saleRatio;
	
	public VIPCustomer(int customerID, String customerName, int agentID){
		super(customerID, customerName);
	
		customerGrade = "VIP";
		bonusRatio = 0.05;
		saleRatio = 0.1;
		this.agentID = agentID;
	}
	@Override
	public int calcPrice(int price){
		bonusPoint += price * bonusRatio;
		return price - (int)(price * saleRatio);
	}
	@Override
	public String showCustomerInfo(){
		return super.showCustomerInfo() + " 담당 상담원 번호는 " + agentID + "입니다";  //super.showInfo로 부모메소드부른후 뒤에 문자열 추가
	}

	public int getAgentID(){
		return agentID;
	}
}
-----------------
package ch6;

import java.util.ArrayList;

public class CustomerTest {
	public static void main(String[] args) {
			
			ArrayList<Customer> customerList = new ArrayList<Customer>();
			
			Customer customerLee = new Customer(10010, "이순신");
			Customer customerShin = new Customer(10020, "신사임당");
			Customer customerHong = new GoldCustomer(10030, "홍길동");
			Customer customerYul = new GoldCustomer(10040, "이율곡");
			Customer customerKim = new VIPCustomer(10050, "김유신", 12345);
			
			customerList.add(customerLee);
			customerList.add(customerShin);
			customerList.add(customerHong);
			customerList.add(customerYul);
			customerList.add(customerKim);
			
			System.out.println("====== 고객 정보 출력 =======");
			
			for( Customer customer : customerList){
				System.out.println(customer.showCustomerInfo());
			}
			
			System.out.println("====== 할인율과 보너스 포인트 계산 =======");
			
			int price = 10000;
			for( Customer customer : customerList){
				int cost = customer.calcPrice(price); //재정의된 calcPrice를 찾는다.
				System.out.println(customer.getCustomerName() +" 님이 " +  + cost + "원 지불하셨습니다."); //Customer로 업캐스팅 했기때문에 Customer의 bonusPoint를 가져올수있다.
				System.out.println(customer.getCustomerName() +" 님의 현재 보너스 포인트는 " + customer.bonusPoint + "점입니다."); //new로 생성할 때는 vip,customer,gold로 구분했기때문에 알아서 bonusPoint 찾아간다.
			}
		}
}
===================================================================
package ch8;

import java.util.ArrayList;

//다운캐스팅은 명시적으로 해야한다.
//Customer vc = new VIPCustomer(); 묵시적
//VIPCustomer vCustomer = (VIPCustomer)vc; 명시적(다운캐스팅)

	class Animal{
		
		public void move() {
			System.out.println("동물이 움직입니다.");
		}
		
		public void eating() {
			
		}
	}

	class Human extends Animal{
		public void move() {
			System.out.println("사람이 두발로 걷습니다.");
		}
		
		public void readBooks() {
			System.out.println("사람이 책을 읽습니다.");
		}
	}

	class Tiger extends Animal{
		
		public void move() {
			System.out.println("호랑이가 네 발로 뜁니다.");
		}
		
		public void hunting() {
			System.out.println("호랑이가 사냥을 합니다.");
		}
	}


	class Eagle extends Animal{
		public void move() {
			System.out.println("독수리가 하늘을 날아갑니다.");
		}
		
		public void flying() {
			System.out.println("독수리가 날개를 쭉 펴고 멀리 날아갑니다");
		}
	}
public class AnimalTest {
	public static void main(String[] args) {
		Animal hAnimal = new Human();  
		Animal tAnimal = new Tiger();
		Animal eAnimal = new Eagle();
		
		/*AnimalTest test = new AnimalTest();
		test.moveAnimal(hAnimal);  //함수에전달(다형성)
		test.moveAnimal(tAnimal);
		test.moveAnimal(eAnimal);
		*/
		
		//다운캐스팅
		ArrayList<Animal> animalList = new ArrayList<Animal>();
		animalList.add(hAnimal);
		animalList.add(tAnimal);
		animalList.add(eAnimal);
		
		AnimalTest test = new AnimalTest();
		test.testDownCasting(animalList);
		
		
		
	/*	for(Animal animal : animalList) {
			animal.move();
		}
		*/	
	}
	
	//다시 원래 자기타입으로 되돌리고 싶으면 다운캐스팅 쓰고 그게아니면 그냥 다형성을 쓰는게 좋다 (moveAnimal 함수처럼)
	public void testDownCasting(ArrayList<Animal> list) {
			
			for(int i =0; i<list.size(); i++) {
				Animal animal = list.get(i);
			
				if ( animal instanceof Human) { //animal이 Human타입이냐
					Human human = (Human)animal;
					human.readBooks();
				}
				else if( animal instanceof Tiger) {
					Tiger tiger = (Tiger)animal;
					tiger.hunting();
				}
				else if( animal instanceof Eagle) {
					Eagle eagle = (Eagle)animal;
					eagle.flying();
				}
				else {
					System.out.println("error");
				}
			
			}
		}
	
	
	
	/*
	 * public void moveAnimal(Animal animal) { animal.move();
	 * 
	 * }
	 */
	}
======================================================================================================
#)추상클래스
추상의 반댓말은 구체적
추상클래스란 우리가 클래스를 구성할 떄 메서드를 구현하는데 추상클래스는 메서드의 선언만있다.
추상클래스는 new할수없음.(인스턴스화 할수없다)
abstract예약어사용

int add(int x, int y);   -> 추상메서드(함수내용은 정의하지않음), 메서드선언만했다.
위와같은 추상메서드를 포함한것이 추상클래스이다.

=========================================================================================================
package ch9;

//부모
public abstract class  Computer { //추상클래스는 상속을위한 클래스다.
	
	//메서드선언만했다.(추상메서드)
	//상속받을 애들을 구체적으로 어떻게 구현할지 모르기때문에 display,typing은 자식이 알아서해라
	//컴퓨터는 공통으로쓸 turnOn, turnOff만 구현하고 display(), typing()은 구현하지않았다. 하위클래스로 책임전가
	abstract void display();
	abstract void typing();
	
	//일반메서드
	public void turnOn() {
		System.out.println("전원을 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("전원을 끕니다.");
	}
}
---------------
package ch9;

public class DeskTop extends Computer{

	@Override
	void display() {
		System.out.println("DeskTop display");
	}

	@Override
	void typing() {
		System.out.println("DeskTop typing");
	}

	@Override
	public void turnOff() { //재정의도 가능
		System.out.println("Desktop turnoff");
	}
}
------------------
package ch9;
//추상클래스를 상속받으면 메소드를 다 구현해야된다. 안하면 abstract를 붙여야한다.
public abstract class NoteBook extends Computer{ //추상클래스 (구현안한 메서드가 display()가있는데 이거를 구현안하면 abstract를 붙힌다)
	@Override
	public void typing() {
		System.out.println("NoteBook typing");		
	}
}
-------------------
package ch9;

public class MyNoteBook extends NoteBook{ //추상클래스인 NoteBook을 상속받음(부모가 구현안한 display()를 구현)

	@Override
	void display() {
		System.out.println("MyNoteBook display");		
	}
}
------------------
package ch9;

public class ComputerTest {

	public static void main(String[] args) {
		Computer computer = new DeskTop(); //Computer는 추상클래스(인스턴스화할수없다new), DeskTop은 일반클래스
		computer.display(); //오버라이딩된 인스턴스의 메서드를 찾아간다(desktop) -> 가상메서드
		computer.turnOff();
		
		NoteBook myNote = new MyNoteBook();
	}
}
==================================================================================
jdk(라이브러리) -> 안에도 라이브러리있음. -> 내가 필요한 경우 가져다쓰지만 내가 구성을한다.

안드로이드(프레임워크) -> 프레임워크를 도입한다는 애기는 이미 흐름이 정의되있다. 내가 어떤클래스를 넣으면 어떻게연동되고, 내가 값을 넣으면 어떻게 답이오고 영향을 주는지 등등
화면이 어떻게돌아가고 클로즈가되고 destroy가 된다 등은 안드로이드 내부에 이미정의되있지만(프레임워크) 실제로 화면에서 어떤위젯이 올라가고 어떤액션을 할지는 우리가 짜는것이다.
화면에 여러가지생성과정, 소멸과정 등은 정해져있지만 거기에 들어가는 기능들은 우리가해야한다.

프레임워크에서 많이쓰는 패턴중에하나가 템플릿메서드패턴이다.
- 추상 메서드나 구현된 메서드를 활용하여 코드의 흐름(시나리오)를 정의하는 메서드
- final로 선언하여 하위클래스에서 재정의 할 수 없게한다.(흐름은 변하면안되기때문에)
- 하위클래스에서 다르게 구현되어야 하는 부분은 추상메서드로 선언하여 하위 클래스에서 구현하도록 함

==================================================================================
package ch10;

public abstract class Car {
	//선언만했다.
	public abstract void drive(); //AI, 직접운전은 drive메서드는 자식이 구현해라
	public abstract void stop(); //마찬가지
	
	//시동은 공통이니까 구현했음
	public void startCar() {
		System.out.println("시동을 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("시동을 끕니다.");
	}
			
	public void washCar() {} //구현되긴했다.
	
	final public void run() {
		//시동을걸고 운전하다가 일이생기면 멈추고 시동꺼라 -> 시나리오(이거는 변하면안된다) -> run메서드를 재정의하면안되니까 final로 선언
		startCar(); //일반
		drive(); //추상
		stop(); //추상 
		turnOff(); //일반
		washCar(); //재정의할수있게끔(ai에서만 써도됨), 일반자동차는 재정의안했음
	}
}
------------------
package ch10;

public class AICar extends Car{
	
	//Car에서 상속받은 추상메서드 drive, stop 구현
	@Override
	public void drive() {
		System.out.println("자율 주행합니다.");
		System.out.println("자동차가 스스로 방향을 바꿉니다.");
	}

	@Override
	public void stop() {
		System.out.println("스스로 멈춥니다.");		
	}

	@Override
	public void washCar() {
		System.out.println("자동 세차를 합니다.");
	}
	
	
}
-----------------------
package ch10;

public class ManualCar extends Car{

	@Override
	public void drive() {
		System.out.println("사람이 운전합니다.");
		System.out.println("사람이 핸들을 조작합니다.");		
	}

	@Override
	public void stop() {
		System.out.println("브레이크를 밟아서 정지합니다.");		
	}

}
------------------------
package ch10;

public class CarTest {

	public static void main(String[] args) {
		Car aiCar = new AICar();
		aiCar.run();
		System.out.println("=================");
		Car manualCar = new ManualCar();
		manualCar.run();
	}
}
========================================================================
package ch10;

//이렇게 상수는 따로 빼서 쓴다.
public class Define {

	public static final int MIN = 1;
	public static final int MAX = 999999;
	public static final double PI = 3.14;
	public static final String GREETING = "Good Morning!";
	public static final int MATH_CODE = 1001;
	public static final int CHEMISTRY_CODE = 1002;
	
}
-------------------
package ch10;

public class UsingDefine {

	public static void main(String[] args) {

		System.out.println(Define.GREETING);
		System.out.println(Define.MIN);
		System.out.println(Define.MAX);
		System.out.println(Define.MATH_CODE);
		System.out.println(Define.CHEMISTRY_CODE);
		System.out.println("원주률은" + Define.PI + "입니다.");
	}

}
===========================================================================
#)인터페이스
인터페이스에서 메소드를 선언하면 모든 메소드가 자동으로 public abstract로 선언이된다.
모든 변수는 상수로 선언된다. public static final

interface 인터페이스 이름 {
	(public static final)float pi = 3.14F;
	public void makeSomthing(); //알아서 public abstract 으로 바뀜
}

============================================================================
#)인터페이스가 하는일
클래스나 프로그램이 제공하는 기능을 명시적으로 선언
클라이언트는 인터페이스에 선언된 메서드 명세만 보고 이를 구현한 클래스를 사용할 수 있음
클라이언트는 서버가 어떻게 구현되있는 모른다 -> 그래서 서버와 클라이언트 사이에 선언된 인터페이스 명세를 보고 클라이언트가 쓴다.(서버의 메서드가 어떻게 구현되있는지는 궁금하지않음)
어떤 객체가 하나의 인터페이스 타입이라는 것은 그 인터페이스가 제공하는 모든 메서드를 구현했다는 의미이다.
단, 클라이언트가 쓸때는 모든 메서드를 쓸필요는 없다. 서버만 모든 메서드를 구현
인터페이스를 구현한 다양한 객체를 사용함 -> 다형성

인터페이스를 쓰고있는 여러 클래스가 있어도 동일한 방식으로 쓰인다.

ex) jdbc 인터페이스 (connection도 인터페이스이다. -> 서드파티에서 메서드 구현했고 클라이언트는 골라쓰기만하면된다)

================================================================================
package ch11;

public interface Calc {

	double PI = 3.14; //static으로 바뀜
	int ERROR = -99999999;
	
	int add(int num1, int num2); //인터페이스는 abstract와 달리 상속이아니라 구현이라는 것이다.(Calculator에서 구현해야됨)
	int substract(int num1, int num2);
	int times(int num1, int num2);
	int divide(int num1, int num2);
	
}
-----------------
package ch11;

public abstract class Calculator implements Calc{ //abstract를 붙여야됨. implements를 붙이는순간 4개의 메서드를 구현해야되는데 2개만 구현했음
	//또, implement메서드는 자동으로 abstract가 붙기때문에 4개를 다 구현하지 않으면 abstract로 클래스를 만들어야한다.

	@Override
	public int add(int num1, int num2) {
		return num1 + num2;
	}
	
	@Override
	public int substract(int num1, int num2) {
		return num1 - num2;
	}
}

-------------------
package ch11;

public class CompleteCalc extends Calculator{
	
	@Override
	public int times(int num1, int num2) {
		return num1 * num2;
	}

	@Override
	public int divide(int num1, int num2) {
		if( num2 == 0 )
			return ERROR;
		else 
			return num1 / num2;
	}
	
	public void showInfo() {
		System.out.println("모두 구현하였습니다.");
	}
}
-----------------
package ch11;

import java.util.Scanner;

public class CalculatorTest {

	public static void main(String[] args) {
		Calc calc = new CompleteCalc(); //타입이 Calc이다.(인터페이스) 형변환, 인터페이스를 구현한 클래스는 인터페이스형으로 선언한 변수로 형 변환 할 수 있다.
		//형변환이된경우 인터페이스에 선언된 메서드만을 사용가능하다.
		int num1 = 10;
		int num2 = 2;
		
		System.out.println(num1 + "+" + num2 + "=" + calc.add(num1, num2));
		System.out.println(num1 + "-" + num2 + "=" +calc.substract(num1, num2));
		System.out.println(num1 + "*" + num2 + "=" +calc.times(num1, num2));
		System.out.println(num1 + "/" + num2 + "=" +calc.divide(num1, num2));
		
	}
}
==============================================================================
















