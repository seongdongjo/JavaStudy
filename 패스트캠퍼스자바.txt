A -> 65 인코딩
65-> A 디코딩

각 나라별 문자세트가 다르니 호환이 안된다 그래서, 하나의 코드표로 통일하자 -> 유니코드(2byte표현)
-> 16비트 (2의 16승)

'a' -> 2byte 문자 -> 16bit -> 표현값개수 65536개 -> 문자라서 첫번째자리를 부호에 사용하지않기때문에 65536개이다.
short도 2byte이지만 부호가 표현되야하니 -32768~32767
"a" -> 문자열

//char는 자바에서 유니코드(2byte 문자체계)를 사용하므로 2byte이다
//c언어는 아스키코드를 사용하기 때문에 1byte크기를 갖는다.

유니코드란?

세계 각 국의 언어를 통일된 방법으로 표현할 수 있게 제안된 국제적인 코드 규약이다.
컴퓨터가 미국에서 개발되어져 영어를 바탕으로 정의되어 있다.
영어는 26자의 알파벳과 몇 가지 특수 문자를 표현하기에 1 byte로 충분했기 때문에
문자가 1 byte로 표현되고 있지만,
동양 3국의 한글, 한자 또는 일어 등과 같은 문자는 1 byte로는 표현이 불가능하기에
2 byte로 문자를 표현하는 유니코드가 만들어 졌다.

=======================================================================
//강제로
char ch1='A';
System.out.println((int)ch1);

int ch3 = 67;
System.out.println((char)ch3);


//변하지 않는 값은 + 공통적으로 쓰이는 -> final int max_num = 100;
//max_num = 20; 은 불가능

========================================================================
list, set 은 iterator사용가능
map은 사용할려면 entryset 같은걸로 바꾸고 해야됌. -> foreach쓰기위해서

#)map 사용
public static void main(String[] args) {
	HashMap<String,Integer> map = new HashMap<String,Integer>();
	
	//키는 String, value는 Integer
	map.put("Soraka",450);
	map.put("Garen",4800);
	map.put("Garen",450); //중복된 key는 선언은 가능하지만 젤 마지막 선언된것이 덮어씌운다
	
	System.out.println("Map value: " + map.get("Garen"));  //450
	System.out.println("Map value: " + map.size());  //2
	
	map.replace("Garen", 160); //Key값의 내용을 변경
	
	System.out.println("Key Exist: " + map.containsKey("Garen")); //key가 존재하는지 확인
	System.out.println("Value Exist: " + map.containsValue(160)); //value가 존재하는지 확인
	
	System.out.println("Map Empty: " + map.isEmpty()); //map의 크기가 0인지 확인
	
	map.remove("Garen");
}

=========================================================================
#)HashMap은 Map인터페이스에 속해있는 컬렉션이다.따라서, map인터페이스의 기본 기능들을 전부구현할 수 있다
#)map의 keyset메서드 사용
public class Sample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("people", "사람");
        map.put("baseball", "야구");
        System.out.println(map.keySet());  // 키출력 --> [baseball, people] 출력
    }
}
==========================================================================
for(String key : map.keySet()) {
	System.out.println("Value: " + map.get(key));
}

==============================================================================
#)jackson이란
Java Object를 JSON으로 변환하거나 JSON을 Java Object로 변환하는데 사용할 수 있는 Java 라이브러리입니다.

==============================================================================
package ch03;

public class FunctionTest {
	public static int addNum(int num1, int num2) {
		int result;
		result = num1 + num2;
		return result;
	}
	
	public static void sayHello(String greeting) {
		System.out.println(greeting);
	}
	public static int calcSum() {
		int sum = 0;
		int i;
		for(i = 0; i<=100; i++) {
			sum += i; 
		}
		return sum;
	}
	
	public static void main(String[] args) {
		int n1=10;
		int n2=20;
		
		int total = addNum(n1,n2);
		System.out.println(total);
		
		sayHello("안녕하세요");
		
		total = calcSum();
		System.out.println(total);
	}
}

//스택: 함수가 호출될 때 지역변수들이 사용하는 메모리
//스택: 함수의 수행이 끝나면 자동으로 반환되는 메모리

=====================================================================================
package ch04;

public class Student {
	public int studentID; //public이다.
	public String studentName;
	public String address;
	
	public void showStudentInfo() {
		System.out.println(studentID + "학번의 이름은" + studentName + "이고 주소는" + address + "입니다.");
	}
	
	public String getStudentName() {
		return studentName;
	}
	
	public void setStudentName(String name) {
		studentName = name;
	}
}
----------------
package ch04;

public class MainStudent {
	public static void main(String[] args) {
		Student studentLee = new Student(); //인스턴스라고한다, 같은 패키지내에서는 import 안한다
		Student studentKim = new Student();
		
		//인스턴스들은 동적메모리(Heap)에 할당된다, 참조변수는 스택에 올라간다.
		//c나 c++에서는 사용한 동적메모리를 프로그래머가 해제시켜야한다.(free, delete)
		//자바에서는 가비지컬렉터가 주기적으로 사용하지 않는 메모리를 수거한다.
		//하나의 클래스로부터 여러개의 인스턴스가 생성되고 각각 다른 메모리 주소를 가지게 된다.
		
		studentLee.studentID = 12345;
		studentLee.setStudentName("Lee");
		studentLee.address = "서울 강남구";
		
		studentLee.showStudentInfo();
		
		System.out.println(studentKim); //ch04.Student@36aa7bc2 -> 객체의 위치를 가리키는(Heap에 있는 인스턴스를 가리킨다) 주소값이다. (물리적 메모리주소가 아니라 JVM이 준 가상 주소)
		//그래서 studentKim. (점.)을 찍음으로써 접근
		System.out.println(studentLee);
		
		//인스턴스 : new 키워드를 사용하여 클래스를 메모리에 생성한 상태(힙)
		//참조변수: 메모리에 생성된 인스턴스를 가리키는 변수(스택)
		//참조값: 생성된 인스턴스의 메모리 주소값
	}
}
=========================================================================================
package ch06;

public class Student { //멤버변수는 알아서 초기화된다. null, 0
	public int studentNumber;
	public String studentName;
	public int grade;
	
	public Student() {
		System.out.println("생성자");
	}
	
	public Student(int studentNumber, String studentName, int grade) {
		this.studentNumber = studentNumber; //변수이름이 다르면 this붙일필요가없다
		this.studentName = studentName;
		this.grade = grade;
	}
	
	public String showStudentInfo() {
		int i; //i는 초기화되지 않는다.(지역변수라서)
		return studentName + "학생의 학번은" + studentNumber + "이고, " + grade + "학년 입니다.";
	}
}
----------------
package ch06;

public class StudentMain {
	public static void main(String[] args) {
		Student studentLee = new Student();
		Student studentKim = new Student(123456, "Kim", 3);
		
		System.out.println(studentKim.showStudentInfo()); 
		
		System.out.println(studentLee.showStudentInfo()); //null,0~
	}
}
============================================================================================
package ch09;

public class Student {
	int studentId;
	String studentName;
	
	Subject korea; //class내에서 쓸수있도록(전역변수? 느낌)
	Subject math;
	
	Student(int studentId, String studentName) { //학생을 만들 때 subject를 생성
		this.studentId = studentId;
		this.studentName = studentName;
		
		korea = new Subject();
		math = new Subject();
	}
	
	public void setKoreaSubject(String name, int score) {
		korea.subjectName = name;
		korea.score = score;
	}
	
	public void setMathSubject(String name, int score) {
		math.subjectName = name;
		math.score = score;
	}
	
	public void showScoreInfo() {
		int total = korea.score + math.score;
		System.out.println(studentName + "학생의 총점은" + total + "점 입니다.");
	}
}
-------------------
package ch09;

public class Subject {
	String subjectName;
	int score;
	int subjectId;
}
-------------------
package ch09;

public class SubjectMain {
	public static void main(String[] args) {
		Student studentLee = new Student(100, "Lee");
		studentLee.setKoreaSubject("국어", 100);
		studentLee.setMathSubject("수학", 99);
		
		Student studentKim = new Student(200, "Kim");
		studentKim.setKoreaSubject("국어", 80);
		studentKim.setMathSubject("수학", 100);
		
		studentLee.showScoreInfo();
		studentKim.showScoreInfo();
	}
}
=======================================================================================
package ch10;

public class BirthDay {
	private int day; //같은 클래스내에서만 접근 -> private
	private int month;
	private int year;
	
	private boolean isVaild; //기본값이 false
	
	public int getDay() {
		return day;
	}
	public void setDay(int day) {
		this.day = day;
	}
	public int getMonth() {
		return month;
	}
	public void setMonth(int month) {
		if(month < 1 || month > 13) {
			isVaild = false;
		}
		else {
			isVaild = true;
			this.month = month;
		}
	}
	public int getYear() {
		return year;
	}
	public void setYear(int year) {
		this.year = year;
	}
	
	public void showDate() {
		if(isVaild) { //true이면
			System.out.println(year + "년 " + month + "월 " + day + "일 입니다.");
		}
		else {
			System.out.println("유효하지 않은 날짜입니다.");
		}
	}
}
----------------
package ch10;

public class BirthDayMain {
	public static void main(String[] args) {
		BirthDay date = new BirthDay();
		date.setYear(2019);
		
		//private를 쓰는이유는 
		//date.month = 100 이렇게 범위를 벗어난값을 바로 대입가능하기 때문이다.
		//그래서 setter를 통해 제약을 걸었다.
		
		//date.setMonth(13);  month가 1~12사이가 아닌것은 처리 xx, BirthDay클래스에서 처리했다, 유효하지 않은 날짜라고 뜬다.
		date.setDay(30);
	}
}
=========================================================================
package ch11;

public class MakeReport {

	StringBuffer buffer = new StringBuffer(); //append메서드로 String을 연결한다
	
	private String line = "===========================================\n";
	private String title = "  이름\t   주소 \t\t  전화번호  \n";
	private void makeHeader()
	{
		buffer.append(line);
		buffer.append(title);
		buffer.append(line);
	}
	
	private void generateBody()
	{
		buffer.append("James \t");
		buffer.append("Seoul Korea \t");
		buffer.append("010-2222-3333\n");
		
		buffer.append("Tomas \t");
		buffer.append("NewYork US \t");
		buffer.append("010-7777-0987\n");
	}
	
	private void makeFooter()
	{
		
		buffer.append(line);
	}
	
	public String getReport()
	{
		makeHeader();
		generateBody();
		makeFooter();
		return buffer.toString();
	}
}
-----------------
package ch11;

public class MainReport {

	public static void main(String[] args) {

		MakeReport report = new MakeReport();
		String builder = report.getReport();
		
		System.out.println(builder);
	}

}
====================================================================
package ch12;

public class Person {
	String name;
	int age;
	
	public Person() {
		//age = 10;
		//name = "test"
		//this위에 쓰면 안된다. 객체가 만들어지기 전이기 때문에
		this("no name", 1);
	}
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	public void showPerson() {
		System.out.println(name + ", " + age);
	}
	public Person getPerson() { 
		return this; //객체자신을 반환
	}
	
	public static void main(String[] args) {
		Person person = new Person();
		person.showPerson(); //no name, 1
		
		System.out.println(person);  //ch12.Person@1175e2db
		
		Person person2 = person.getPerson(); //person2도 person을 바라본다.
		System.out.println(person2); //ch12.Person@1175e2db 같다.  this == main의 Person 이 같은 Heap공간의 Person을 가리킨다
		
	}
}
===============================================================================
package ch14;

public class Student {
	String studentName;
	int money;
	
	public Student(String studentName, int money) {
		this.studentName = studentName;
		this.money = money;
	}
	
	public void takeBus(Bus bus) {
		bus.take(1000); //버스를타면 1000원을 지불
		this.money -= 1000;
	}
	
	public void takeSubway(Subway subway) {
		subway.take(1200);
		this.money -= 1200;
	}
	
	public void showInfo() {
		System.out.println(studentName + "님의 남은 돈은 " + money + "원 입니다.");
	}
	
}
--------------
package ch14;

public class Subway {
	int lineNumber;
	int passengerCount; //승객수
	int money;
	
	public Subway(int busNumber) {
		this.lineNumber = busNumber;
	}
	
	public void take(int money) {
		this.money = money;
		passengerCount++;
	}
	
	public void showsubwayInfo() {
		System.out.println(lineNumber + "번의 승객 수는 " + passengerCount + "명 이고, 수입은 " + money + "원 입니다.");
	}
}
---------------
package ch14;

public class TakeTransTest {

	public static void main(String[] args) {
		Student studentJ = new Student("James", 5000);
		Student studentT = new Student("Tomas", 10000);
		
		Bus bus100 = new Bus(100);  //버스넘버
		Bus bus500 = new Bus(500);
		
		studentJ.takeBus(bus100); //studentJ가 bus100을 탔다.
		
		Subway greenSubway = new Subway(2); //lineNumber
		studentT.takeSubway(greenSubway);
		
		studentJ.showInfo();
		studentT.showInfo();
		
		bus100.showBusInfo();
		greenSubway.showsubwayInfo();
	}

	/*
	 * James님의 남은 돈은 4000원 입니다. 
	 * Tomas님의 남은 돈은 8800원 입니다. 
	 * 100번의 승객 수는 1명 이고, 수입은
	 * 1000원 입니다. 2번의 승객 수는 1명 이고, 수입은 1200원 입니다.
	 */
}
========================================================================
package ch16;

public class Employee {
	//static변수는 프로그램이 실행되면서 메모리에 로드될때 같이 적재된다. (객체 생성 전)
	public static int serialNum = 1000; //public이라서 외부에서 클래스.serialNum 접근가능하다
	
		private int employeeId;
		private String employeeName;
		private String department;
			
		public Employee() //클래스만들때마다 serialNum은 증가
		{
			serialNum++;
			employeeId = serialNum;
		}
		
		public int getEmployeeId() {
			return employeeId;
		}
		public void setEmployeeId(int employeeId) {
			this.employeeId = employeeId;
		}
		public String getEmployeeName() {
			return employeeName;
		}
		public void setEmployeeName(String employeeName) {
			this.employeeName = employeeName;
		}
		public String getDepartment() {
			return department;
		}
		public void setDepartment(String department) {
			this.department = department;
		}
}
--------------
package ch16;

public class EmployeeTest {

	public static void main(String[] args) {
		Employee employeeLee = new Employee();
		employeeLee.setEmployeeName("이순신");
				
		Employee employeeKim = new Employee();
		employeeKim.setEmployeeName("김유신");
				
		System.out.println(employeeLee.getEmployeeName() + "," + employeeLee.getEmployeeId());
		System.out.println(employeeKim.getEmployeeName() + "," + employeeKim.getEmployeeId());
		
		System.out.println(Employee.serialNum); //static변수는 클래스로 바로 접근 가능
	}
}
===================================================================
package ch17;

public class Employee {
	private static int serialNum = 1000; //private로 고쳤다 -> getter로 가져와야한다
		
		private int employeeId;
		private String employeeName;
		private String department;
			
		public Employee()
		{
			serialNum++;
			employeeId = serialNum;
		}
		
		public static int getSerialNum() {
			return serialNum;
		}
	
		public static void setSerialNum(int serialNum) { //serialNum을 직접 변경할 때
			int i = 0;
			
		//	employeeName = "Lee";  //오류발생 static이라서
			Employee.serialNum = serialNum; //공통으로 쓰는 static값 변경
		}
	
		public int getEmployeeId() {
			return employeeId;
		}
		public void setEmployeeId(int employeeId) {
			this.employeeId = employeeId;
		}
		public String getEmployeeName() {
			return employeeName;
		}
		public void setEmployeeName(String employeeName) {
			this.employeeName = employeeName;
		}
		public String getDepartment() {
			return department;
		}
		public void setDepartment(String department) {
			this.department = department;
		}
}
----------------
package ch17;

public class EmployeeTest {

	public static void main(String[] args) {
		Employee employeeLee = new Employee();
		employeeLee.setEmployeeName("이순신");
				
		Employee employeeKim = new Employee();
		employeeKim.setEmployeeName("김유신");
				
		System.out.println(employeeLee.getEmployeeName() + "," + employeeLee.getEmployeeId());
		System.out.println(employeeKim.getEmployeeName() + "," + employeeKim.getEmployeeId());
		
		System.out.println(Employee.getSerialNum()); //SerialNum은 private라서 getter로 가져옴
	}
}
---------------------
package ch17;

public class EmployeeTest2 {

	public static void main(String[] args) {
		System.out.println(Employee.getSerialNum());
		Employee.setSerialNum(1003);
		System.out.println(Employee.getSerialNum());
	}

}
================================================================================
package singleton18;

public class Company {
	//싱글톤 패턴: 프로그램에서 인스턴스가 단 한 개만 생성되어야 하는 경우 사용하는 디자인 패턴
	//Timezone같은 시간은 인스턴스를 각각 가질수없다. (동일한시간을 가져야하니까)
	//회사라는 객체는 하나여야만한다.(사원도 또 늘어나니까)
	//이런경우 싱글톤패턴이 필요
	
	//static은 프로그램실행될 때 메모리에 로드된다. 따라서 한번만 만든다.
	private static Company instance = new Company(); //유일한 객체를 한번만 미리만들어놓는다.
	
	//컴파일러가 기본으로 생성하는 외부에서 Company를 마음대로 new할 수 없도록
	private Company() {}
	
	//클래스로 바로 접근할수있게끔 static까지 
	public static Company getInstance() {
		if(instance == null) {
			instance = new Company();
		}
		return instance;
	}
}
---------------
package singleton18;

import java.util.Calendar;

public class CompanyTest {
	public static void main(String[] args) {
		Company company1 = Company.getInstance(); //static이라 클래스로 접근
		Company company2 = Company.getInstance();
		
		System.out.println(company1); //값이 같다.
		System.out.println(company2);
		
		Calendar calendar = Calendar.getInstance(); //이것도 마찬가지
		
	}
}
=======================================================================
package singletontest;

public class CarFactory {
	private static CarFactory instance = new CarFactory();
		
		private CarFactory() {}
		
		public static CarFactory getInstance() {
			if(instance == null) {
				instance = new CarFactory();
			}
			return instance;
		}
		
		//공장안에서 Car를 만들기 때문에
		public Car createCar() { //반환은 Car
			
			Car car = new Car(); 
			return car;
		}
}
---------------
package singletontest;

public class Car {
	private static int serialNum = 10000;
	private int carNum;
	
	public Car() {
		serialNum++;
		carNum = serialNum;
	}

	public int getCarNum() {
		return carNum;
	}

	public void setCarNum(int carNum) {
		this.carNum = carNum;
	}
	
	
}
----------------
package singletontest;

public class CarFactoryTest {

	public static void main(String[] args) {
		CarFactory factory = CarFactory.getInstance();
		Car mySonata = factory.createCar();
		Car yourSonata = factory.createCar();
		
		System.out.println(mySonata.getCarNum());
		System.out.println(yourSonata.getCarNum());
	}

}
=================================================================
package taxi;

public class Student {
	String studentName;
	int grade;
	int money;
	
	public Student(String studentName, int money) {
		this.studentName = studentName;
		this.money = money;
	}
	
	public void takeTaxi(Taxi taxi) {
		taxi.take(10000);  //taxi객체 money증가
		this.money -= 10000;
	}
	
	public void showInfo() {
		System.out.println(studentName + "님의 남은 돈은 " + money + "원 입니다.");
	}
}
-----------------
package taxi;

public class Taxi {
	String companyName;
	int money;
	
	public Taxi(String companyName) {
		this.companyName = companyName;
	}
	
	public void take(int money) {
		this.money += money;
	}
	
	public void showTaxiInfo() {
		System.out.println(companyName + "택시 수입은 " + money + "원 입니다.");
	}
}
========================================================================================
#)배열
int[] arr1 = new int[10];
int arr2[] = new int[10];
int[] arr3 = new int[] {10,20,30};
int[] arr4 = {10,20,30};

int[] arr5;
arr5 = new int[] {10,20,30};

for(int i = 0, num=1; i<arr.length; i++) {
	arr[i] = num++;
}

//처음부터 끝까지 돌릴때
for(int num : arr) {
	total += num;
}
--------------
//length를 활용하여 오류나는경우 -> length는 5인데 실제데이터는 3개만 들어가있다.
double[] dArr = new double[5];

dArr[0] = 1.1;
dArr[1] = 1.1;
dArr[2] = 1.1;

double mtotal = 1;
for(int i = 0; i<dArr.lengthl i++) {
	mtotal *= dArr[i];
}
--------------
//해결법: 요소의 개수에 대한 변수(count)를 유지 -> count를 1씩증가(for문돌리기위해 길이)
double[] dArr = new double[5];
int count = 0;
dArr[0] = 1.1; count++;
dArr[1] = 1.1; count++;
dArr[2] = 1.1; count++;

double mtotal = 1;
for(int i = 0; i<count; i++) {
	mtotal *= dArr[i];
}
----------------
package ch20;

public class CharArrayTest {
	public static void main(String[] args) {
		char[] alphabets = new char[26];
		char ch = 'A';
		
		for(int i =0; i<alphabets.length; i++) {
			alphabets[i] = ch++;
		}
		for(char alpha : alphabets) {
			System.out.println(alpha + ", " + (int)alpha);
		}
	}
}
==========================================================================================
package ch21;

public class Book {
	private String title;
	private String author;
	
	public Book() {}
	public Book(String title, String author) {
		this.title = title;
		this.author = author;
	}
	
	public String getTitle() {
		return title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public String getAuthor() {
		return author;
	}
	public void setAuthor(String author) {
		this.author = author;
	}
	
	public void showInfo() {
		System.out.println(title + ", " + author);
	}
	
}
------------------
package ch21;

public class BookTest {

	public static void main(String[] args) {
		Book[] library = new Book[5]; //null로 초기화, new한다고 Book객체가 만들어지는게 아니다.
		
		library[0] = new Book("태백산맥1", "조정래"); //객체를 만들어서 넣어야한다. 
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		for(Book book : library) {
			System.out.println(book); //ch21.Book@36aa7bc2  처럼 각기다른 5개 나옴
			book.showInfo();
		}
		
		
	}

}
--------------------
package ch21;

public class ObjectCopyTest {
	public static void main(String[] args) {
		Book[] library = new Book[5]; //null로 초기화, new한다고 Book개게가 만들어지는게 아니다.
		Book[] copyLibrary = new Book[5];
		
		library[0] = new Book("태백산맥1", "조정래"); //객체를 만들어서 넣어야한다. 
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		System.arraycopy(library, 0, copyLibrary, 0, 5); //library 0번쨰부터 복사해서 copyLibrary의 0에서5까지 넣어라(주소가 같은 상태이다)
	
		//기존 book
		for(Book book : library) {
			System.out.println(book);  //주소가같다.
			book.showInfo();
		}
		
		//복사한
		for(Book book : copyLibrary) { //주소가같다.
			System.out.println(book); 
			book.showInfo();
		}
		
		//주소가같아서 library0번째만 바꿧는데 copyLibrary도 같이 바뀐다.
		library[0].setAuthor("박완서");
		library[0].setTitle("나목");
		
	}
	//이런게 얕은복사이다.
}
-------------------
package ch21;

public class ObjectCopyTest2 {
	public static void main(String[] args) {
		Book[] library = new Book[5]; 
		Book[] copyLibrary = new Book[5];
		
		library[0] = new Book("태백산맥1", "조정래");
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		//깊은 복사 방식
		copyLibrary[0] = new Book();
		copyLibrary[1] = new Book();
		copyLibrary[2] = new Book();
		copyLibrary[3] = new Book();
		copyLibrary[4] = new Book();
		
		for(int i =0; i<library.length; i++) {
			copyLibrary[i].setAuthor(library[i].getAuthor());
			copyLibrary[i].setTitle(library[i].getTitle());
		}
		
		
		//주소가같아서 library0번째만 바꿧는데 copyLibrary[0]는 안바뀐다.
		library[0].setAuthor("박완서");
		library[0].setTitle("나목");
		
				//기존 book
				for(Book book : library) {
					System.out.println(book);  //주소가다르다
					book.showInfo();
				}
				
				//복사한
				for(Book book : copyLibrary) { //주소가 다르다
					System.out.println(book); 
					book.showInfo();
				}
	}
}
==============================================================================
package ch22;

public class TwoDimensionTest {
	public static void main(String[] args) {
		int[][] arr = { {1,2,3}, {4,5,6,7}};
		//int[][] arr = new int[3][4];
		
		int i, j;
		
		for(i =0; i<arr.length; i++) {
			for(j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j] + " ");
			}
			System.out.println(", \t" + arr[i].length);
			System.out.println();
		}
	}
}
/* 결과
 * 1 2 3 , 3
 * 
 * 4 5 6 7 , 4
 */
 ==========================================================
 package ch23;

import java.util.ArrayList;

import ch21.Book;

public class ArrayListTest {

	public static void main(String[] args) {
		//기존 배열방식은 길이가 고정이라서 배열의 길이가 커지면 배열을 재할당하고 복사해야했다.
		//ArrayList는 동적
		
		ArrayList<Book> library = new ArrayList<Book>(); //book객체를 가리키는 주소가 array형식으로 만들겠다.
				
				library.add(new Book("태백산맥1", "조정래"));
				library.add(new Book("태백산맥2", "조정래"));
				library.add(new Book("태백산맥3", "조정래"));
				library.add(new Book("태백산맥4", "조정래"));
				library.add(new Book("태백산맥5", "조정래"));
				
				for(int i =0; i<library.size(); i++) {
					library.get(i).showInfo();
				}
			}

}
==============================================================
package ch24;

public class Subject {
	private String name; //과목이름
	private int scorePoint; //점수
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getScorePoint() {
		return scorePoint;
	}
	public void setScorePoint(int scorePoint) {
		this.scorePoint = scorePoint;
	}
}
----------------
package ch24;

import java.util.ArrayList;

public class Student {
	int studentID;
	String studentName;
	ArrayList<Subject> subjectList; //이게 Has-A 방식 (subject를 상속받는게아니라) -> 클래스가 다른 클래스를 포함하는 관계
		
	public Student(int studentID, String studentName){
		this.studentID = studentID;
		this.studentName = studentName;
		
		subjectList = new ArrayList<Subject>();
	}
	
	public void addSubject(String name, int score){
		Subject subject = new Subject();
		
		subject.setName(name); //입력받은 이름 
		subject.setScorePoint(score); //입력받은 점수
		
		subjectList.add(subject); //리스트에 add
	}
	
	public void showStudentInfo()
	{
		int total = 0;
		
		for(Subject s : subjectList){
			
			total += s.getScorePoint();
			System.out.println("학생 " + studentName + "의 " + s.getName() + " 과목 성적은 " + 
			        s.getScorePoint() + "입니다.");
		}
			
		System.out.println("학생 " + studentName + "의 총점은 " + total + " 입니다.");
	}
}
-----------------
package ch24;

public class StudentTest {
	public static void main(String[] args) {
		Student studentLee = new Student(1001, "Lee");
		
		studentLee.addSubject("국어", 100);
		studentLee.addSubject("수학", 50);
		
		Student studentKim = new Student(1002, "Kim");
		
		studentKim.addSubject("국어", 70);
		studentKim.addSubject("수학", 85);
		studentKim.addSubject("영어", 100);
		
		studentLee.showStudentInfo();
		System.out.println("======================================");
		studentKim.showStudentInfo();
	}
}
==================================================================================
package ch2;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public int calcPrice(int price) { //입력받은 price
		bonusPoint += price * bonusRatio; //가격의 1퍼센트를 기존 보너스포인트에 쌓는다.
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}

-----------------
package ch2;

//만약에 VIPCustomer 클래스없이 Customer로만 만들려면 if문돌려서 gold,silver 분류해서 할인율, 또 요구조건이 생기면 계속 if문 쓰면 너무 번거롭다.
//그래서 VIPCustomer로 별도로 뺸다.
public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio; //VIP에만 있는 변수
	
	public VIPCustomer() { //생성자
		//super();
		customerGrade = "VIP";//덮어쓰기    //오류 발생 -> extends를 해야한다(protected라서), private은 extends해도 안됨.
		bonusRatio = 0.05; //덮어쓰기 마찬가지 
		salesRatio = 0.1;
	}
	
	public int getAgentID() { //안씀
		return agentID;
	}
}

---------------------
package ch2;

public class CustomerTest {
	public static void main(String[] args) {
		Customer customerLee = new Customer();
		customerLee.setCustomerName("이순신");
		customerLee.setCustomerID(10010);
		customerLee.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee.showCustomerInfo());
			
			
		VIPCustomer customerKim = new VIPCustomer();  //new VIPCustomer()를 호출하면 Customer()생성자가 먼저 호출된다.
		customerKim.setCustomerName("김유신"); //부모의 메서드
		customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim.showCustomerInfo()); //vip로 생성자만들었으니 잘나온다.
	}
}
이순신님의 등급은 SILVER이며, 보너스 포인트는 1000입니다
김유신님의 등급은 VIP이며, 보너스 포인트는 10000입니다
=============================================================================
package ch3;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public Customer(int customerID, String customerName) {
		this.customerID = customerID;
		this.customerName = customerName;
		
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //가격의 1퍼센트를 기존 보너스포인트에 쌓는다, 현재는 vip는 계산이안됨,vip에서 bonusratio를 재정의해도 calcPrice에서 찾아가지못함.
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}
-------------------
package ch3;

public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio; //VIP에만 있는 변수
	
	public VIPCustomer() { //덮어쓰기
		//super();
		customerGrade = "VIP"; 
		bonusRatio = 0.05;
		salesRatio = 0.1;
	}
	
	public VIPCustomer(int customerID, String customerName) {
		super(customerID, customerName);
		customerGrade = "VIP"; //덮어쓰기 super()에서 정의된 customerGrade를   
		bonusRatio = 0.05; //마찬가지로 덮어쓰기
		salesRatio = 0.1;
		//아직 보너스포인트, 가격은 정의안함
	}
	
	public int getAgentID() {
		return agentID;
	}
}
----------------------
package ch3;

public class CustomerTest {
	public static void main(String[] args) {
		Customer customerLee = new Customer(); //디폴트 생성자
		customerLee.setCustomerName("이순신");
		customerLee.setCustomerID(10010);
		customerLee.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee.showCustomerInfo());
		
		Customer customerLee2 = new Customer(10030, "홍길동");
		//customerLee.setCustomerName("홍길동");
		//customerLee.setCustomerID(10010);
		customerLee2.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee2.showCustomerInfo());
			
			
		VIPCustomer customerKim = new VIPCustomer();  //new VIPCustomer()를 호출하면 Customer()생성자가 먼저 호출된다.
		customerKim.setCustomerName("김유신"); //부모의 메서드
		customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim.showCustomerInfo());
		
		VIPCustomer customerKim2 = new VIPCustomer(10040, "강지은"); 
		//customerKim.setCustomerName("김유신"); //부모의 메서드
		//customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim2.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim2.showCustomerInfo());
	}
	
	//업캐스팅
	//Customer customerLee = new VIPCustomer(); 
	//customerLee.  으로 쓸수있는걸보면 Customer만 쓸수있다.(오버라이딩된거, 부모의 멤버변수만 쓸수있다)
}
==========================================================================================
package ch4;

public class Customer {
	protected int customerID; //private는 자식이여도 직접 수정은 못한다. -> setter로 가능
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	/*public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
		
		System.out.println("Customer() 생성자 호출");
	}*/
	
	public Customer(int customerID, String customerName) {
		this.customerID = customerID;
		this.customerName = customerName;
		
		customerGrade = "SILVER";
		bonusRatio = 0.01;
		//System.out.println("Customer(int, String) 생성자 호출");
	}
	
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}
---------------------
package ch4;

public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio;
	
	/*public VIPCustomer() {
		customerGrade = "VIP";    //오류 발생, why? customer에서 기본생성자를 주석처리 했기때문에
		bonusRatio = 0.05;
		salesRatio = 0.1;
		
		System.out.println("VIPCustomer() 생성자 호출");
	}
	*/
	
	public VIPCustomer(int customerID, String customerName) {
		super(customerID, customerName);
		
		customerGrade = "VIP";
		bonusRatio = 0.05;
		salesRatio = 0.1;
		
		//System.out.println("VIPCustomer(int, String) 생성자 호출");
	}
	
	
	//오버라이딩의 조건은 함수명, 매개변수, 타입까지 다 같아야한다.
	@Override
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price - (int)(price * salesRatio);
	}



	public int getAgentID() {
		return agentID;
	}
	
	@Override
	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade +  
				"이며, 보너스 포인트는 " + bonusPoint + "입니다(vip)";  //여기쓰인 변수들은 부모의 변수를 쓰고있다.
	}
}
---------------------
package ch4;

public class CustomerTest {
	public static void main(String[] args) {
			//함수의 이름이 주소값이다.
		 	//메서드는 명령어의 set이고 프로그램이 로드되면 메서드 영역(코드영역)에 명령어 set이 위치
			//해당 메서드가 호출되면 명령어 set이 있는 주소를 찾아 명령어가 실행됨
			//이때 메서드에서 사용하는 변수들은 스택메모리에 위치한다
			//따라서 다른 인스턴스라도 같은 메서드의 코드는 같으므로 같은 메서드가 호출됨
			//인스턴스가 생성되면 변수는 힙메모리에 따로 생성되지만, 메서드 명령어 set은 처음 한번만 로드됨
		
			//가상메소드란
			//상속에서 상위클래스와 하위 클래스에 같은 이름의 메서드((재정의함수)가 존재할 때 호출되는 메소드는 인스턴스에 따라 결정된다.
			//선언한 클래스형이 아닌 생성된 인스턴스의 메서드를 호출하는것
			//그떄, 인스턴스의 메서드가 호출되는 기술을 가상메서드라고한다.
		
			//같은 객체의 인스턴스를 여러개 생성한다고 해서 메소드도 여러개 생성되지 않는다.
			//즉, new Customer 를 여러번한다고 해서 a라는 메서드가 여러개 생성되지 않는다.(하나를 공유(메모리주소로))
			//예외적으로 사용하는 지역변수는 stack에 생성되서 잡힘
		
			//VIP의 멤버변수 private int agentID;  double salesRatio;
			Customer customerLee = new Customer(10010, "이순신");
			customerLee.bonusPoint = 1000;
			System.out.println(customerLee.showCustomerInfo());
			
			VIPCustomer customerKim = new VIPCustomer(10020, "김유신");
			customerKim.bonusPoint = 10000;
			System.out.println(customerKim.showCustomerInfo());
			
			int priceLee = customerLee.calcPrice(10000); //구입가격대입
			int priceKim = customerKim.calcPrice(10000); //구입가격대입
			
			System.out.println(customerLee.showCustomerInfo() + " 지불금액은 " + priceLee + "원 입니다.");
			System.out.println(customerKim.showCustomerInfo() + " 지불금액은 " + priceKim + "원 입니다.");
			
			//업캐스팅
			Customer customerNo = new VIPCustomer(10030, "나몰라"); 
			customerNo.bonusPoint = 10000;
			int priceNo = customerNo.calcPrice(10000); //오버라이딩한 VIPCustomer를 찾아간다.
			System.out.println(customerNo.showCustomerInfo() + " 지불금액은 " + priceNo  + "원 입니다."); //오버라이딩한 show를 찾아간다
			
			//나몰라님의 등급은 VIP이며, 보너스 포인트는 10500입니다 지불금액은 9000원 입니다.
		}
}
=============================================================================================
package ch6;

import java.util.ArrayList;
//정보은닉, 상속과 더불어 다형성은 객체지향 프로그래밍의 가장 큰 특징 중 하나이다.
class Animal{
	
	public void move() {
		System.out.println("동물이 움직입니다.");
	}
	
	public void eating() {
		
	}
}

class Human extends Animal{
	@Override
	public void move() {
		System.out.println("사람이 두발로 걷습니다.");
	}
	
	public void readBooks() {
		System.out.println("사람이 책을 읽습니다.");
	}
}

class Tiger extends Animal{
	@Override
	public void move() {
		System.out.println("호랑이가 네 발로 뜁니다.");
	}
	
	public void hunting() {
		System.out.println("호랑이가 사냥을 합니다.");
	}
}


class Eagle extends Animal{
	@Override
	public void move() {
		System.out.println("독수리가 하늘을 날아갑니다.");
	}
	
	public void flying() {
		System.out.println("독수리가 날개를 쭉 펴고 멀리 날아갑니다");
	}
}

public class AnimalTest {
	public static void main(String[] args) {

		Animal hAnimal = new Human();//업캐스팅 됬지만 오버라이딩된 메서드를 찾아간다.
		Animal tAnimal = new Tiger();
		Animal eAnimal = new Eagle();
		
		//출력방법 1
		AnimalTest test = new AnimalTest(); //밑에 moveAnimal함수쓸려고 갹체 생성
		test.moveAnimal(hAnimal);
		test.moveAnimal(tAnimal);
		test.moveAnimal(eAnimal);
		
		
		//출력방법2
		ArrayList<Animal> animalList = new ArrayList<Animal>();
		animalList.add(hAnimal);
		animalList.add(tAnimal);
		animalList.add(eAnimal);
		
		for(Animal animal : animalList) {
			animal.move();
		}
	}	
	//main밖에서 함수정의해야한다.
	public void moveAnimal(Animal animal) {
		animal.move(); //이런게 다형성이다. 같은 move라는 메서드이지만 출력결과는 다르다.
		
	}
	
}
===========================================================================================
package ch6;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer()
	{
		initCustomer();
	}

	public Customer(int customerID, String customerName){
		this.customerID = customerID;
		this.customerName = customerName;
		
		initCustomer();
	}
	
	private void initCustomer() //회원등급과 보너스포인트비율을 초기화
	{
		customerGrade = "SILVER";
		bonusRatio = 0.01;	
	}
	
	public int calcPrice(int price){
		bonusPoint += price * bonusRatio;
		return price;
	}
	
	public String showCustomerInfo(){
		return customerName + " 님의 등급은 " + customerGrade + "이며, 보너스 포인트는 " + bonusPoint + "입니다.";  
	}
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}
}
---------------
package ch6;

public class GoldCustomer extends Customer{

	double saleRatio;
		
		public GoldCustomer(int customerID, String customerName){
			super(customerID, customerName);
		
			customerGrade = "GOLD"; //부모의 멤버변수니까 showInfo는 오버라이딩 안했음. 
			bonusRatio = 0.02;   	//부모의 멤버변수
			saleRatio = 0.1;		//내꺼
		
		}
		@Override
		public int calcPrice(int price){
			bonusPoint += price * bonusRatio;
			return price - (int)(price * saleRatio);
		}
}
-------------------
package ch6;

public class VIPCustomer extends Customer{
	private int agentID;
	double saleRatio;
	
	public VIPCustomer(int customerID, String customerName, int agentID){
		super(customerID, customerName);
	
		customerGrade = "VIP";
		bonusRatio = 0.05;
		saleRatio = 0.1;
		this.agentID = agentID;
	}
	@Override
	public int calcPrice(int price){
		bonusPoint += price * bonusRatio;
		return price - (int)(price * saleRatio);
	}
	@Override
	public String showCustomerInfo(){
		return super.showCustomerInfo() + " 담당 상담원 번호는 " + agentID + "입니다";  //super.showInfo로 부모메소드부른후 뒤에 문자열 추가
	}

	public int getAgentID(){
		return agentID;
	}
}
-----------------
package ch6;

import java.util.ArrayList;

public class CustomerTest {
	public static void main(String[] args) {
			
			ArrayList<Customer> customerList = new ArrayList<Customer>();
			
			Customer customerLee = new Customer(10010, "이순신");
			Customer customerShin = new Customer(10020, "신사임당");
			Customer customerHong = new GoldCustomer(10030, "홍길동");
			Customer customerYul = new GoldCustomer(10040, "이율곡");
			Customer customerKim = new VIPCustomer(10050, "김유신", 12345);
			
			customerList.add(customerLee);
			customerList.add(customerShin);
			customerList.add(customerHong);
			customerList.add(customerYul);
			customerList.add(customerKim);
			
			System.out.println("====== 고객 정보 출력 =======");
			
			for( Customer customer : customerList){
				System.out.println(customer.showCustomerInfo());
			}
			
			System.out.println("====== 할인율과 보너스 포인트 계산 =======");
			
			int price = 10000;
			
			for( Customer customer : customerList){
				int cost = customer.calcPrice(price); //재정의된 calcPrice를 찾는다.
				System.out.println(customer.getCustomerName() +" 님이 " +  + cost + "원 지불하셨습니다."); //Customer로 업캐스팅 했기때문에 Customer의 bonusPoint를 가져올수있다.
				System.out.println(customer.getCustomerName() +" 님의 현재 보너스 포인트는 " + customer.bonusPoint + "점입니다.");
			}
		}
}
===================================================================
package ch8;

import java.util.ArrayList;

//다운캐스팅은 명시적으로 해야한다.
//Customer vc = new VIPCustomer(); 묵시적(업캐스팅)
//VIPCustomer vCustomer = (VIPCustomer)vc; 명시적(다운캐스팅)

	class Animal{
		
		public void move() {
			System.out.println("동물이 움직입니다.");
		}
		
		public void eating() {
			
		}
	}

	class Human extends Animal{
		public void move() {
			System.out.println("사람이 두발로 걷습니다.");
		}
		
		public void readBooks() {
			System.out.println("사람이 책을 읽습니다.");
		}
	}

	class Tiger extends Animal{
		
		public void move() {
			System.out.println("호랑이가 네 발로 뜁니다.");
		}
		
		public void hunting() {
			System.out.println("호랑이가 사냥을 합니다.");
		}
	}


	class Eagle extends Animal{
		public void move() {
			System.out.println("독수리가 하늘을 날아갑니다.");
		}
		
		public void flying() {
			System.out.println("독수리가 날개를 쭉 펴고 멀리 날아갑니다");
		}
	}
public class AnimalTest {
	public static void main(String[] args) {
		Animal hAnimal = new Human();  
		Animal tAnimal = new Tiger();
		Animal eAnimal = new Eagle();
		
		/*AnimalTest test = new AnimalTest();
		test.moveAnimal(hAnimal);  //함수에전달(다형성)
		test.moveAnimal(tAnimal);
		test.moveAnimal(eAnimal);
		*/
		
		//다운캐스팅
		ArrayList<Animal> animalList = new ArrayList<Animal>();
		animalList.add(hAnimal);
		animalList.add(tAnimal);
		animalList.add(eAnimal);
		
		AnimalTest test = new AnimalTest();
		test.testDownCasting(animalList);
		
		
		
	/*	for(Animal animal : animalList) {
			animal.move();
		}
		*/	
	}
	
	//다시 원래 자기타입으로 되돌리고 싶으면 다운캐스팅 쓰고 그게아니면 그냥 다형성을 쓰는게 좋다 (moveAnimal 함수처럼)
	public void testDownCasting(ArrayList<Animal> list) {
			
			for(int i =0; i<list.size(); i++) {
				Animal animal = list.get(i);
			
				if ( animal instanceof Human) { //animal이 Human타입이냐
					Human human = (Human)animal;
					human.readBooks();
				}
				else if( animal instanceof Tiger) {
					Tiger tiger = (Tiger)animal;
					tiger.hunting();
				}
				else if( animal instanceof Eagle) {
					Eagle eagle = (Eagle)animal;
					eagle.flying();
				}
				else {
					System.out.println("error");
				}
			
			}
		}
	
	
	
	/*
	 * public void moveAnimal(Animal animal) { animal.move();
	 * 
	 * }
	 */
	}
======================================================================================================
#)추상클래스
추상의 반댓말은 구체적
추상클래스란 우리가 클래스를 구성할 떄 메서드를 구현하는데 추상클래스는 메서드의 선언만있다.
추상클래스는 new할수없음.(인스턴스화 할수없다)
abstract예약어사용

int add(int x, int y);   -> 추상메서드(함수내용은 정의하지않음), 메서드선언만했다.
위와같은 추상메서드를 포함한것이 추상클래스이다.

=========================================================================================================
package ch9;

//부모
public abstract class  Computer { //추상클래스는 상속을위한 클래스다.
	
	//메서드선언만했다.(추상메서드)
	//상속받을 애들을 구체적으로 어떻게 구현할지 모르기때문에 display,typing은 자식이 알아서해라
	//컴퓨터는 공통으로쓸 turnOn, turnOff만 구현하고 display(), typing()은 구현하지않았다. 하위클래스로 책임전가
	abstract void display();
	abstract void typing();
	
	//일반메서드
	public void turnOn() {
		System.out.println("전원을 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("전원을 끕니다.");
	}
}
---------------
package ch9;

public class DeskTop extends Computer{

	@Override
	void display() {
		System.out.println("DeskTop display");
	}

	@Override
	void typing() {
		System.out.println("DeskTop typing");
	}

	@Override
	public void turnOff() { //재정의도 가능
		System.out.println("Desktop turnoff");
	}
}
------------------
package ch9;
//추상클래스를 상속받으면 메소드를 다 구현해야된다. 안하면 abstract를 붙여야한다.
public abstract class NoteBook extends Computer{ //추상클래스 (구현안한 메서드가 display()가있는데 이거를 구현안하면 abstract를 붙힌다)
	@Override
	public void typing() {
		System.out.println("NoteBook typing");		
	}
}
-------------------
package ch9;

public class MyNoteBook extends NoteBook{ //추상클래스인 NoteBook을 상속받음(부모가 구현안한 display()를 구현)

	@Override
	void display() {
		System.out.println("MyNoteBook display");		
	}
}
------------------
package ch9;

public class ComputerTest {

	public static void main(String[] args) {
		Computer computer = new DeskTop(); //Computer는 추상클래스(인스턴스화할수없다new), DeskTop은 일반클래스
		computer.display(); //오버라이딩된 인스턴스의 메서드를 찾아간다(desktop) -> 가상메서드
		computer.turnOff();
		
		NoteBook myNote = new MyNoteBook();
	}
}
==================================================================================
jdk(라이브러리) -> 안에도 라이브러리있음. -> 내가 필요한 경우 가져다쓰지만 내가 구성을한다.

안드로이드(프레임워크) -> 프레임워크를 도입한다는 애기는 이미 흐름이 정의되있다. 내가 어떤클래스를 넣으면 어떻게연동되고, 내가 값을 넣으면 어떻게 답이오고 영향을 주는지 등등
화면이 어떻게돌아가고 클로즈가되고 destroy가 된다 등은 안드로이드 내부에 이미정의되있지만(프레임워크) 실제로 화면에서 어떤위젯이 올라가고 어떤액션을 할지는 우리가 짜는것이다.
화면에 여러가지생성과정, 소멸과정 등은 정해져있지만 거기에 들어가는 기능들은 우리가해야한다.

프레임워크에서 많이쓰는 패턴중에하나가 템플릿메서드패턴이다.
- 추상 메서드나 구현된 메서드를 활용하여 코드의 흐름(시나리오)를 정의하는 메서드
- final로 선언하여 하위클래스에서 재정의 할 수 없게한다.(흐름은 변하면안되기때문에)
- 하위클래스에서 다르게 구현되어야 하는 부분은 추상메서드로 선언하여 하위 클래스에서 구현하도록 함

==================================================================================
package ch10;

public abstract class Car {
	//선언만했다.
	public abstract void drive(); //AI, 직접운전은 drive메서드는 자식이 구현해라
	public abstract void stop(); //마찬가지
	
	//시동은 공통이니까 구현했음
	public void startCar() {
		System.out.println("시동을 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("시동을 끕니다.");
	}
			
	public void washCar() {} //구현되긴했다.
	
	final public void run() {
		//시동을걸고 운전하다가 일이생기면 멈추고 시동꺼라 -> 시나리오(이거는 변하면안된다) -> run메서드를 재정의하면안되니까 final로 선언
		startCar(); //일반
		drive(); //추상
		stop(); //추상 
		turnOff(); //일반
		washCar(); //재정의할수있게끔(ai에서만 써도됨), 일반자동차는 재정의안했음
	}
}
------------------
package ch10;

public class AICar extends Car{
	
	//Car에서 상속받은 추상메서드 drive, stop 구현
	@Override
	public void drive() {
		System.out.println("자율 주행합니다.");
		System.out.println("자동차가 스스로 방향을 바꿉니다.");
	}

	@Override
	public void stop() {
		System.out.println("스스로 멈춥니다.");		
	}

	@Override
	public void washCar() {
		System.out.println("자동 세차를 합니다.");
	}
	
	
}
-----------------------
package ch10;

public class ManualCar extends Car{

	@Override
	public void drive() {
		System.out.println("사람이 운전합니다.");
		System.out.println("사람이 핸들을 조작합니다.");		
	}

	@Override
	public void stop() {
		System.out.println("브레이크를 밟아서 정지합니다.");		
	}

}
------------------------
package ch10;

public class CarTest {

	public static void main(String[] args) {
		Car aiCar = new AICar();
		aiCar.run();
		System.out.println("=================");
		Car manualCar = new ManualCar();
		manualCar.run();
	}
}
========================================================================
package ch10;

//이렇게 상수는 따로 빼서 쓴다.
public class Define {

	public static final int MIN = 1;
	public static final int MAX = 999999;
	public static final double PI = 3.14;
	public static final String GREETING = "Good Morning!";
	public static final int MATH_CODE = 1001;
	public static final int CHEMISTRY_CODE = 1002;
	
}
-------------------
package ch10;

public class UsingDefine {

	public static void main(String[] args) {

		System.out.println(Define.GREETING);
		System.out.println(Define.MIN);
		System.out.println(Define.MAX);
		System.out.println(Define.MATH_CODE);
		System.out.println(Define.CHEMISTRY_CODE);
		System.out.println("원주률은" + Define.PI + "입니다.");
	}

}
===========================================================================
#)인터페이스
인터페이스에서 메소드를 선언하면 모든 메소드가 자동으로 public abstract로 선언이된다.
모든 변수는 상수로 선언된다. public static final

interface 인터페이스 이름 {
	(public static final)float pi = 3.14F;
	public void makeSomthing(); //알아서 public abstract 으로 바뀜
}

============================================================================
#)인터페이스가 하는일
클래스나 프로그램이 제공하는 기능을 명시적으로 선언
클라이언트는 인터페이스에 선언된 메서드 명세만 보고 이를 구현한 클래스를 사용할 수 있음
클라이언트는 서버가 어떻게 구현되있는 모른다 -> 그래서 서버와 클라이언트 사이에 선언된 인터페이스 명세를 보고 클라이언트가 쓴다.(서버의 메서드가 어떻게 구현되있는지는 궁금하지않음)
어떤 객체가 하나의 인터페이스 타입이라는 것은 그 인터페이스가 제공하는 모든 메서드를 구현했다는 의미이다.
단, 클라이언트가 쓸때는 모든 메서드를 쓸필요는 없다. 서버만 모든 메서드를 구현
인터페이스를 구현한 다양한 객체를 사용함 -> 다형성

인터페이스를 쓰고있는 여러 클래스가 있어도 동일한 방식으로 쓰인다.

ex) jdbc 인터페이스 (connection도 인터페이스이다. -> 서드파티에서 메서드 구현했고 클라이언트는 골라쓰기만하면된다)

================================================================================
package ch11;

public interface Calc {

	double PI = 3.14; //static으로 바뀜
	int ERROR = -99999999;
	
	int add(int num1, int num2); //인터페이스는 abstract와 달리 상속이아니라 구현이라는 것이다.(Calculator에서 구현해야됨)
	int substract(int num1, int num2);
	int times(int num1, int num2);
	int divide(int num1, int num2);
	
}
-----------------
package ch11;

public abstract class Calculator implements Calc{ //abstract를 붙여야됨. implements를 붙이는순간 4개의 메서드를 구현해야되는데 2개만 구현했음
	//또, implement메서드는 자동으로 abstract가 붙기때문에 4개를 다 구현하지 않으면 abstract로 클래스를 만들어야한다.

	@Override
	public int add(int num1, int num2) {
		return num1 + num2;
	}
	
	@Override
	public int substract(int num1, int num2) {
		return num1 - num2;
	}
}

-------------------
package ch11;

public class CompleteCalc extends Calculator{
	
	@Override
	public int times(int num1, int num2) {
		return num1 * num2;
	}

	@Override
	public int divide(int num1, int num2) {
		if( num2 == 0 )
			return ERROR;
		else 
			return num1 / num2;
	}
	
	public void showInfo() {
		System.out.println("모두 구현하였습니다.");
	}
}
-----------------
package ch11;

import java.util.Scanner;

public class CalculatorTest {

	public static void main(String[] args) {
		Calc calc = new CompleteCalc(); //타입이 Calc이다.(인터페이스) 형변환, 인터페이스를 구현한 클래스는 인터페이스형으로 선언한 변수로 형 변환 할 수 있다.
		//형변환이된경우 인터페이스에 선언된 메서드만을 사용가능하다.
		int num1 = 10;
		int num2 = 2;
		
		System.out.println(num1 + "+" + num2 + "=" + calc.add(num1, num2));
		System.out.println(num1 + "-" + num2 + "=" +calc.substract(num1, num2));
		System.out.println(num1 + "*" + num2 + "=" +calc.times(num1, num2));
		System.out.println(num1 + "/" + num2 + "=" +calc.divide(num1, num2));
		
	}
}
==============================================================================
//인터페이스를 활용한 dao구현
dao인터페이스를 하나만들고 하나는 oracle, 또 하나는 mysql, 또 하나는 mssql용으로 만든다.
그러면 사용자는 implements로 바꾸기만 하면된다.
이런게 다형성이다. 똑같은 인터페이스를 활용해서 메서드를 활용하지만 결과는다르다.

===============================================================================
//인터페이스에서 모든 변수는 상수로 변환된다. public static final
//인터페이스에서 모든 선언된 메서드는 추상메서드로 선언된다.
//자바8이후에 디폴트메서드가있는데 implements가 된 클래스쪽에서 공통으로(기본적으로 제공) 사용할 수 있는 기본메서드이다. 오버라이딩로 가능
default void description() { //인터페이스쪽 
	System.out.println("정수계산기를 구현합니다.");
}

@Override //implements쪽 (class ~~~ implements ~~~~) 되는데 여기는 new로 인스턴스화를 해야된다. class이기때문에 하지만 정적메서드는 static이라 안해도된다.(아래참조)
public void description() {
	System.out.println("재정의");
}
==============================================================================
//또 자바8이후에 정적메서드를 제공한다.
위와 다르게 인스턴스 생성(new)과 관계없이 인터페이스 타입으로 사용할 수 있는 메서드
//자바 9이후에는 private메서드가 있다.
private이기때문에 인터페이스 내부에서만 사용하기 위해 구현하는 메서드
default메서드나 static메서드에서 사용한다.
=============================================================================
package ch14;

public interface Calc {

	double PI = 3.14;
	int ERROR = -99999999;
	
	int add(int num1, int num2);
	int substract(int num1, int num2);
	int times(int num1, int num2);
	int divide(int num1, int num2);
	
	default void description() {
		System.out.println("정수 계산기를 구현합니다.");
		myMethod(); 
	}
	
	static int total(int[] arr) { //arr의 합구하기
		int total = 0;
		
		for(int i: arr) {
			total += i;
		}
		mystaticMethod(); //static메서드에서 private static호출가능(private이기때문에 클래스안에서만)
		return total;
	}
	
	private void myMethod() { //버전때문에 지금 private는 안된다. 상속받은 CompleteCalc에서 구현하라고 에러가뜸
		System.out.println("private method");
	}
	
	private static void mystaticMethod() { 
		System.out.println("private static method");
	}
}
--------------
package ch14;

public abstract class Calculator implements Calc{ //implements를 하면 4개 함수 (add등)다 구현해야하는데 2개만해서 abstract붙혔다.

	@Override
	public int add(int num1, int num2) {
		return num1 + num2;
	}

	@Override
	public int substract(int num1, int num2) {
		return num1 - num2;
	}
}

---------------
package ch14;

public class CompleteCalc extends Calculator{ //Calc interface의 private myMethod, mystaticMethod는 재정의,구현할수없다.
	//즉, private메서드는 재정의할수없다.
	@Override
	public int times(int num1, int num2) {
		return num1 * num2;
	}

	@Override
	public int divide(int num1, int num2) {
		if( num2 == 0 )
			return ERROR;
		else 
			return num1 / num2;
	}
	
	public void showInfo() { //내 함수
		System.out.println("모두 구현하였습니다.");
	}

	@Override
	public void description() { //Calc interface에 있는 default메서드이다.
		System.out.println("CompleteCalc에서 재정의한 default 메서드");
		//super.description(); 부모에있는걸쓰는게아니라 재정의하겠다. 위에서
	}
}
----------------
package ch14;

public class CalculatorTest {

	public static void main(String[] args) {
		Calc calc = new CompleteCalc();
		int num1 = 10;
		int num2 = 2;
		
		System.out.println(num1 + "+" + num2 + "=" + calc.add(num1, num2));
		System.out.println(num1 + "-" + num2 + "=" +calc.substract(num1, num2));
		System.out.println(num1 + "*" + num2 + "=" +calc.times(num1, num2));
		System.out.println(num1 + "/" + num2 + "=" +calc.divide(num1, num2));
	
		calc.description();
		
		int[] arr = {1,2,3,4,5};
		int sum = Calc.total(arr); //total이라는 정적메서드이기때문에 바로 클래스를 호출했다.(private로 선언된 mystaticMethod도 호출했다 total에 같이선언되있으니)
		System.out.println(sum);
	}
}
====================================================================
#)여러 인터페이스 구현
//자바의 인터페이스에는 구현코드가 없으므로 하나의 클래스가 여러 인터페이스는 구현할수있음

buy(인터페이스)   sell(인터페이스)
       \	      /
      Customer(구현클래스) implements가 2개이다.

//그렇다면 클래스에서 상속은 왜 하나만 될까
예를들어 
a라는 클래스에서 b(클래스)가 a를 상속받고, c(클래스)가 상속받고 a라는 클래스에서 정의한 a라는 메서드를 b,c클래스에서 재정의하고나서
d라는 클래스가 d extends b extends c라고 한다면 무슨 메서드를 써야할지모른다. -> 따라서 다중상속이 안되는이유는 이러한 다이아몬드 상속때문이다.(c++은 가능하다. 어느클래스의 메서드를 써라는것을 지정가능)

static메서드는 인터페이스이름으로 호출
디폴트메서드가 중복되는 경우는 구현하는 클래스에서 재정의해야한다.(여러인터페이스호출시)

여러인터페이스를 구현한 클래스는 인터페이스 타입으로 형변환되는 경우 해당인터페이스에 선언된 메서드만 사용가능하다.
예를들어 buy로 인터페이스 타입선언되면 buy인터페이스 기능만 쓸수있다.

package ch15;

public interface Buy {

	void buy();
	
	default void order() {
		System.out.println("구매 주문");
	}
}
--------------
package ch15;

public interface Sell {

	void sell();
	
	default void order() {
		System.out.println("판매 주문");
	}
}
--------------
package ch15;

public class Customer implements Buy, Sell{

	@Override
	public void sell() {
		System.out.println("customer sell");
	}

	@Override
	public void buy() {
		System.out.println("customer buy");		
	}

	@Override
	public void order() { //default메서드를 재정의했다. 재정의나 명시적으로 누구의 메서드쓸지인지 선언 안하면에러가난다. 왜냐하면 buy,sell 디폴트메서드가 중복되기때문에
		//명시적으로 누구의 디폴트메서드를 쓸지 정의해야한다.
		//Sell.super.order();
		//아니면 그냥 재정의하던지
		System.out.println("customer order");
	}

	public void sayHello() { //내함수
		System.out.println("Hello");
	}

}
-----------------
package ch15;

public class CustomerTest {

	public static void main(String[] args) {

		Customer customer = new Customer();
		customer.buy();
		customer.sell();
		customer.sayHello();
		
		Buy buyer = customer; //type을 바꾼다.(업캐스팅)
		buyer.buy();
		
		Sell seller = customer;
		seller.sell();
		
		buyer.order(); //디폴트메서드로 정의한 order는 공통적으로 쓸수있다.
		seller.order();
	}
}
====================================================================
//인터페이스 상속
인터페이스 사이에도 상속을 사용할 수 있다.
extends 키워드를 사용
인터페이스는 다중상속이 가능하고 구현 코드의 상속이 아니므로 타입상속이라고 한다.

package ch15;

public interface X {

	void x();
}
------------
package ch15;

public interface Y {

	void y();
}
-------------
package ch15;

public interface MyInterface extends X, Y{  //인터페이스를 상속받음.

	void myMethod();
}
---------------
package ch15;

public class MyClass implements MyInterface{ //인터페이스 기능을 다 구현해야한다.

	@Override
	public void x() {
		System.out.println("x()");
	}

	@Override
	public void y() {
		System.out.println("y()");		
	}

	@Override
	public void myMethod() {
		System.out.println("myMethod()");		
	}
}
----------------
package ch15;

public class MyClassTest {

	public static void main(String[] args) {

		MyClass mClass = new MyClass(); //인터페이스는 클래스를 만들수없으니
		
		X xClass = mClass; //x로 타입이 되면 x만 쓸수있다.
		xClass.x();
		
		
		Y yClass = mClass;
		yClass.y();
		
		MyClass iClass = mClass;
		iClass.x();
		iClass.y();
		iClass.myMethod();
	}

}
========================================================
	   shelf  queue
(extends)\     /(implements)
		BookShelf

책이 순서대로 대여가 되는 도서관구현(FIFO)
shelf클래스를 상속받고 queue를 구현한다.

package ch15;

import java.util.ArrayList;

public class Shelf {

	 protected ArrayList<String> shelf; //상속받기위해 protected
	 
	 public Shelf() {
		 shelf = new ArrayList<String>();
	 }
	 
	 public ArrayList<String> getShelf(){
		 return shelf;
	 }
	 
	 public int getCount() {
		 return shelf.size();
	 }
	 
}
---------------
package ch15;

public interface Queue {

	//함수 3개선언
	void enQueue(String title);
	String deQueue(); //꺼내면 책의 이름을 반환
	
	int getSize(); //몇개가있느냐
}
---------------
package ch15;

public class BookShelf extends Shelf implements Queue{

	@Override
	public void enQueue(String title) {
		shelf.add(title); //shelf의 기능
	}

	@Override
	public String deQueue() {
		return shelf.remove(0); 
	}
 
	@Override
	public int getSize() {
		return getCount();
	}

}
------------------
package ch15;

public class BookShelfTest {

	public static void main(String[] args) {

		Queue bookQueue = new BookShelf(); //큐타입, 인터페이스는 new해서 못만든다.
		bookQueue.enQueue("태백산맥1");
		bookQueue.enQueue("태백산맥2");
		bookQueue.enQueue("태백산맥3");
		
		System.out.println(bookQueue.deQueue());
		System.out.println(bookQueue.deQueue());
		System.out.println(bookQueue.deQueue());
	}

}
=========================================================================
//상담원 작업분배 
//1. 우선배분(priority)
//2. 가장일이적은(leastjob)
//3. 
package ch16.scheduler;

public interface Scheduler {
	public void getNextCall();
	public void sendCallToAgent();
}
---------------
package ch16.scheduler;

public class PriorityAllocation implements Scheduler{

	@Override
	public void getNextCall() {
		System.out.println("고객등급이 높은 고객의 call을 먼저 가져옵니다");
		
	}

	@Override
	public void sendCallToAgent() {
		System.out.println("업무 숙련도가 높은 상담원에게 먼저 배분합니다");		
	}

}
-----------------
package ch16.scheduler;

public class LeastJob implements Scheduler{

	@Override
	public void getNextCall() {
		System.out.println("상담 전화를 순서대로 대기열에서 가져옵니다.");
		
	}

	@Override
	public void sendCallToAgent() {
		System.out.println("현재 상담업무가 없거나 상담대기가 가장 적은 상담원에게 할당합니다.");
		
	}

}
-------------------
package ch16.scheduler;

public class RoundRobin implements Scheduler{

	@Override
	public void getNextCall() {
		System.out.println("상담 전화를 순서대로 대기열에서 가져옵니다.");
	}

	@Override
	public void sendCallToAgent() {
		System.out.println("다음 순서의 상담원에게 배분합니다.");
	}

}
-----------------------
package ch16.scheduler;

import java.io.IOException;

public class SchedulerTest {

	public static void main(String[] args) throws IOException {

		System.out.println("전화 상담원 할당 방식을 선택하세요");
		System.out.println("R : 한명씩 차례대로");
		System.out.println("L : 대기가 적은 상담원 우선");
		System.out.println("P : 우선순위가 높은 고객우선 숙련도 높은 상담원");
		
		int ch = System.in.read();
		Scheduler scheduler = null; //인터페이스
		
		if ( ch == 'R' || ch =='r') {
			scheduler = new RoundRobin(); //인터페이스에만 있는 메서드만쓸수있다. RoundRobin에 재정의 된것
		}
		else if ( ch == 'L' || ch =='l') {
			scheduler = new LeastJob();
		}
		else if ( ch == 'P' || ch =='p') {
			scheduler = new PriorityAllocation();
		}
		else {
			System.out.println("지원되지 않는 기능입니다.");
			return;
		}
		
		scheduler.getNextCall();
		scheduler.sendCallToAgent();
	}

}
===============================================================
package ch16.gamelevel;

public abstract class PlayerLevel {
	
	public abstract void run();
	public abstract void jump();
	public abstract void turn();
	public abstract void showLevelMessage();
	
	
	final public void go(int count) { //템플릿메서드패턴
		run();
		for(int i = 0; i<count; i++) {
			jump();
		}
		turn();
	}

}
------------------
package ch16.gamelevel;

public class BeginnerLevel extends PlayerLevel{

	@Override
	public void run() {
		System.out.println("천천히 달립니다.");
	}

	@Override
	public void jump() {
		System.out.println("jump 못하지롱");
	}

	@Override
	public void turn() {
		System.out.println("turn 못하지롱");
	}

	@Override
	public void showLevelMessage() {
		System.out.println("****** 초급자 레벨입니다. ******");
	}

}
-------------------
package ch16.gamelevel;

public class AdvancedLevel extends PlayerLevel{

	@Override
	public void run() {
		System.out.println("빨리 달립니다.");
	}

	@Override
	public void jump() {
		System.out.println("높이 jump 합니다.");
	}

	@Override
	public void turn() {
		System.out.println("turn 못하지롱");
	}

	@Override
	public void showLevelMessage() {
		System.out.println("****** 중급자 레벨입니다. ******");
	}
}
---------------------
package ch16.gamelevel;

public class SuperLevel extends PlayerLevel{

	@Override
	public void run() {
		System.out.println("엄청 빠르게 달립니다.");
	}

	@Override
	public void jump() {
		System.out.println("아주 높이jump 합니다.");
	}

	@Override
	public void turn() {
		System.out.println("turn 합니다.");
	}

	@Override
	public void showLevelMessage() {
		System.out.println("****** 고급자 레벨입니다. ******");
	}
}
-----------------
package ch16.gamelevel;

public class UltraSuperLevel extends PlayerLevel{

	@Override
	public void run() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void jump() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void turn() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void showLevelMessage() {
		// TODO Auto-generated method stub
		
	}

}
--------------------
package ch16.gamelevel;

public class Player {
	
	private PlayerLevel level;
	
	public Player(){
		level = new BeginnerLevel();
		level.showLevelMessage();
	}
	
	
	public PlayerLevel getLevel() {
		return level;
	}
	
	public void upgradeLevel( PlayerLevel level ) {
		this.level = level;
		level.showLevelMessage();
	}
	
	public void play(int count) {
		level.go(count); //go에는 해당레벨의 run,turn 등
	}

}
----------------------
package ch16.gamelevel;

public class MainBoardPlay {

	public static void main(String[] args) {

		Player player = new Player();
		player.play(1); //기본레벨플레이어에서 계속 player.upgrade하는 방식
		
		AdvancedLevel aLevel = new AdvancedLevel();
		player.upgradeLevel(aLevel);
		player.play(2);
		
		SuperLevel sLevel = new SuperLevel();
		player.upgradeLevel(sLevel);
		player.play(3);
		
	}

}
=====================================================================
//오브젝트클래스
모든 클래스의 최상위 클래스이다. 
java.lang패키지 -> import안해도된다. String, Integer, System 등
모든 클래스는 오브젝트클래스를 상속받는다.
또 재정의도 할 수 있다. 물론, 재정의 할 수 없는 것도있는데 그거는 final로 선언되서 그렇다.

모든클래스는 java.lang.Object클래스를 상속받는다.
class Student = class Student (extends Object) 이렇게 된다.

toString 메서드는 객체의 정보를 String으로 바꾸어서 사용할 때 쓰인다.
=========================================================================
package ch01;

class Book{
	
	private String title;
	private String author;
	
	public Book(String title, String author) {
		this.title = title;
		this.author = author;
	}
	
	public String toString() {
		return title + "," + author;
	}
}

public class BookTest {

	public static void main(String[] args) {

		Book book = new Book("데미안", "헤르만 헤세");
		
		System.out.println(book);
	}
}
=========================================================================
//오브젝트 클래스
equals()메서드

StudentLee(메모리를 가리키는 참조변수)-----> 힙(인스턴스)   
StudentLee2                  ----->    "
이 두 참조변수가 똑같은 힙메모리를 가리키면 두개가 같다.(물리적)

equals의 역할은 두 인스턴스의 주소값을 비교하여 true/false를 반환
하지만, 재정의해서 두인스턴스가 논리적으로 같은지 비교 가능

clone()메서드
객체의 원본을 복제하는데 사용(멤버변수 등이 똑같은)
생성자랑은 다르다.
clone()메서드를 사용하면 객체의 정보(멤버변수 값 등)가 동일한 또 다른 인스턴스가 생성되는 것이므로, 은닉, 객체 보호의 관점에서 위배 될 수 있다.
private 까지 다 복제하니까
그래서 복제해도된다라는 것을 구분하기 위해 public class Student implements Cloneable 를 붙여준다.

-----------------------------------------------------
package ch02;

public class Student implements Cloneable{

	private int studentId;
	private String studentName;

	public Student(int studentId, String studentName)
	{
		this.studentId = studentId;
		this.studentName = studentName;
	}
	
	public boolean equals(Object obj) {
		if( obj instanceof Student) { //넘어온 객체가 Student인가
			Student std = (Student)obj; //그렇다면 obj를 Student로 다운캐스팅
			if(this.studentId == std.studentId ) //id로 똑같은 학생인지 확인(주소가 서로달라도) 즉, 주소가(물리적)달라도 논리적으로 같다. 
				return true;
			else return false;
		}
		return false;
		
	}
	
	public void setStudentName(String name) {
		this.studentName = name;
	}
	@Override
	public int hashCode() {
		return studentId;
	}

	@Override
	protected Object clone() throws CloneNotSupportedException {
		// TODO Auto-generated method stub
		return super.clone();
	}
	
}
----------------
package ch02;

public class EqualTest {

	public static void main(String[] args) throws CloneNotSupportedException { //cloneable하지않는데 clone할때 예외발생처리
		Student Lee = new Student(100, "Lee");
		Student Lee2 = Lee;
		Student Shun = new Student(100, "Lee");
		
		System.out.println(Lee == Shun); // 같은 클래스로 만들었지만 false로 나온다. 다른 객체이기때문에
		System.out.println(Lee.equals(Shun)); //재정의 안하면 false로 나온다. equals의 원래 재정의를 안하면 주소값이 같느냐를 보는것이다. 근데 우리는 재정의를 했다
		System.out.println(Lee == Lee2); //true
		
		System.out.println(Lee.hashCode()); //917~  서로 메모리주소가 다르기때문에
		System.out.println(Shun.hashCode()); //199~ 다른값이 나온다.
		//하지만 우리가 hashCode()를 재정의 했기때문에 같은값이나온다(Studentid)
		
		//그렇다고 기존에 가지고있던 hashCode()는 없어지지 않는다.
		//System.out.println(System.identityHashCode(Lee));
		//System.out.println(System.identityHashCode(Shun));
		
		//이와같은 방법으로 Integer, String도 위와같이 equals, hashCode가 오버라이딩이 되어있다.
		//그래서 아래와같이 나온다.
		Integer i1 = new Integer(100); //String str1 = new String("abc");
		Integer i2 = new Integer(100); //String str2 = new String("abc");
		
		System.out.println(i1.equals(i2)); //true
		System.out.println(i1.hashCode()); //100
		System.out.println(i2.hashCode()); //100
		
		System.out.println(System.identityHashCode(i1)); //주소값은 다르다
		System.out.println(System.identityHashCode(i2)); //주소값은 다르다.
		
		Lee.setStudentName("kim");
		Student Lee3 = (Student)Lee.clone(); //클론의 return타입은 object이기때문에 다운캐스팅
		System.out.println(Lee3); //100,kim 으로 나온다. 즉, 복제하면 다가져온다.
		
		System.out.println(System.identityHashCode(Lee)); //복제를 해도 주소값은다르다.
		System.out.println(System.identityHashCode(Lee3)); //값은 다르다.
		
		
		
	}
}
=================================================================================
//String 클래스
방법1. String str1 = new String("abc"); 이거는 힙에 생성
방법2. String str2 = "abc"; //상수풀에 잡힌다.  위랑 다르다. 

즉 힙메모리는 생성될 때마다 다른 주소값을 가지지만, 상수풀의 문자열은 모두 같은 주소값을 가진다.
package ch03;

public class StringTest {

	public static void main(String[] args) {
		String str1 = new String("abc");
		String str2 = new String("abc");
		
		System.out.println(str1 == str2); //false
		
		String str3 = "abc"; //abc를 가리키는 참조변수 2개(상수풀을 가리킴)
		String str4 = "abc";
		
		System.out.println(str3 == str4); //true
	}
}

==================================================================================
여기서 한번 생성된 String은 값을 바꿀수없다. new로 하든, 상수로 만들던 바꿀수없다.  -> immutable

package ch03;

public class StringTest2 {

	public static void main(String[] args) {
		String java = new String("java");
		String android = new String("android");
		System.out.println(System.identityHashCode(java));
		
		java = java.concat(android); //위에서 선언한 java참조변수가 새로운 공간인 javaandroid를 가리키게된다. 기존에있던 "java"공간은 남아있다.
		//근데 이렇게 쓰면 메모리 낭비이다.
		
		System.out.println(java);
		System.out.println(System.identityHashCode(java)); //다른주소를 가리킨다.
		
	}
}
//출력결과
366712642
javaandroid
1829164700

//이게 단점이 문자열을 연결할 때 메모리가 계속 생성되니까 StringBuilder를 쓰는 것이다.
======================================================
String은 final이라서 변경이 안되지만 String Builder, String Buffer는 변경이 된다.
그래서, 문자열은 연결, 변경할 떄 사용하면 유용하다.

String Builder는 단일쓰레드프로그램에서 사용을 권장
String Buffer는 멀티쓰레드 프로그램에서 동기화를 보장

package ch03;

public class StringBuilderTest {

	public static void main(String[] args) {
		String java = new String("java");
		String android = new String("android");
		
		StringBuilder buffer = new StringBuilder(java);
		System.out.println(System.identityHashCode(buffer));
		buffer.append("android");
		System.out.println(System.identityHashCode(buffer));
		
		java = buffer.toString(); //문자로체인지
		System.out.println(java);
	}
}
//출력결과
366712642
366712642
javaandroid
==============================================================
//java13부터가능 text block
package ch03;

public class StringTextBlock {

	public static void main(String[] args) {
		
		String strBlock = """
				This 
				is 
				text
				block
				test.""";
		System.out.println(strBlock);
		
		System.out.println(getBlockOfHtml());
		
	}
	
	public static String getBlockOfHtml() {
		    return """
		            <html>
		                <body>
		                    <span>example text</span>
		                </body>
		            </html>""";
		
	}

}
//출력
This 
is 
text
block
test.
 <html>
     <body>
		 <span>example text</span>
	</body>
</html>
======================================================================
//동적로딩
원래는 우리가 Person jo, Student lee 이렇게 데이터타입이 binding되는데 
동적로딩은 컴파일시에 데이터타입이 binding되는것이 아닌, 실행(runntime)중에 데이터타입을 binding을 하는 방법이다.
즉, 프로그래밍시에는 문자열변수로 처리했다가 런타임시에는 원하는 클래스를 로딩하여 binding 할수있다는장점이다.
단점은 컴파일시에 타입이 정해지지않으므로 동적로딩시 오류가 발생하면 프로그램의 심각한 장애가 발생

즉, 시스템이 돌아가다가 필요한 데이터타입을 그때 클래스를 부르는게 장점이다.

package ch04;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

public class StringTest {

	public static void main(String[] args) throws ClassNotFoundException {
		Class c3 =  Class.forName("java.lang.String");
		
		//c.getConstructors(); 배열로반환된다
		
		Constructor<String>[] cons =  c3.getConstructors();
		for(Constructor con: cons) {
			System.out.println(con); //많은생성자가 있다. 
		}
		
		System.out.println();
		
		Method[] methods = c3.getMethods();
		for(Method  method : methods) {
			System.out.println(method);
		}
	}

}
============================================================================
package ch04;

public class Person {
	private String name;
	private int age;
	
	//생성자 3개
	public Person() {};
	
	public Person(String name) {
		this.name = name;
	}
	
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
	
	public String toString() {
		return name;
	}
}
---------------------
package ch04;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class ClassTest {

	public static void main(String[] args) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException,
						ClassNotFoundException, NoSuchMethodException, SecurityException {
		//기존방식
		Person person = new Person("James");
		System.out.println(person); //James
		
		//동적로딩
		//Class.forName("클래스이름") 메서드로 클래스를 동적으로 로드함(런타임시에)
		
		//Class c = String.class; 클래스 이름으로 직접 Class가져오기
		
		//생성된 인스턴스에서 Class 클래스 가져오기
		//String s = new String();
		//Class c = s.getClass(); 
		
		Class c1 = Class.forName("ch04.Person"); //class를 가져오는 방법 1
		Person person1 = (Person)c1.newInstance(); //반환값이 오브젝트라서
		person1.setName("Lee");
		System.out.println(person1); //Lee 출력(오버라이딩했으니)
		
		//class를 가져오는 방법2
		//아래까지가 실질적으로 Person kim2 = new Person("김유신"); 과 같다.
		//이런거는 local에 Person이라는 클래스가 없을 떄 쓰는것이다.
		Class c2 = person1.getClass(); //getClass를 쓸려면 이미 인스턴스가 있는상태여야한다.
		Person p = (Person)c2.newInstance();
		System.out.println(p); //null출력
		
		Class[] parameterTypes = {String.class};  //person이라는 타입의 클래스가 없는데 
		Constructor cons = c2.getConstructor(parameterTypes); //constructor정보를 가져와서 반환해준다. 
		
		Object[] initargs = {"김유신"};
		Person personLee = (Person)cons.newInstance(initargs);
		System.out.println(personLee); //김유신 출력
		
		//이런게 reflection 프로그래밍인데
		//Class 클래스를 사용하여 클래스의 정보(생성자, 변수, 메서드)등을 알수있고 인스턴스를 생성하고, 메서드를 호출하는 방식의 프로그래밍
		//로컬메모리에 객체없는경우, 원격프로그래밍, 객체의 타입을 알수없는 경우에 사용
		
		
	}
}
===========================================================================================
//자료구조
메모리상에서 관리하는 여러 구현방법들
효율적인 자료구조가 성능 좋은 알고리즘의 기반이 된다.

1. 배열
선형으로 자료를 관리. 정해진 크기의 메모리를 먼저 할당받아 사용. (어느 위치에 있는걸 가져오는게 빠르다.) 4byte씩 a[2]에서 a[0]이 메모리주소가 10이라면 a[2]는 18 
jdk클래스: ArrayList, Vector
2. 연결리스트
선형으로 자료를 관리, 자료가 추가될때마다 메모리를 할당받고, 자료는 링크로 연결된다. (자료 + 링크) 로 구성, 수행속도가 데이터가 삭제,삽입이 배열보다 빠르다.(링크연결만수정), 배열은 넣고, 삭제 시에는 나머지애들이 다 밀리거나 땡겨져야하니까 느리다.
단, 가져오는거는 맨처음부터 찾아가야하기때문에 느리다.
3.스택(선형)
가장 나중에 입력된 자료가 가장먼저 출력되는 자료구조(LIFO)
4.큐(선형)
가장 먼저 입력된 자료가 가장 먼저 출력되는 자료구조(FIFO)
맨앞은 front(자료삭제되는부분=dequeue), 맨뒤는 rear(자료추가되는부분=enqueue)
5.트리(비선형)
부모,자식노드
이진트리는 부모노드에 자식노드가 두개 이하인 트리
힙은 꽉찬(pull)이진트리는 아니지만 complete이진트리이다. 왼쪽은 채워져있는형태
힙은 MaxHeap: 부모노드는 자식노드보다 항상 크거나 같은 값을 가지는 경우(root가 젤크다)
    MinHeap : 부모노드는 자식노드보다 항상 작거나 같은 값을 가지는 경우(root가 젤작다)

이진검색트리는 값이 중복되면 안된다. 힙은 중복되도 된다.
왼쪽자식노드는 부모노드보다 작은값, 오른쪽은 부모노드보다 큰값.
검색시 절반은 계속 날라간다.
즉, 23,10,28,15,7,22,22,56순으로 넣을 때는
23을 먼저넣고 10을 넣을 때 23보다 작으면 왼쪽자식노드에 배치 .... 22를 넣을 때 중복되니까 한번만
 
6.해싱 : 자료를 검색하기 위한 자료구조
key는 유일하고 이에대한 value를 쌍으로 저장
jdk클래스 : HashMap, Properties
들어가는 순서와상관없이 꺼냈을때는 내가 넣은 순서와상관없이 출력된다.
왜냐하면 해시함수로 정해진인덱스에 넣었기떄문에


==================================================================================================
//배열구현
package ch02;

public class MyArray {

	int[] intArr;   	//int array
	int count;  		//개수
		
	public int ARRAY_SIZE;
	public static final int ERROR_NUM = -999999999;
	
	public MyArray()// 그냥 생성시 기본 배열 사이즈 10
	{
		count = 0;
		ARRAY_SIZE = 10;
		intArr = new int[ARRAY_SIZE];
	}
	
	public MyArray(int size) //사이즈 정할 때
	{
		count = 0;
		ARRAY_SIZE = size;
		intArr = new int[size];
	}
	
	public void addElement(int num)
	{
		if(count >= ARRAY_SIZE){ //꽉찼을때
			System.out.println("not enough memory");
			return;
		}
		//꽉안찼을때
		intArr[count++] = num;
				
	}

	public void insertElement(int position, int num) //position은 0부터
	{
		int i;
		
		if(count >= ARRAY_SIZE){  //꽉 찬 경우
			System.out.println("not enough memory");
			return;
		}
		
		if(position < 0 || position > count ){  //index error
			System.out.println("insert Error");
			return;
		}
		
		for( i = count-1; i >= position ; i--){ //뒤에서부터 한칸씩밀고 넣어야한다.(덮어쓰기때문에)
			intArr[i+1]  = intArr[i];        // 하나씩 이동
		}
		
		intArr[position] = num;
		count++;
	}
	
	public int removeElement(int position)
	{
		int ret = ERROR_NUM;
		
		if( isEmpty() ){
			System.out.println("There is no element");
			return ret;
		}
		
		if(position < 0 || position >= count ){  //index error, 포지션이 카운트랑같거나 크면(카운트는 인덱스 + 1이니까)
			System.out.println("remove Error");
			return ret;
		}
		
		ret = intArr[position];
		
		for(int i = position; i<count -1; i++ ) //배열안의 개수 -1 까지이다. 배열의 길이가 아니라.
		{
			intArr[i] = intArr[i+1];
		}
		count--;
		return ret;
	}
	
	public int getSize()
	{
		return count;
	}
	
	public boolean isEmpty()
	{
		if(count == 0){
			return true;
		}
		else return false;
	}
	
	public int getElement(int position)
	{
		if(position < 0 || position > count-1){
			System.out.println("검색 위치 오류. 현재 리스트의 개수는 " + count +"개 입니다.");
			return ERROR_NUM;
		}
		return intArr[position];
	}
	
	public void printAll()
	{
		if(count == 0){
			System.out.println("출력할 내용이 없습니다.");
			return;
		}
			
		for(int i=0; i<count; i++){
			System.out.println(intArr[i]);
		}
		
	}
	
	public void removeAll()
	{
		for(int i=0; i<count; i++){
			intArr[i] = 0;
		}
		count = 0;
	}
}
----------------
package ch02;

public class MyArrayTest {

	public static void main(String[] args) {

		MyArray array = new MyArray();
		array.addElement(10);
		array.addElement(20);
		array.addElement(30);
		array.insertElement(1, 50);
		array.printAll();
		
		System.out.println("===============");
		array.removeElement(1);
		array.printAll();
		System.out.println("===============");
			
		array.addElement(70);
		array.printAll();
		System.out.println("===============");
		array.removeElement(1);
		array.printAll();
		
		System.out.println("===============");
		System.out.println(array.getElement(2));
		
	}
}
================================================================
//연결리스트
package ch03;

public class MyListNode {

	private String data;       // 자료
	public MyListNode next;    // 다음 노드를 가리키는 링크
	
	public MyListNode(){
		data = null;
		next = null;
	}
	
	public MyListNode(String data){
		this.data = data;
		this.next = null;
	}
	
	public MyListNode(String data, MyListNode link){
		this.data = data;
		this.next = link;
	}
	
	public String getData(){
		return data;
	}
}
--------------
package ch03;

public class MyLinkedList {

	private MyListNode head;
	int count;
	
	public MyLinkedList()
	{
		head = null;
		count = 0;
	}
	
	public MyListNode addElement( String data ) //앞이나 뒤에 추가
	{
		
		MyListNode newNode; //새로 들어갈 애
		if(head == null){  //맨 처음일때는 링크 필요없이 데이터만 있으면 되니까
			newNode = new MyListNode(data); //들어오는 데이터로 노드생성
			head = newNode; //헤드가 첫번쨰노드가된다.
		}
		else{ //첫번째노드가 아닌경우(맨뒤인경우이다) 찾아가는 과정은 head부터 찾아가면된다. 그리고 맨마지막 노드는 가리키는 게 null이다.
			newNode = new MyListNode(data); //next = null(마지막에 넣을거기 떄문에)
			MyListNode temp = head; //헤드부터 돌수있게끔(헤드를 받아와서)
			while(temp.next != null) {//맨 뒤로 갈떄까지
				temp = temp.next;
			}
			temp.next = newNode;
		}
		count++;
		return newNode;
	}
	
	public MyListNode insertElement(int position, String data )
	{
		int i;
		MyListNode tempNode = head;
		MyListNode newNode = new MyListNode(data);
		
		if(position < 0 || position > count ){
			System.out.println("추가 할 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 앞으로 들어가는 경우
			newNode.next = head; //newNode는 맨앞에 insert하려는 노드이다. 맨앞에 넣기때문에 head를 다음요소로 가리킨다.
			head = newNode; //새로들어온게 head로 들어가고
		}
		else{
			MyListNode preNode = null;	 //중간에들어가는경우
			for(i=0; i<position; i++){
				preNode = tempNode;
				tempNode = tempNode.next;
				
			}
			newNode.next = preNode.next;
			preNode.next = newNode;
		}
		count++;
		return newNode;
	}
	
	public MyListNode removeElement(int position) //위치로 삭제
	{
		int i;
		MyListNode tempNode = head;
		MyListNode preNode = null;
		
		if(position >= count ){
			System.out.println("삭제 할 위치 오류입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 앞을 삭제하면 다음요소가 헤드가된다.
			head = tempNode.next;
		}
		else{ //중간에서 뺴는경우
			MyListNode preNode = null;	
			for(i=0; i<position; i++){ 
				preNode = tempNode;
				tempNode = tempNode.next; //for문돌리면 tempNode가 내가 지우는 노드가 된다.
			}
			preNode.next = tempNode.next;
		}
		count--;
		System.out.println(position + "번째 항목 삭제되었습니다.");
		
		return tempNode;
	}
	
	public String getElement(int position)
	{
		int i;
		MyListNode tempNode = head;
		
		if(position >= count ){
			System.out.println("검색 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return new String("error");
		}
		
		if(position == 0){  //맨 인 경우

			return head.getData();
		}
		
		for(i=0; i<position; i++){
			tempNode = tempNode.next;
			
		}
		return tempNode.getData();
	}

	public MyListNode getNode(int position)
	{
		int i;
		MyListNode tempNode = head;
		
		if(position >= count ){
			System.out.println("검색 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 인 경우

			return head;
		}
		
		for(i=0; i<position; i++){
			tempNode = tempNode.next;
			
		}
		return tempNode;
	}

	public void removeAll()
	{
		head = null;
		count = 0;
		
	}
	
	public int getSize()
	{
		return count;
	}
	
	public void printAll()
	{
		if(count == 0){
			System.out.println("출력할 내용이 없습니다.");
			return;
		}
		
		MyListNode temp = head;
		while(temp != null){
			System.out.print(temp.getData());
			temp = temp.next;
			if(temp!=null){
				System.out.print("->");
			}
		}
		System.out.println("");
	}
	
	public boolean isEmpty()
	{
		if(head == null) return true;
		else return false;
	}
	
}
-------------------
package ch03;

public class MyLinkedListTest {

	public static void main(String[] args) {

		MyLinkedList list = new MyLinkedList();
		list.addElement("A");
		list.addElement("B");
		list.addElement("C");
		list.printAll();
		list.insertElement(3, "D"); //4번쨰에 D넣어라
		list.printAll();
		list.removeElement(0); //head지우기
		list.printAll();
		list.removeElement(1);
		list.printAll();
						
		list.insertElement(0, "A-1");
		list.printAll();
		System.out.println(list.getSize());
		
		list.removeElement(0);
		list.printAll();
		System.out.println(list.getSize());
		
		list.removeAll();
		list.printAll();
		list.addElement("A");
		list.printAll();
		System.out.println(list.getElement(0));
		list.removeElement(0);
	}
}
=========================================================================
//스택
package ch02;

public class MyArray {

	int[] intArr;   	//int array
	int count;  		//개수
		
	public int ARRAY_SIZE;
	public static final int ERROR_NUM = -999999999;
	
	public MyArray()// 그냥 생성시 기본 배열 사이즈 10
	{
		count = 0;
		ARRAY_SIZE = 10;
		intArr = new int[ARRAY_SIZE];
	}
	
	public MyArray(int size) //사이즈 정할 때
	{
		count = 0;
		ARRAY_SIZE = size;
		intArr = new int[size];
	}
	
	public void addElement(int num)
	{
		if(count >= ARRAY_SIZE){ //꽉찼을때
			System.out.println("not enough memory");
			return;
		}
		//꽉안찼을때
		intArr[count++] = num;
				
	}

	public void insertElement(int position, int num) //position은 0부터
	{
		int i;
		
		if(count >= ARRAY_SIZE){  //꽉 찬 경우
			System.out.println("not enough memory");
			return;
		}
		
		if(position < 0 || position > count ){  //index error
			System.out.println("insert Error");
			return;
		}
		
		for( i = count-1; i >= position ; i--){ //뒤에서부터 한칸씩밀고 넣어야한다.(덮어쓰기때문에)
			intArr[i+1]  = intArr[i];        // 하나씩 이동
		}
		
		intArr[position] = num;
		count++;
	}
	
	public int removeElement(int position)
	{
		int ret = ERROR_NUM;
		
		if( isEmpty() ){
			System.out.println("There is no element");
			return ret;
		}
		
		if(position < 0 || position >= count ){  //index error, 포지션이 카운트랑같거나 크면(카운트는 인덱스 + 1이니까)
			System.out.println("remove Error");
			return ret;
		}
		
		ret = intArr[position];
		
		for(int i = position; i<count -1; i++ ) //배열안의 개수 -1 까지이다. 배열의 길이가 아니라.
		{
			intArr[i] = intArr[i+1];
		}
		count--;
		return ret;
	}
	
	public int getSize()
	{
		return count;
	}
	
	public boolean isEmpty()
	{
		if(count == 0){
			return true;
		}
		else return false;
	}
	
	public int getElement(int position)
	{
		if(position < 0 || position > count-1){
			System.out.println("검색 위치 오류. 현재 리스트의 개수는 " + count +"개 입니다.");
			return ERROR_NUM;
		}
		return intArr[position];
	}
	
	public void printAll()
	{
		if(count == 0){
			System.out.println("출력할 내용이 없습니다.");
			return;
		}
			
		for(int i=0; i<count; i++){
			System.out.println(intArr[i]);
		}
		
	}
	
	public void removeAll()
	{
		for(int i=0; i<count; i++){
			intArr[i] = 0;
		}
		count = 0;
	}
}
--------------
package ch04;

import ch02.MyArray;

public class MyArrayStack {

	int top;
	MyArray arrayStack; 
	
	public MyArrayStack()
	{
		top = 0;
		arrayStack = new MyArray();
	}
	
	public MyArrayStack(int size) //사이즈만큼
	{
		arrayStack = new MyArray(size);
	}
	
	public void push(int data)
	{
		if(isFull()){ //아래에 isFull함수가있다.
			System.out.println("stack is full");
			return;
		}
		
		arrayStack.addElement(data); //배열의 맨뒤로 쭉쭉 들어간다.
		top++;
	}
	
	public int pop()
	{
		if (top == 0){
			System.out.println("stack is empty");
			return MyArray.ERROR_NUM;
		}
		return arrayStack.removeElement(--top);//탑1을 지울려면 removelemnet는 인덱스요소로 지우니까 --top으로 (0)번쨰
		
	}
	
	public int peek()
	{
		if (top == 0){
			System.out.println("stack is empty");
			return MyArray.ERROR_NUM;
		}
		return arrayStack.getElement(top-1);
	}
	
	public int getSize()
	{
		return top;
	}
	
	public boolean isFull()
	{
		if(top == arrayStack.ARRAY_SIZE){ //top이 개수와같다.
			return true;
		}
		else return false;
	}
	
	public boolean isEmpty()
	{
		if (top == 0){
			return true;
		}
		else return false;
	}
	
	public void printAll()
	{
		arrayStack.printAll();
	}
}
----------------
package ch04;

public class MyArrayStackTest {

	public static void main(String[] args) {

		MyArrayStack stack = new MyArrayStack(3);
		
		stack.push(10);
		stack.push(20);
		stack.push(30);
		stack.push(40);
		
		stack.printAll();
		
		System.out.println("top element is " + stack.pop());
		stack.printAll();
		System.out.println("stack size is " + stack.getSize());
	}
}
============================================================================
//큐 구현
package ch03;

public class MyListNode {

	private String data;       // 자료
	public MyListNode next;    // 다음 노드를 가리키는 링크
	
	public MyListNode(){
		data = null;
		next = null;
	}
	
	public MyListNode(String data){
		this.data = data;
		this.next = null;
	}
	
	public MyListNode(String data, MyListNode link){
		this.data = data;
		this.next = link;
	}
	
	public String getData(){
		return data;
	}
}
--------------
package ch03;

public class MyLinkedList {

	private MyListNode head;
	int count;
	
	public MyLinkedList()
	{
		head = null;
		count = 0;
	}
	
	public MyListNode addElement( String data ) //앞이나 뒤에 추가
	{
		
		MyListNode newNode; //새로 들어갈 애
		if(head == null){  //맨 처음일때는 링크 필요없이 데이터만 있으면 되니까
			newNode = new MyListNode(data); //들어오는 데이터로 노드생성
			head = newNode; //헤드가 첫번쨰노드가된다.
		}
		else{ //첫번째노드가 아닌경우(맨뒤인경우이다) 찾아가는 과정은 head부터 찾아가면된다. 그리고 맨마지막 노드는 가리키는 게 null이다.
			newNode = new MyListNode(data); //next = null(마지막에 넣을거기 떄문에)
			MyListNode temp = head; //헤드부터 돌수있게끔(헤드를 받아와서)
			while(temp.next != null) {//맨 뒤로 갈떄까지
				temp = temp.next;
			}
			temp.next = newNode;
		}
		count++;
		return newNode;
	}
	
	public MyListNode insertElement(int position, String data )
	{
		int i;
		MyListNode tempNode = head;
		MyListNode newNode = new MyListNode(data);
		
		if(position < 0 || position > count ){
			System.out.println("추가 할 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 앞으로 들어가는 경우
			newNode.next = head; //newNode는 맨앞에 insert하려는 노드이다. 맨앞에 넣기때문에 head를 다음요소로 가리킨다.
			head = newNode; //새로들어온게 head로 들어가고
		}
		else{
			MyListNode preNode = null;	 //중간에들어가는경우
			for(i=0; i<position; i++){
				preNode = tempNode;
				tempNode = tempNode.next;
				
			}
			newNode.next = preNode.next;
			preNode.next = newNode;
		}
		count++;
		return newNode;
	}
	
	public MyListNode removeElement(int position) //위치로 삭제
	{
		int i;
		MyListNode tempNode = head;
		MyListNode preNode = null;
		
		if(position >= count ){
			System.out.println("삭제 할 위치 오류입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 앞을 삭제하면 다음요소가 헤드가된다.
			head = tempNode.next;
		}
		else{ //중간에서 뺴는경우
			MyListNode preNode = null;	
			for(i=0; i<position; i++){ 
				preNode = tempNode;
				tempNode = tempNode.next; //for문돌리면 tempNode가 내가 지우는 노드가 된다.
			}
			preNode.next = tempNode.next;
		}
		count--;
		System.out.println(position + "번째 항목 삭제되었습니다.");
		
		return tempNode;
	}
	
	public String getElement(int position)
	{
		int i;
		MyListNode tempNode = head;
		
		if(position >= count ){
			System.out.println("검색 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return new String("error");
		}
		
		if(position == 0){  //맨 인 경우

			return head.getData();
		}
		
		for(i=0; i<position; i++){
			tempNode = tempNode.next;
			
		}
		return tempNode.getData();
	}

	public MyListNode getNode(int position)
	{
		int i;
		MyListNode tempNode = head;
		
		if(position >= count ){
			System.out.println("검색 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 인 경우

			return head;
		}
		
		for(i=0; i<position; i++){
			tempNode = tempNode.next;
			
		}
		return tempNode;
	}

	public void removeAll()
	{
		head = null;
		count = 0;
		
	}
	
	public int getSize()
	{
		return count;
	}
	
	public void printAll()
	{
		if(count == 0){
			System.out.println("출력할 내용이 없습니다.");
			return;
		}
		
		MyListNode temp = head;
		while(temp != null){
			System.out.print(temp.getData());
			temp = temp.next;
			if(temp!=null){
				System.out.print("->");
			}
		}
		System.out.println("");
	}
	
	public boolean isEmpty()
	{
		if(head == null) return true;
		else return false;
	}
	
}
--------------
package ch05;

import ch03.MyLinkedList;
import ch03.MyListNode;

interface IQueue{
	public void enQueue(String data);
	public String deQueue();
	public void printAll();
}

public class MyListQueue extends MyLinkedList implements IQueue{

	MyListNode front;
	MyListNode rear;
		
	
	public MyListQueue()
	{
		front = null;
		rear = null;
	}
	
	public void enQueue(String data)
	{
		MyListNode newNode;
		if(isEmpty())  //처음 항목
		{
			newNode = addElement(data); //맨뒤로 add되니까
			front = newNode;
			rear = newNode;
		}
		else
		{
			newNode = addElement(data);
			rear = newNode;
		}
		System.out.println(newNode.getData() + " added");
	}
	
	public String deQueue()
	{
		if(isEmpty()){
			System.out.println("Queue is Empty");
			return null;
		}
		String data = front.getData(); //맨앞에서 지워야하니까
		front = front.next; //front는 이제 front.next를 가리키면된다.
		if( front == null ){  // 근데 front가 null이면 마지막 항목이라는 소리이다.
			rear = null;
		}
		return data;
	}
	
	public void printAll()
	{
		if(isEmpty()){
			System.out.println("Queue is Empty");
			return;
		}
		MyListNode temp = front; //맨앞노드를 잠시 temp에 저장
		while(temp!= null){ 
			System.out.print(temp.getData() + ",");
			temp = temp.next; //front가 next를 가리키는 곳을 temp에 다시저장 ... 반복
		}
		System.out.println();
	}
}
------------------
package ch05;

public class MyListQueueTest {

	public static void main(String[] args) {

		MyListQueue listQueue = new MyListQueue();
		listQueue.enQueue("A");
		listQueue.enQueue("B");
		listQueue.enQueue("C");
		listQueue.enQueue("D");
		listQueue.enQueue("E");
		
		System.out.println(listQueue.deQueue());
		listQueue.printAll();
	}
}
=================================================================
//무엇이든 담을 수 있는 제레닉(일반화) 프로그래밍
여러 자료형이 쓰일 수 있는 변수일때 쓰인다. 자료형마다 클래스를 만들기에는 오버헤드라서...

package ch06;

public class Plastic {
	public String toString() {
		return "재료는 Plastic 입니다.";
	}
}
-----------
package ch06;

public class Powder {
	public String toString() {
		return "재료는 Powder 입니다.";
	}
}
-------------
package ch06; //제네릭 타입을 안쓰면 이렇게 powder,material 자료형마다 클래스를 만들어줘야한다

public class ThreeDPrinter1 {
	private Powder material;
		
	public Powder getMaterial() {
		return material;
	}

	public void setMaterial(Powder material) {
		this.material = material;
	}

}
---------------
package ch06;

public class ThreeDPrinter2 {
	private Plastic material;
		
	public Plastic getMaterial() {
		return material;
	}

	public void setMaterial(Plastic material) {
		this.material = material;
	}

}
----------------
package ch06; 

public class ThreeDPrinter3 {
	private Object material; //우리는 제네릭을 쓰지않으면 이렇게 Object를 써야한다.(변수타입을 다 받기위해서)
		
	public Object getMaterial() {
		return material;
	}

	public void setMaterial(Object material) {
		this.material = material;
	}

}
------------------
package ch06;

public class ThreeDPrinterTest {
	public static void main(String[] args) {
		Powder powder = new Powder();
		ThreeDPrinter3 printer = new ThreeDPrinter3();
		
		printer.setMaterial(powder); //object로 받는다. printer는
		
		Powder p = (Powder)printer.getMaterial(); //이렇게 오브젝트로 쓰면 다운캐스팅을 해줘야한다. 이게 번거러우니 제네릭타입이 나온것이다.
	}
}
=====================================================================================
package ch06;

public class GenericPrinter<T> {
	private T material;
	
	public void setMaterial(T material) {
		this.material = material;
	}
	
	public T getMaterial() {
		return material;
	}
	
	public String toString(){
		return material.toString();
	}
}
--------------------
package ch06;

public class GenericPrinterTest {

	public static void main(String[] args) {

		//Powder powder = new Powder();
		GenericPrinter<Powder> powderPrinter = new GenericPrinter<Powder>(); //GenericPrinter에서 <T>,T가 알아서 powder로 바뀐다.
		//GenericPrinter<Powder> powderPrinter = new GenericPrinter<>(); <powder>생략가능하다. 
		powderPrinter.setMaterial(new Powder());
		System.out.println(powderPrinter);
		Powder p = powderPrinter.getMaterial(); //다운캐스팅안해도 된다.
		
		GenericPrinter<Plastic> plasticPrinter = new GenericPrinter<Plastic>();
		plasticPrinter.setMaterial(new Plastic());
		System.out.println(plasticPrinter);
		
	}

}
==================================================================================================
//하지만, 제네릭을 쓰면 객체와 관계없는 것까지 타입으로 받을 수 있기때문에 문제가된다. 
//그래서 <T extends 클래스> 를 사용한다
//T자료형의 범위를 제한 할 수 있다.
//상속을 받지 않는 경우 T는 Object로 변환되어 Object클래스가 기본으로 제공하는 메소드만 사용가능

T에 무작위 클래스가 들어갈 수 없게 Material 클래스를 상속받은 클래스로 한정
			Material
		   /       \
		Powder    Plastic

=================================================================
package ch07;

public abstract class Material {
	
	public abstract void doPrinting(); //공통
}
-------------
package ch07;

public class Plastic extends Material{
	@Override
	public void doPrinting() {
		System.out.println("Plastic 재료로 출력합니다");
	}
	
	public String toString() {
		return "재료는 Plastic 입니다";
	}
}
-----------------
package ch07;

public class Powder extends Material{
	@Override
	public void doPrinting() {
		System.out.println("Powder 재료로 출력합니다");
	}
	
	public String toString() {
		return "재료는 Powder 입니다";
	}
}
------------------
package ch07;

public class GenericPrinter<T extends Material> { //Material을 상속받은 아이만 가능
	private T material;
	
	public void setMaterial(T material) {
		this.material = material;
	}
	
	public T getMaterial() {
		return material;
	}
	
	public String toString(){
		return material.toString();
	}
	
	public void printing() {
		material.doPrinting();
	}
}
-----------------------
package ch07;

public class GenericPrinterTest {

	public static void main(String[] args) {
		
		//Powder, Plastic은 Material을 상속받았기 때문에 GenericPrinter를 Class 생성가능
		GenericPrinter<Powder> powderPrinter = new GenericPrinter<Powder>();
		powderPrinter.setMaterial(new Powder());
		Powder powder = powderPrinter.getMaterial(); // 형변환 하지 않음
		System.out.println(powderPrinter);
		
		GenericPrinter<Plastic> plasticPrinter = new GenericPrinter<Plastic>();
		plasticPrinter.setMaterial(new Plastic());
		Plastic plastic = plasticPrinter.getMaterial(); // 형변환 하지 않음
		System.out.println(plasticPrinter);
		
	/*	GenericPrinter powderPrinter2 = new GenericPrinter(); //자료형을 안쓸수도있다.
		powderPrinter2.setMaterial(new Powder());
		Powder powder = (Powder)powderPrinter.getMaterial();
		System.out.println(powderPrinter);
		*/
		//GenericPrinter<Water> printer = new GenericPrinter<Water>();	이렇게쓸수는없다. 자식이 아니라서(extends의 장점)
	}
}
------------------------
package ch07;

public class GenericPrinterTest2 {

	public static void main(String[] args) {

		GenericPrinter<Powder> powderPrinter = new GenericPrinter<Powder>();
		powderPrinter.setMaterial(new Powder());
		powderPrinter.printing();
		
		GenericPrinter<Plastic> plasticPrinter = new GenericPrinter<Plastic>();
		plasticPrinter.setMaterial(new Plastic());
		plasticPrinter.printing();
	}
}
============================================================
//제네릭 메서드
//너비구하기
package ch08;

public class Point<T, V> { //Integer, double일수있으니
	
	T x;
	V y;
	
	Point(T x, V y){
		this.x = x;
		this.y = y;
	}
	
	public  T getX() {
			return x;
	}

	public V getY() {
		return y;
    }
}
----------------
package ch08;

public class GenericMethod {

	public static <T, V> double makeRectangle(Point<T, V> p1, Point<T, V> p2) {
		double left = ((Number)p1.getX()).doubleValue();
		double right =((Number)p2.getX()).doubleValue();
		double top = ((Number)p1.getY()).doubleValue();
		double bottom = ((Number)p2.getY()).doubleValue();
		
		double width = right - left; //거리 
		double height = bottom - top; //거리
		
		return width * height; //double로 반환
	}
	
	public static void main(String[] args) {
		
		Point<Integer, Double> p1 = new Point<Integer, Double>(0, 0.0); //한점
		Point<Integer, Double> p2 = new Point<>(10, 10.0); //자료형 생략가능 <>
		
		//static이라 클래스로 접근(굳이 함수를 static으로 선언할 필요는없다)
		double rect = GenericMethod.<Integer, Double>makeRectangle(p1, p2);
		System.out.println("두 점으로 만들어진 사각형의 넓이는 " + rect + "입니다.");
	}
}
//출력결과 : 100.0
===============================================================
//자바에서 제공되는 자료구조 구현 클래스들 - 컬렉션 프레임 워크
//java.util 패키지에 구현되어있다.

//Collection인터페이스 하위에 List, Set 인터페이스(중복허용x)가 있다.

package ch10;

public class Member {
	
	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}
}
------------------
package ch10;

import java.util.ArrayList;  // 사용할 클래스 import
import java.util.Iterator;

public class MemberArrayList {

	private ArrayList<Member> arrayList;  // ArrayList 선언 

	public MemberArrayList(){
		arrayList = new ArrayList<Member>();  //멤버로 선언한 ArrayList 생성
	}
	
	public void addMember(Member member){  //ArrayList 에 멤버 추가
		arrayList.add(member);
	}
	
	public boolean removeMember(int memberId){  // 멤버 아이디를 매개변수로, 삭제 여부를 반환
		
		//Iterator안하면 이렇게해야된다.
	/*	for(int i =0; i<arrayList.size(); i++){ // 해당 아이디를 가진 멤버를 ArrayList에서 찾음
			Member member = arrayList.get(i); //하나씩 꺼낸다.
			int tempId = member.getMemberId();
			if(tempId == memberId){            // 멤버아이디가 매개변수와 일치하면 
				arrayList.remove(i);           // 해당 멤버를 삭제
				return true;                   // true 반환
			}
		}
		*/
		
		Iterator<Member> ir = arrayList.iterator(); //<Member>라고안하면 알아서 Object로 된다
		while(ir.hasNext()) {
			Member member = ir.next();  //다음꺼를 반환후 그자리에 이동
			int tempId = member.getMemberId();
			if(tempId == memberId){            // 멤버아이디가 매개변수와 일치하면 
				arrayList.remove(member);           // 해당 멤버를 삭제
				return true;                   // true 반환
			}
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");  //for 가 끝날때 까지 return 이 안된경우
		return false;                   
	}
	
	public void showAllMember(){
		for(Member member : arrayList){
			System.out.println(member);
		}
		System.out.println();
	}
}
-------------------
package ch10;

public class MemberArrayListTest {

	public static void main(String[] args) {

		MemberArrayList memberArrayList = new MemberArrayList();
		
		Member memberLee = new Member(1001, "이순신");
		Member memberKim = new Member(1002, "김유신");
		Member memberKang = new Member(1003, "강감찬");
		Member memberHong = new Member(1004, "홍길동");
		
		memberArrayList.addMember(memberLee);
		memberArrayList.addMember(memberKim);
		memberArrayList.addMember(memberKang);
		memberArrayList.addMember(memberHong);
		
		memberArrayList.showAllMember();
		
		memberArrayList.removeMember(memberHong.getMemberId()); //한명지우기
		memberArrayList.showAllMember();
	}
}
==================================================================
//Collection요소를 순회하는 Iterator
순서가있는 List인터페이스는 Iterator를 사용하지않고 get(i)를 사용, Iterator써도됨
Set경우에는 get이 없으므로 Iterator를 쓴다.
===================================================================
//중복되지 않게 자료를 관리하는 Set 인터페이스를 구현한 클래스와 그 활용
HashSet 클래스
- Set인터페이스를 구현한 클래스
- 멤버의 중복여부를 체크하기 위해 인스턴스의 동일성을 확인해야함.
- .add될때 equals, hashCode 를 확인한다.

package ch12;

import java.util.HashSet;

public class HashSetTest {

	public static void main(String[] args) {

		HashSet<String> hashSet = new HashSet<String>();
		hashSet.add(new String("김유신"));
		hashSet.add(new String("이순신"));
		hashSet.add(new String("홍연의"));
		hashSet.add(new String("강감찬"));
		hashSet.add(new String("강감찬"));
		
		System.out.println(hashSet); //중복은 한번만출력
	}
}
=====================================================================

package ch12;

public class Member {
	
	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}

	@Override
	public int hashCode() {
		return memberId;
	}

	@Override
	public boolean equals(Object obj) {
		if( obj instanceof Member){
			Member member = (Member)obj;
			if( this.memberId == member.memberId )
				return true;
			else 
				return false;
		}
		return false;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}
}
---------------
package ch12;

import java.util.HashSet;
import java.util.Iterator;


public class MemberHashSet {
	private HashSet<Member> hashSet;

	public MemberHashSet(){
		hashSet = new HashSet<Member>();
	}
	
	public void addMember(Member member){
		hashSet.add(member);
	}
	
	public boolean removeMember(int memberId){

		Iterator<Member> ir = hashSet.iterator();
		
		while( ir.hasNext()){
			Member member = ir.next();
			int tempId = member.getMemberId();
			if( tempId == memberId){
				hashSet.remove(member);
				return true;
			}
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");
		return false;
	}
	
	public void showAllMember(){
		for(Member member : hashSet){
			System.out.println(member);
		}
		System.out.println();
	}
}
-------------------
package ch12;

public class MemberHashSetTest {

	public static void main(String[] args) {

		MemberHashSet memberHashSet = new MemberHashSet();
		
		Member memberLee = new Member(1001, "이순신");
		Member memberKim = new Member(1002, "김유신");
		Member memberKang = new Member(1003, "강감찬");
		
		
		memberHashSet.addMember(memberLee);
		memberHashSet.addMember(memberKim);
		memberHashSet.addMember(memberKang);
		memberHashSet.showAllMember();
		
		Member memberHong = new Member(1003, "홍길동");  //1003 아이디 중복(equals, hashcode안쓰면 그냥 들어간다) 
		memberHashSet.addMember(memberHong);
		memberHashSet.showAllMember();
	}
}
===========================================================================
//객체의 정렬에 사용하는 클래스 TreeSet
//Set인터페이스를 구현하여 중복을 허용하지않고, 오름차순이나 내림차순으로 객체를 정렬할수있다.
//내부적으로 이진검색트리로 구현된다.
package ch13;

import java.util.TreeSet;

public class TreeSetTest {

	public static void main(String[] args) {

		TreeSet<String> treeSet = new TreeSet<String>();
		treeSet.add("홍길동");
		treeSet.add("강감찬");
		treeSet.add("이순신");
		
		for(String str : treeSet) {
			System.out.println(str); //정렬된다.강감찬, 이순신, 홍길동 TreeSet에서 구현한 Comparable에서 String비교할수있게해놓아서
		}
	}
}
=============================================================================

package ch13;

public class Member implements Comparable<Member>{ //인터페이스추가 -> 구현해야하는 메서드가 compareTo

	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}

	@Override
	public int hashCode() {
		return memberId;
	}

	@Override
	public boolean equals(Object obj) {
		if( obj instanceof Member){
			Member member = (Member)obj;
			if( this.memberId == member.memberId )
				return true;
			else 
				return false;
		}
		return false;
	}

	@Override
	public int compareTo(Member member) {
		
		//return (this.memberId - member.memberId);   //오름차순
		return (this.memberId - member.memberId) *  (-1);   //내림 차순
		
		//left는 더 작은값, right는 더 큰값으로 해서 오름차순으로 출력
		//if(this.memberId > member.memberId)
		//	return 1;
		//else if(this.memberId < member.memberId)
		//	return -1;
		//else 
		//	return 0;
	}
}
--------------
package ch13;

import java.util.Iterator;
import java.util.TreeSet;



public class MemberTreeSet {

	private TreeSet<Member> treeSet;

	public MemberTreeSet(){
		treeSet = new TreeSet<Member>();
	}
	
	public void addMember(Member member){
		treeSet.add(member);
	}
	
	public boolean removeMember(int memberId){
		
		Iterator<Member> ir = treeSet.iterator();
		
		while( ir.hasNext()){
			Member member = ir.next();
			int tempId = member.getMemberId();
			if( tempId == memberId){
				treeSet.remove(member);
				return true;
			}
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");
		return false;
	}
	
	public void showAllMember(){
		for(Member member : treeSet){
			System.out.println(member);
		}
		System.out.println();
	}
}
--------------------
package ch13;

public class MemberTreeSetTest {

	public static void main(String[] args) {
		
		
		MemberTreeSet memberTreeSet = new MemberTreeSet();
		
		
		Member memberKim = new Member(1003, "김유신");
		Member memberLee = new Member(1001, "이순신");
		Member memberKang = new Member(1002, "강감찬");
		
		
		memberTreeSet.addMember(memberKim); //add할때마다 비교할수없기때문에 에러가난다. Comparable(compareTo), compartor(comapre)둘중에 하나를 구현해야한다
		memberTreeSet.addMember(memberLee);
		memberTreeSet.addMember(memberKang);
		memberTreeSet.showAllMember();
		
	}
}
=========================================================================
//Comparator로 구현
package ch13;

public class Member implements Comparator<Member>{ //인터페이스추가 -> 구현해야하는 메서드가 compareTo

	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member() {}

	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}

	@Override
	public int hashCode() {
		return memberId;
	}

	@Override
	public boolean equals(Object obj) {
		if( obj instanceof Member){
			Member member = (Member)obj;
			if( this.memberId == member.memberId )
				return true;
			else 
				return false;
		}
		return false;
	}

	@Override 
	public int compare(Member member1, Member member2) { //인자2개
		return (member1.memberId - member2.memberId); //앞이 크면 양수니까 오름차순으로 정렬
	}
}
--------------
package ch13;

import java.util.Iterator;
import java.util.TreeSet;



public class MemberTreeSet {

	private TreeSet<Member> treeSet;

	public MemberTreeSet(){
		treeSet = new TreeSet<Member>(new Member()); //comparator를 쓸때는 comapre가 구현된 클래스를 지정해줘야한다. new Member()이렇게하면 기본생성자도 만들어줘야한다
	}
	
	public void addMember(Member member){
		treeSet.add(member);
	}
	
	public boolean removeMember(int memberId){
		
		Iterator<Member> ir = treeSet.iterator();
		
		while( ir.hasNext()){
			Member member = ir.next();
			int tempId = member.getMemberId();
			if( tempId == memberId){
				treeSet.remove(member);
				return true;
			}
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");
		return false;
	}
	
	public void showAllMember(){
		for(Member member : treeSet){
			System.out.println(member);
		}
		System.out.println();
	}
}
--------------------
package ch13;

public class MemberTreeSetTest {

	public static void main(String[] args) {
		
		
		MemberTreeSet memberTreeSet = new MemberTreeSet();
		
		
		Member memberKim = new Member(1003, "김유신");
		Member memberLee = new Member(1001, "이순신");
		Member memberKang = new Member(1002, "강감찬");
		
		
		memberTreeSet.addMember(memberKim); //add할때마다 비교할수없기때문에 에러가난다. Comparable, compareTo둘중에 하나를 구현해야한다
		memberTreeSet.addMember(memberLee);
		memberTreeSet.addMember(memberKang);
		memberTreeSet.showAllMember();
		
	}
}
=================================================================
//Comparator은 임 Comparable에서 구현되어있는걸 다시 정의하고싶을 떄 쓴다.
//이미 Comparable에서 String이 오름차순으로 구현되어있는데 나는 String을 내림차순으로 구현하고 싶으면 Comparator를 통해 가능
package ch13;

import java.util.Comparator;
import java.util.Set;
import java.util.TreeSet;

class MyCompare implements Comparator<String>{

	@Override
	public int compare(String s1, String s2) {
		return (s1.compareTo(s2)) *-1 ; //내림차순, 원래 앞이 크면 양수이다.
	}
}

public class ComparatorTest {
	
	public static void main(String[] args) {
		
		Set<String> set = new TreeSet<String>(new MyCompare()); //비교하는 방식을 새로만듬
		set.add("aaa");
		set.add("ccc");
		set.add("bbb");
				
		System.out.println(set); //ccc bbb aaa
	}
}
================================================================
//comapartor로 memberName으로 정렬
package ch13;

import java.util.Comparator;

public class Member implements Comparator<Member>{

	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member() {}
	
	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}

	@Override
	public int hashCode() {
		return memberId;
	}

	@Override
	public boolean equals(Object obj) {
		if( obj instanceof Member){
			Member member = (Member)obj;
			if( this.memberId == member.memberId )
				return true;
			else 
				return false;
		}
		return false;
	}

//	@Override
//	public int compareTo(Member member) {
//		
//		//return (this.memberId - member.memberId);   //오름차순
//		return (this.memberId - member.memberId) *  (-1);   //내림 차순
//	}

	@Override
	public int compare(Member arg0, Member arg1) {
		return (arg0.memberName.compareTo(arg1.memberName)) *-1 ; //내림차순, 원래 앞이 크면 양수이다.
	}
}
--------------
package ch13;

import java.util.Iterator;
import java.util.TreeSet;



public class MemberTreeSet {

	private TreeSet<Member> treeSet;

	public MemberTreeSet(){
		treeSet = new TreeSet<Member>(new Member());
	}
	
	public void addMember(Member member){
		treeSet.add(member);
	}
	
	public boolean removeMember(int memberId){
		
		Iterator<Member> ir = treeSet.iterator();
		
		while( ir.hasNext()){
			Member member = ir.next();
			int tempId = member.getMemberId();
			if( tempId == memberId){
				treeSet.remove(member);
				return true;
			}
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");
		return false;
	}
	
	public void showAllMember(){
		for(Member member : treeSet){
			System.out.println(member);
		}
		System.out.println();
	}
}
-----------------
package ch13;

public class MemberTreeSetTest {

	public static void main(String[] args) {

		MemberTreeSet memberTreeSet = new MemberTreeSet(); //맵트리셋
		
		
		Member memberKim = new Member(1003, "김유신");
		Member memberLee = new Member(1001, "이순신");
		Member memberKang = new Member(1002, "강감찬");
		
		
		memberTreeSet.addMember(memberKim);
		memberTreeSet.addMember(memberLee);
		memberTreeSet.addMember(memberKang);
		memberTreeSet.showAllMember();
		
	}
}
====================================================================
//쌍으로 자료를 관리하는 Map인터페이스를 구현한 클래스와 그 활용
HashMap 클래스
package ch14;

public class Member {
	
	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}

	@Override
	public int hashCode() {
		return memberId;
	}

	@Override
	public boolean equals(Object obj) {
		if( obj instanceof Member){
			Member member = (Member)obj;
			if( this.memberId == member.memberId )
				return true;
			else 
				return false;
		}
		return false;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}
}
---------------------
package ch14;

import java.util.HashMap;
import java.util.Iterator;


public class MemberHashMap {

	private HashMap<Integer, Member> hashMap;
	
	public MemberHashMap()
	{
		hashMap = new HashMap<Integer, Member>();
	}
	
	public void addMember(Member member){
		
		hashMap.put(member.getMemberId(), member); //key, value로 넣기
		
	}
	
	public boolean removeMember(int memberId){
		
		if(hashMap.containsKey(memberId)){ //containsKey, containsValue는 반환값이 boolean이다.
			hashMap.remove(memberId);
			return true;
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");
		return false;
	}
	
	public void showAllMember(){
		Iterator<Integer> ir = hashMap.keySet().iterator(); //map자체에는 Iterator가 없으므로 key 또는 value에서 가져와야함
		while (ir.hasNext()){
			int key = ir.next();
			Member member = hashMap.get(key); //value가 반환된다.
			System.out.println(member);
		}	
		System.out.println();
	}
}
--------------------
package ch14;

import java.util.HashMap;

public class MemberHashMapTest {

	public static void main(String[] args) {

		MemberHashMap memberHashMap = new MemberHashMap();
		
		
		Member memberLee = new Member(1001, "이순신");
		Member memberKim = new Member(1002, "김유신");
		Member memberKang = new Member(1003, "강감찬");
		Member memberHong = new Member(1004, "홍길동");
		
		memberHashMap.addMember(memberLee);
		memberHashMap.addMember(memberKim);
		memberHashMap.addMember(memberKang);
		memberHashMap.addMember(memberHong);
		
		memberHashMap.showAllMember();
		
		memberHashMap.removeMember(1004);
		memberHashMap.showAllMember();
		
		HashMap<Integer,String> hashMap = new HashMap<Integer, String>();
		hashMap.put(1001,"kim");
		System.out.println(hashMap); // {1001=kim} 이렇게 keyvalue형식으로 나온다.
	}
}
//여기서 key로 정렬하는게 TreeMap이다.
=================================================================
//내부클래스(중첩클래스)
//클래스안의 클래스 선언
//내부클래스 종류
1. 인스턴스 내부 클래스
- 내부에서 쓰니까 private, private가 아니면 외부에서 사용가능

package ch01;

class OutClass {

	private int num = 10;
	private static int sNum = 20;
	private InClass inClass;
	
	public OutClass(){ 
		inClass = new InClass(); // 아웃클래스 생성될때 내부 클래스 생성
	}
	
	private class InClass{ //중첩클래스
		
		int inNum = 100;
		//static int sInNum = 200;  //에러 난디. 아우터클래스가 먼저생성난 다음에 이너클래스가 생성되니까 
		
		void inTest(){
			System.out.println("OutClass num = " +num + "(외부 클래스의 인스턴스 변수)");
			System.out.println("OutClass sNum = " + sNum + "(외부 클래스의 스태틱 변수)");
			System.out.println("InClass inNum = " + inNum + "(내부 클래스의 인스턴스 변수)");
		}
		
	    //static void sTest(){  //에러 남
	    	
	    //}
		
	}
	
	public void usingClass(){
		inClass.inTest(); //내부 클래스 변수를 사용하여 메서드 호출하기(InClass 접근)
	}
	
	2. 정적내부클래스
	static class InStaticClass{
		
		int inNum = 100;
		static int sInNum = 200;
		
		void inTest(){   //정적 클래스의 일반 메서드
			//num += 10;    // 외부 클래스의 인스턴스 변수는 사용할 수 없음.
			System.out.println("InStaticClass inNum = " + inNum + "(내부 클래스의 인스턴스 변수 사용)"); 
			System.out.println("InStaticClass sInNum = " + sInNum + "(내부 클래스의 스태틱 변수 사용)");
			System.out.println("OutClass sNum = " + sNum + "(외부 클래스의 스태틱 변수 사용)");
		}
		
		static void sTest(){  // 정적 클래스의 static 메서드
			//num += 10;   // 외부 클래스의 인스턴스 변수는 사용할 수 없음.
			//inNum += 10; // 내부 클래스의 인스턴스 변수는 사용할 수 없음
			
			System.out.println("OutClass sNum = " + sNum + "(외부 클래스의 스태틱 변수 사용)");
			System.out.println("InStaticClass sInNum = " + sInNum + "(내부 클래스의 스태틱 변수 사용)");
			
		}
	}	
}

public class InnerTest {

	public static void main(String[] args) {
		//정석방법 1
	/*	OutClass outClass = new OutClass();
		System.out.println("외부 클래스 이용하여 내부 클래스 기능 호출");
		outClass.usingClass();    // 내부 클래스 기능 호출
	    System.out.println();
	    
		//다른방법 1 (단, Inclass가 private이 아닌경우)
		OutClass.InClass inClass = outClass.new InClass();   // 외부 클래스를 이용하여 내부 클래스 생성
		System.out.println("외부 클래스 변수를 이용하여 내부 클래스 생성");
		inClass.inTest();
		
		System.out.println();
		*/
		//외부 클래스 생성하지 않고 바로 정적 내부 클래스 생성
		OutClass.InStaticClass sInClass = new OutClass.InStaticClass();  
		System.out.println("정적 내부 클래스 일반 메서드 호출");
		sInClass.inTest(); //일반메서드는 객체를 생성 후 호출
		System.out.println();
		
		System.out.println("정적 내부 클래스의 스태틱 메소드 호출");
		OutClass.InStaticClass.sTest(); //정적 메서드는 바로 호출가능
	}

}

====================================================================
3. 지역내부클래스(메서드 내부에 클래스 -> 이걸 이름을 없앤게 익명내부클래스)
package ch01;

class Outer{
	
	int outNum = 100;
	static int sNum = 200;
	
		
	Runnable getRunnable(final int i){ //Runnable한 타입을 반환해라.(메서드)
		//매개변수(i) , num도 스택메모리에 올라간다.
		int num = 100; //그냥 이렇게 선언해도 알아서 final이 붙음.(그래서 run메서드에서 출력가능하다. 스택에서 없어져도 상수영역에서 남기떄문에 run에서 출력가능한것이다)
		
		class MyRunnable implements Runnable{

			int localNum = 10;
				
			@Override
			public void run() {
				//num = 200;   //에러 남. 지역변수는 상수로 바뀜, 메서드(getRunnable)는 호출하고 끝나면 스택에서 사라진다. 근데 run이라는 메서드는 다시호출될수있는데 num,i가 없을수도있으니 final붙임 (상수화시킴 -> 스택에서 사라지지만 상수영역에서남음)
				//i = 100;     //에러 남. 매개 변수 역시 지역변수처럼 상수로 바뀜
				System.out.println("i =" + i); //그래서 가져오는건 문제가안됌
				System.out.println("num = " +num);  
				System.out.println("localNum = " +localNum);
					
				System.out.println("outNum = " + outNum + "(외부 클래스 인스턴스 변수)"); //Outer가 생성되고 Runnable 메서드가 실행되니 가능
				System.out.println("Outter.sNum = " + Outer.sNum + "(외부 클래스 정적 변수)");
				}
			}
		 return new MyRunnable();
	}
}

public class LocalInnerTest {

	public static void main(String[] args) {

		Outer out = new Outer();
		Runnable runner = out.getRunnable(10); //이렇게 runner를 주고 메서드는 끝나면 스택에 있는 것들은 사라진다.(호출이끝났으니까)
		runner.run(); //근데 여기서 호출이 되니까 값을 상수화시켜버린다, 예전에는 final을 강제적으로 븉여야됬지만 요즘은 알아서 컴파일러가 해준다.
	}
}
//근데 MyRunnable이라는 클래스이름을 굳이 줄필요가있을까? 쓰지도 않는데 -> 익명내부클래스 
===================================================================
4. 익명내부클래스
- 클래스의 이름을 생략하고 주로 하나의 인터페이스나 하나의 추상 클래스를 구현하여 반환
package ch01;

class Outter2{
		
		//방법 1
	Runnable getRunnable(int i){

		int num = 100;
		
		return new Runnable() { //클래스이름을 없앴다.
				
		@Override
		public void run() {
			//num = 200;   //에러 남
			//i = 10;      //에러 남
			System.out.println(i);
			System.out.println(num);
			}
		}; //implements의 끝이 여기다
	}
	
	//또 다른 방법(outter2의 인스턴스변수)
	Runnable runner = new Runnable() {  //runner를 통해접근가능
		
		@Override
		public void run() {
			System.out.println("Runnable 이 구현된 익명 클래스 변수");
			
		}
	};
}

public class AnonymousInnerTest {

	public static void main(String[] args) {
		Outter2 out = new Outter2();
	
		Runnable runnerble = out.getRunnable(10);
		runnerble.run();
		
		out.runner.run();
	}
}
=============================================================================
//람다식(자바8부터지원)
//일반 함수
int add(int x, int y) {
	return x+y;
}
//람다식으로 표현
(int x, int y) -> {return x+y;}

===============================================================================
package ch03;

//@FunctionalInterface 컴파일러한테 정보를 주는역할이다, 메서드를 두개이상 선언하면안된다.
public interface Add {

	public int add(int x, int y);
}
-----------
package ch03;

public class TestAdd {

	public static void main(String[] args) {

		Add addF = (x, y) -> x + y; //원래는 인터페이스를 받으면 클래스를 만들고 함수를 정의해야하는데. 람다식은 인터페이스만 선언하고 구현바로가능
		
		System.out.println(addF.add(3,5));
	}

}
===================================================================================
//함수형인터페이스
- 람다식을 선언하기위한 인터페이스
- 익명함수와 매개변수만으로 구현되므로 인터페이스는 단하나의 메서드만을 선언해야한다.
- @FunctionalInterface 는 함수형 인터페이스라는 의미. 내부에 여러개의 메서드를 선언하면 에러난다.

package ch03;

@FunctionalInterface
public interface MyNumber {
	
	int getMax(int num1, int num2);

}
-----------------
package ch03;

public class TestMyNumber {

	public static void main(String[] args) {
		MyNumber max = (x, y)->(x>= y)? x:y; // 람다식을 인터페이스 자료형 max 변수에 대입

		System.out.println(max.getMax(10, 20));// 인터페이스 자료형 변수로 함수 호출
			
	}
}
=================================================================================
//객체지향과 람다식 비교
//기존 객체지향 방식
package ch04;

public interface StringConcat {
	
	public void makeString(String s1, String s2);

}
-----------
package ch04;

public class StringConCatImpl implements StringConcat{

	@Override
	public void makeString(String s1, String s2) {
		System.out.println( s1 + "," + s2 );
	}
}
------------
package ch04;

public class TestStringConcat {

	public static void main(String[] args) {

		String s1 = "Hello";
		String s2 = "World";
		StringConCatImpl concat1 = new StringConCatImpl();
		concat1.makeString(s1, s2);
		int i = 100;
		
		//인터페이스로(람다식)
		//클래스를 만들지않아도 되지만 실제적으로는 익명클래스가 만들어진다.(아래)
		StringConcat concat2 = (s, v)->System.out.println(s + "," + v ); //System.out.println(i);
		concat2.makeString(s1, s2);
		i = 300;
		
		//아래처럼 이렇게 익명클래스가 만들어진다.
		StringConcat concat3 = new StringConcat() {
			
			@Override
			public void makeString(String s1, String s2) {
				
				System.out.println( s1 + "," + s2 );
			}
		};
		
		concat3.makeString(s1, s2);
		
	}

}
===========================위에부분은 객체지향 방식이다.
//여기는 람다식 방법
//TestLamda.java
package ch04;

interface PrintString{
	
	void showString(String str);
}

public class TestLambda {

	public static void main(String[] args) {

		PrintString lambdaStr = s->System.out.println(s);  //람다식을 변수에 대입
		lambdaStr.showString("hello lambda_1");
		
		showMyString(lambdaStr);                          //메서드 매개변수로 전달(static함수)
		
		PrintString reStr = returnString();  
		reStr.showString("hello ");
		
	}
	
	public static void showMyString(PrintString p) { //인터페이스 자료형을 매개변수로 받는다.
		p.showString("hello lambda_2");
	}
	
	public static PrintString returnString() {         //반환 값으로 사용(반환값은 인터페이스)
		return s->System.out.println(s + "world");
	}
}
========================================================================
//스트림
- 컬렉션이나 배열 등의 자료들이 모여있는데 이런 자료들의 연산(더하기, 뺴기, 평군 등)의 처리를 일관성있게 해준다. 즉, 배열이건 상관없이 동일한 방식으로 연산할 수 있도록해주는 것이 스트림이다.
- 자료의 대상과 관계없이 동일한 연산을 수행
- 배열, 컬렉션을 대상으로 연산을 수행한다.
- 한번생성하고 사용한 스트림은 재사용 할 수 없다.
- 스트림 연산은 기존 자료를 변경하지않는다.(정렬 등)

package ch05;

import java.util.Arrays;

public class IntArrayTest {

	public static void main(String[] args) {

		int[] arr = {1,2,3,4,5};
		
		int sumVal = Arrays.stream(arr).sum();
		long count = Arrays.stream(arr).count();
		
		System.out.println(sumVal);
		System.out.println(count);
	}

}
======================================================================
package ch05;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream

public class IntArrayStreamTest {

	public static void main(String[] args) {
		int[] arr = {1,2,3,4,5};
		Arrays.stream(arr).forEach(n->System.out.print(n + "\t"));
		System.out.println();
					
		int sum  = Arrays.stream(arr).sum();
		System.out.println("sum: " + sum);
		
		//스트림생성
		IntStream is = Arrays.stream(arr); //IntStream으로 반환한다.
		is.forEach(n->System.out.println(n));
		//여기서 또 is. 으로 못쓴다. 스트림은 한번만 연산가능(소모)
		
		//그래서 다시 스트림을 생성해야한다.
		//int sum = Arrays.stream(arr).sum();
		
		
		List<Integer> list = new ArrayList<Integer>();
		list.add(1);
		list.add(2);
		list.add(3);
		list.add(4);
		list.add(5);
		int sum2 = list.stream().mapToInt(n->n.intValue()).sum(); 
		System.out.println(sum2);
	}

}
=======================================================================
//스트림은 중간연산 최종연산으로 나뉜다.
// 중간연산의 예) filter(), map(), sorted() 등
// 최종연산의 예) forEach(), count(), sum() 등
// 최종연산이 호출될 때 중간 연산이 수행되고 결과가 생성된다.
// filter()는 중간연산이고, forEach()는 최종연산이다.
package ch05;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class ArrayListStreamTest {

	public static void main(String[] args) {
		List<String> sList = new ArrayList<String>();
		sList.add("Tomas");
		sList.add("Edward");
		sList.add("Jack");
		
		Stream<String> stream = sList.stream(); //스트림 생성
		stream.forEach(s->System.out.print(s + " "));
		System.out.println();
		
		//람다식은 익명클래스가 숨어있다.
		sList.stream().sorted().forEach(s->System.out.print(s+ " ")); //기존의 자료는 바뀌지않는다.
		sList.stream().map(s->s.length()).forEach(n->System.out.println(n)); //s가 가지고 있는 메서드를 호출할려면 map
		sList.stream().filter(s->s.length() >= 5).forEach(s->System.out.println(s));
		
	}

}
=============================================================================
#)reduce()  -> 최종연산으로 스트림의 요소를 소모하여 연산을 수행. 람다식을 직접구현하거나 람다식이 긴 경우 BinaryOperator를 구현한 클래스를 사용한다.
예시) 배열의 모든 요소의 합을 구하는 reduce()연산 구현
Arrays.stream(arr).reduce(0,(a,b)->a+b)); //arr은 배열이라고 가정


package ch06;

import java.util.Arrays;
import java.util.function.BinaryOperator;

public class ReduceTest {

	public static void main(String[] args) {

		String[] greetings = {"안녕하세요~~~", "hello", "Good morning", "반갑습니다^^"}; 
		
		System.out.println(Arrays.stream(greetings).reduce("", (s1, s2)->              //자료가 소모될때까지 진행
		                          {if (s1.getBytes().length >= s2.getBytes().length)  //getBytes를 하면 array가 반환이 되기떄문에 .length 가능하다.
				                                  return s1;  
		                          else return s2;}));   //출력하면 안녕하세요~~~ 가 출력된다. 한글은 2byte이고 영문은 1byte이니까
		                          
	}
}
//이 방법이 지저분하다면 아래처럼 이용

====================================================================================

package ch06;

import java.util.Arrays;
import java.util.function.BinaryOperator;

class CompareString implements BinaryOperator<String>{ //인터페이스니까 함수구현

	@Override
	public String apply(String s1, String s2) {  //두인자를 계속받는다.
		if (s1.getBytes().length >= s2.getBytes().length) return s1;
		else return s2;
	}
}

public class ReduceTest {

	public static void main(String[] args) {

		String[] greetings = {"안녕하세요~~~", "hello", "Good morning", "반갑습니다^^"}; 
		
		
		String str = Arrays.stream(greetings).reduce(new CompareString()).get(); //BinaryOperator를 구현한 클래스 이용, apply가 자동으로 작동된다.
		System.out.println(str); // 안녕하세요~~~ 출력된다.
		                          
	}
}
=================================================================================
//스트림을 이용한 패키지 여행비용계산하기
여행비용은 15세이상은 100만원 , 그 미만은 50만원
package ch07;

public class TravelCustomer {

	private String name;   //이름
	private int age;       //나이
	private int price;     //가격
	
	public TravelCustomer(String name, int age, int price) {
		this.name = name;
		this.age = age;
		this.price = price;
	}

	public String getName() {
		return name;
	}

	public int getAge() {
		return age;
	}

	public int getPrice() {
		return price;
	}
	
	public void setName(String name) {
		this.name = name;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public void setPrice(int price) {
		this.price = price;
	}

	public String toString() {
		return "name: " + name + "age: " + age + "price: " + price; 
	}

}
--------------------
package ch07;

import java.util.ArrayList;
import java.util.List;

public class TravelTest {

	public static void main(String[] args) {
		TravelCustomer customerLee = new TravelCustomer("이순신", 40, 100);
		TravelCustomer customerKim = new TravelCustomer("김유신", 20, 100);
		TravelCustomer customerHong = new TravelCustomer("홍길동", 13, 50);
		
		List<TravelCustomer> customerList = new ArrayList<>(); //<>안에 생략해도됌.
		customerList.add(customerLee);
		customerList.add(customerKim);
		customerList.add(customerHong);
		
		System.out.println("== 고객 명단 추가된 순서대로 출력 ==");
		customerList.stream().forEach(s->System.out.println(s)); // toString이 출력된다.(s)객체를 출력해라. 
		customerList.stream().map(c->c.getName()).forEach(s->System.out.println(s)); // 이름만 출력된다. map이 중간연산, forEach가 최종연산이된다.
		
		int total = customerList.stream().mapToInt(c->c.getPrice()).sum();
		System.out.println("총 여행 비용은 :" + total + "입니다");
		
		System.out.println("== 20세 이상 고객 명단 정렬하여 출력 =="); //20명이상은 mapping해서 다시 sorted(기본 오름차순)해서 출력
		customerList.stream().filter(c->c.getAge() >= 20).map(c->c.getName()).sorted().forEach(s->System.out.println(s)); //최종연산은 한번만 사용된다.
		//출력 
		//김유신
		//이순신
	}

}
=============================================================================================
#)예외처리하는 이유 -> 서비스가 죽지않기하기 위해서 (비정상종료 방지, 로그남겨서 그 상황이 무엇인지 버그를 알기위해)

  throwable   (ERROR , Exception은 throwable에서 상속받았다)
   |    |
ERROR Exception(하위에 있는 Exception들이 엄청많다)

#)이렇게 try를 해야 서비스 중지를 막을 수 있다.
try {
	예외가 발생할수있는 부분
}catch(처리할 예외 타입 e) {
	try 블록안에서 예외가 발생했을 떄 예외를 처리하는 부분(대부분 로그를 남긴다)
}
================================================================
package ch08;

public class ArrayExceptionHandling {

	public static void main(String[] args) {
		int[] arr = {1,2,3,4,5};
		try{
			for(int i=0; i<=5; i++){      //배열범위 예외
				System.out.println(arr[i]);
			}
		}catch(ArrayIndexOutOfBoundsException e){   //콘솔에 빨갛게 글자가 뜨는게 아니라 검은색으로 글자가 나온다.
			System.out.println(e);  //Index 5 out of bounds for length 5
			System.out.println(e.getMessage());   //java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length
		}
		System.out.println("비정상 종료되지 않았습니다.");
	}
}
================================================================
//try-catch-finally 문 (소켓같은 close해줘야될때) finally는 catch에 return이 있어도 호출이된다.


//잘못된 예시 (finally를 안쓸때)
try {
	fis = new FileInputStream("a.txt");
	System.out.println("read");
	
	try {
		fis.close();
	}catch(IOException e) {
		e.printStackTrace();
	}
}catch (FileNotFoundException e) {
	System.out.println(e);
	try {
		fis.close();
	}catch(IOException e1) {
		e1.printStackTrace();
	}
	System.out.println("end");
}
=========================================================================

package ch09;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileExceptionHandling {

	public static void main(String[] args) {
		FileInputStream fis = null;
		try {
			fis = new FileInputStream("a.txt"); //파일을 읽어들인다(가장먼저 찾는 path는 프로젝트 폴더 바로 밑이다)
		} catch (FileNotFoundException e) {
			System.out.println(e);
			//return; //return을 해도 finally는 불린다.
		}finally{ //finally를 안쓰면 catch구간마다 close를 해줘야하니까 
			if(fis != null){ //열려있을 떄 close해야함
				try {
					fis.close();
				} catch (IOException e) { //IOException은 close할떄 나는 예외이다.
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			System.out.println("항상 수행 됩니다.");
		}
		System.out.println("여기도 수행됩니다.");
	}
}
//근데 이거는 코드가 더럽다 -> 자바 7부터 try-with-resources가 있는데 자동으로 자원을 해제시켜준다.
============================================================
//이 처럼쓰면 알아서 close가 된다. (try안에 쓰면)
//FileInputStream이 autoCloseable을 implements를 하고있는데 이거는 예외가 났던간에 끝나면 close메소드가 자동으로 호출되도록 하는 인터페이스이다.
public class FileExceptionHandling {
	public static void main(String[] args) {
	try(FileInputStream fis = new FileInputStream("a.txt")) {
		System.out.println("read") //에러나면 여기는 실행안한다.
	} catch(FileNotFoundException e) {
		e.printStackTrace();
	} catch(IOException e) {
		e.printStackTrace();
	}
	System.out.println("end"); //예외가 나도 실행
	}
}

===================================================================
//AutoCloseable 실습

package ch09;

public class AutoCloseObj implements AutoCloseable{

	@Override //AutoCloseable에 있는 close를 오버라이딩
	public void close() throws Exception {
		System.out.println("리소스가 close() 되었습니다");   //예외든 아니든(try가 실행되면 close가 호출된다 -> autoCloseable을 implements한 obj를 썼으니)
	}
}
-------------------
package ch09;

public class AutoCloseTest {
	
	public static void main(String[] args) {
		
		AutoCloseObj obj = new AutoCloseObj();
    	try (obj){
			throw new Exception(); //강제로 예외만들기
		}catch(Exception e) { //모든 예외처리
			System.out.println("예외 부분 입니다");
		}
	}
}
===================================================================
package ch09;

import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class ThrowsException {

	public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException{ //여기서는 catch를 안쓰고 throws를 써보자(예외처리를 미루겠다) -> 어디로미루냐? -> loadClass라는 메소드를 호출하는 쪽에서 처리해라
		FileInputStream fis = new FileInputStream(fileName); //FileNotFoundException 발생(fileName를 연다) -> throws로 던지고
		Class c = Class.forName(className);  //ClassNotFoundException 발생
		return c;
	}

	public static void main(String[] args) {

		ThrowsException test = new ThrowsException();
		
		try {
			test.loadClass("a.txt", "java.lang.String"); //loadClass메서드를 호출 -> 예외처리 , java.lang.Sttring이라는 클래스를 로드해라
		
		}catch (FileNotFoundException e) {
			e.printStackTrace(); //로그남기기
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}catch (Exception e) {  //애를 맨위에 쓰면안된다.(업캐스팅되니까 여기오면)
			e.printStackTrace();
		}
	}
}
================================================================
//multi-exception(한번에 처리 '|' 기호를 통해서)
package ch09;

import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class ThrowsException2 {

	public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException{ //예외를 던지겠다
		FileInputStream fis = new FileInputStream(fileName); //FileNotFoundException 발생
		Class c = Class.forName(className);  //ClassNotFoundException 발생
		return c;
	}

	public static void main(String[] args) {

		ThrowsException2 test = new ThrowsException2();

		try {
			test.loadClass("a.txt", "java.lang.String");
		} catch (FileNotFoundException | ClassNotFoundException e) { //둘중에 하나의 예외가 발생하면
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
=====================================================================
제네릭 타입
<? extends Object> == <?> 같은의미이다. 어떤 자료형의 객체도 매개변수로 받겠다는 의미이다.

public class WildTest {

    public static void main(String[] args) {
        // List는 인터페이스이기 때문에 ArrayList 생성 후 Upcasting 이용
        List<String> list = new ArrayList();
        list.add("test1");
        list.add("test2");
        list.add("test3");

        // Integer 자료형 list2 객체 생성
        List<Integer> list2 = new ArrayList();
        list2.add(1);
        list2.add(2);
        list2.add(new Integer(3));

        // Double형 list3 생성
        List<Double> list3 = new ArrayList();
        list3.add(10.1);
        list3.add(11.2);
        list3.add(12.3);

        // static 메소드 호출
        printData(list);
        printData(list2);
        printData(list3);

        /*
        test1    test2    test3
        1        2        3
        10.1    11.2    12.3
        */

    }

    // 리스트 출력 메소드
    public static void printData(List<?> list) {
        for (Object v : list) { //Object로 받았음을 볼수가있다.
            System.out.println(v);
        }
    }
====================================================================
위에는 extends Object였다면 이번에는 extends 클래스이다.

class Test {
	String name;
}

class Person {
	String name;
}

//Person상속 Man 클래스
class Man extends Person {
	//생성자
	Man(String name) {
		this.name = name;
	}
	
	//name 반환 메소드
	public String toString() {
		return name.toString();
	}
}

// Person 상속 Woman 클래스
class Woman extends Person {
    Woman(String name) {
        this.name = name;
    }

    public String toString() {
        return name.toString();
    }
}

public class WildExtends {

    public static void main(String[] args) {

        // Person
        List<Person> listP = new ArrayList<Person>();
        listP.add(new Person());
        printData(listP);        // j200210.Person@15db9742

        // Man
        List<Man> listM = new ArrayList<Man>();
        listM.add(new Man("이순신"));
        listM.add(new Man("하현우"));
        listM.add(new Man("박효신"));
        printData(listM);    // 이순신    하현우    박효신

        // Woman
        List<Woman> listW = new ArrayList<Woman>();
        listW.add(new Woman("유관순"));
        listW.add(new Woman("백예린"));
        listW.add(new Woman("박정현"));
        printData(listW);    // 유관순    백예린    박정현

        // Test
        List<Test> listT = new ArrayList<Test>();
        listT.add(new Test());
//      printData(listT); → Person 클래스를 상속받지 않았기 때문에 메소드 호출 불가

    }

    // Person 클래스와 그 하위 클래스로 생성된 인스턴스만 매개변수로 전달 가능
    public static void printData(List<? extends Person> list) {
        for (Person obj : list) {
            System.out.println(obj);
        }
    }

}
=====================================================================
<? super 클래스>
매개변수의 자료형을 특정 클래스와 그 클래스의 상위 클래스로만 제한함

// Person 클래스
class Person {
    String name;

    // 기본 생성자
    Person() {
    }
	
    // 생성자 오버로딩
    Person(String name) {
        this.name = name;
    }

    public String toString() {
        return name;
    }
}

//Person상속 Man 클래스
class Man extends Person {
	//생성자
	Man(String name) {
		this.name = name;
	}
	
	//name 반환 메소드
	public String toString() {
		return name.toString();
	}
}

// Person 상속 Woman 클래스
class Woman extends Person {
    Woman(String name) {
        this.name = name;
    }

    public String toString() {
        return name.toString();
    }
}

public class WildSuper {

    public static void main(String[] args) {

        // Person
        List<Person> listP = new ArrayList<Person>();
        listP.add(new Person("사람"));
        listP.add(new Person("인간"));
        printData(listP); // 사람 인간

        // Man
        List<Man> listM = new ArrayList<Man>();
        listM.add(new Man("하현우"));
        listM.add(new Man("박효신"));
        printData(listM); // 하현우 박효신

        // Woman
        List<Woman> listW = new ArrayList<Woman>();
        listW.add(new Woman("백예린"));
        listW.add(new Woman("박정현"));
//      printData(listW); → Man 클래스의 상위 클래스가 아니기 때문에 메소드 호출 불가

    }

    // Man 클래스와 그 상위 클래스로 생성된 인스턴스만 매개변수로 전달 가능
    public static void printData(List<? super Man> list) {
        for (Object obj : list) {
            System.out.println(obj);
        }
    }
}

=====================================================================
//연결리스트
ArrayList(배열)에 비해서 추가나 삭제 용이하지만 인덱스가 없어서 특정요소에 접근하기 위해서는 순차적으로 접근이 필요 -> 탐색속도가 떨어진다.
그래서 탐색또는 정렬을 자주하는 경우엔 배열을 사용, 데이터의 추가,삭제가 많은 경우 연결리스트 사용한다.

ArrayList는 내부 배열에 객체를 저장해서 인덱스로 관리하는데 비해서 LinkedList는 위와 같이 인접 참조를 링크해서 체인처럼 관리합니다. 

예시) LinkedList<Studnet> members = new LinkedList<Student>();
     LinkedList<Integer> num = new LinkedList<Integer>();

<>안에 선언할수 있는게 제네릭스 타입인데 제네릭스는 선언할 수 있는 타입이 객체타입이다.
int는 기본자료형이기때문에 들어갈수없으므로 int를 객체화시킨 wrapper클래스를 사용해야한다. 그래서 Integer를 썻다

LinkedList<Integer> list = new LinkedList<Integer>();
list.addFirst(1); //가장 앞에 데이터추가
list.addLast(2); //가장 뒤에 데이터추가
list.add(3); //데이터 추가(인덱스 생략시 마지막에 추가)
list.add(1,10); // index 1에 데이터 10 추가

----------------------
//LinkedList 값 출력
LinkedList<Integer> list = new LinkedList<Integer>(Arrays.asList(1,2,3));

System.out.println(list.get(0));//0번째 index 출력
				
for(Integer i : list) { //for문을 통한 전체출력
    System.out.println(i);
}

Iterator<Integer> iter = list.iterator(); //Iterator 선언 
while(iter.hasNext()){//다음값이 있는지 체크
    System.out.println(iter.next()); //값 출력
}

======================================================================
		-------------
Head -> |data | link|
        -------------

public class LinkedList {
	//첫번째 노드를 가리키는 필드 
	private Node head;
	//마지막 노드를 가리키는 필드 
	private Node tail;
	private int size = 0;
	
	private class Node { //하나의 노드에는 data,next가 있다.(next는 node를 가리켜야하니 타입이 Node이다) 
		private Object data; //데이터가 저장될 필드
		private Node next;	//다음 노드를 가리키는 필드
		
		public Node(Object input) {
			this.data = input;
			this.next = null;
		}
	}
	//노드 내용 확인
	public String toString() {
		String.valueOf(this.data);
	}
}

또는

public class SLinkedList<E> implements List<E> {
	private Node<E> head; //노드의 첫부분(리스트의 가장 첫 노드를 가리키는 변수다)
	private Node<E> tail; //노드의 마지막부분
	private int size; //(연결된 노드 개수)
	
	//생성자(null,0 초기화)
	public SLinkedList() {
		this.head = null;
		this.tail = null;
		this.size = 0;
	}
}

//search 메소드 구현(특정위치의 노드를 반환하는 메서드)
private Node<E> search(int index) {
	
	//범위 밖(잘못된 위치)일 경우 예외던지기
	if(index < 0 || index >= size) {
		throw new IndexOutOfBoundsException();
	}
	
	Node<E> x = head; //head가 가리키는 노드부터 시작(순차적으로) x에는 data,next가 있다, 즉 headNode부터 시작
	
	for(int i = 0; i<index; i++) {
		x = x.next;  //x.next는 다음 노드자체를 가리킨다.
	}
	 return x;
}

//addFirst(E value) 맨 앞에 추가 메소드
1. new Node(data,null)를 생성해서 head앞에 놓아야하는데 그럴려면
2. 링크작업이필요하다. new Node의 링크는 헤드를 가리켜야한다.
3. 링크작업이끝나면 head를 new Node로 바꾼다.

public void addFirst(E value) {
	
	Node<E> newNode = new Node<E>(value); //새 노드생성
	newNode.next = head; //링크작업
	head = newNode; //헤드를 newNode로 바꾸기
	size++;
	
	if(head.next == null) {
		tail = head;
	}
}


//add(E value) 또는 addLast(E value)
1. new Node(data,null)를 생성해서 tail 뒤에 놓아야하는데 그럴려면
2. 링크작업이 필요하다. 기존에 tail(data,null)인데  기존 tail의 link를 newNode자체를 가리켜야한다.
3. 그 후 tail을 newNode로 바꾼다.

public boolean add(E value) {
	addLast(value);
	return true;
}

public void addLast(E value) {
	Node<E> newNode = new Node<E>(value); //새 노드생성
	
	if(size == 0) { //처음 넣는 노드일 경우 addFirst로 추가
		addFirst(value);
		return;
	}

	tail.next = newNode; //기존의 tailNode는 newNode를 가리키고
	tail = newNode;
	size++;
}


//add(중간삽입)
public void add(int index, E value) {
	
	//잘못된 인덱스를 참조할 경우 예외 발생
	if(index < size || index < 0) {
		throw new IndexOutOfBoundsException();
	}
	
	//추가하려는 index가 가장 앞이면 addFirst호출
	if(index == 0) {
		addFirst(value);
		return;
	}
	
	//추가하려는 index가 마지막 위치일 경우 addLast호출
	if(index == size) {
		addLast(value);
		return;
	}
	
	//추가하려는 위치의 이전노드
	Node<E> prev_Node = search(index - 1); //추가하려는 위치의 이전노드를 받는다.
	
	//추가하려는 위치의 노드 -> 이전 노드가 가리키고있던 노드를 받는다. (추가하는 노드에 부여하기위해)
	Node<E> next_Node = prev_Node.next; 

	//추가하려는 노드
	Node<E> newNode = new Node<E>(value);
	
	//이전노드가 가리키는 노드를 끊은 뒤 만든 새노드를 연결
	prev_Node.next = null;
	prev_Node.next = newNode;
	
	//새노드는 이전노드가 가리켰던 노드를 가리켜야한다.
	newNode.next = next_Node;
	size++;
}


//삭제할때
1. 가장 앞의 요소 제거 remove()
2. 특정 index의 요소를 제거 remove(int index)
3. 특정 요소를 제거 remove(Object value)

1. 가장 앞의 요소 제거 remove()
//가장 앞의 요소 제거는 쉽게 head가 가리키는 노드의링크, 데이터를 null로 지워준 뒤 head를 다음 노드로 업데이트만 해주면된다.
//그리고 삭제하려는 노드가 리스트에서의 유일한 노드였을 경우 해당 노드를 삭제하면 tail이 가리키는 노드 또한 없어지게된다.(요소가 한개일경우 head와 tail이 가리키는 노드가 같기때문)
public E remove() {
	Node<E> headNode = head;
	
	if(headNode == null) {
		throw new NoSuchElementException();
	}
	
	//삭제된 노드를 반환하기 위한 변수
	E element = headNode.data;
	
	//head의 다음 노드
	Node<E> nextNode = head.next;
	
	//head 노드의 값들 모두 삭제
	head.data = null;
	head.next = null;
	
	//head를 nextNode로 변경
	head = nextNode;
	size--;
	
	//삭제된 요소가 리스트의 유일한 요소일 경우 그 요소는 head이자 tail이다.
	if(size == 0) {
		tail = null;
	}
	return element;
}

2. 특정 index의 요소를 제거 remove(int index)

public E remove(int index) {
	
	//삭제하려는 노드가 첫 번째 원소일 경우
	if(index == 0) {
		return remove();
	}
	
	//잘못된 범위에 대한 예외
	if(index >= size || index < 0) {
		throw new IndexOutOfBoundsException();
	}
	
	Node<E> prevNode = search(index - 1); //삭제할 노드의 이전 노드
	Node<E> removedNode = prevNode.next; //삭제할 노드
	Node<E> nextNode = removedNode.next; //삭제할 노드의 다음 노드
	
	E element = removedNode.data; //삭제되는 노드의 데이터 반환
	
	//삭제하려는 노드가 가리키는 노드를 이전노드가 받아야한다.
	preNode.next = nextNode;
	
	//만약 삭제했던 노드가 마지막 노드라면 tail을 prevNode로 바꾼다.
	if(prevNode.next = null) {
		tail = prevNode;
	}
	
	//데이터 삭제
	removedNode.next = null;
	removedNode.data = null;
	size--;
	
	return element;
}

3. 사용자가 원하는 특정 요소(value)를 리스트에서 찾아서 삭제
- 여기서 핵심은 삭제하려는 요소가 존재하는지를 먼저 봐야한다. -> false, true

public boolean remove(Object value) {
	
	Node<E> prevNode = head;
	boolean hasValue = false;
	Node<E> x = head; //삭제할 value를 찾기위해 head부터 순차적으로 돌아야하니
	
	// value와 일치하는 노드를 찾는다.
	for(; x != null; x=x.next) {
		if(value.equals(x.data)) {
			hasValue = true;
			break;
		}
		prevNode = x;  //삭제할 노드의 이전노드를 prevNode에 대입
	}
	
	//일치하는 요소가 없을 경우 false 반환
	if(x == null) {
		return false;
	}
	
	//만약 삭제하려는 노드가 head라면 기존 remove()를 사용
	if(x.equals(head)) {
		remove();
		return true;
	}
	
	else {
		//삭제하려는 노드의 링크를 이어받아서 이전노드의 링크에 대입
		prevNode.next = x.next;
		
		//만약 삭제했던 노드가 마지막 노드라면 tail을 prevNode로 바꾼다.
		if(prevNode.next == null) {
			tail=prevNode;
		}
		x.data = null;
		x.next = null;
		size--;
		return true;
	}
}

//이렇게 추가,삭제 메소드는 끝이 났고 추가적인 메소드를 알아보자
1. get(int index)메소드
우리가 구현했던 search()와 무슨차이일까?
search()는 노드를 반환하고, get()메소드는 노드의데이터를 반환하는 것이다.

public E get(int index) {
	return search(index).data;
}


2. set(int index, E value)메소드
해당 메소드는 index에 위치한 데이터를 새로운 데이터로 교체하는것이다. 노드의 데이터만 바꿔주면 된다
search()메소드에서 잘못된 인덱스를 참조하고 있지 않은지 검사하기 때문에 따로 구현안해도된다.

public void set(int index, E value) {
	Node<E> replaceNode = search(index);
	replaceNode.data = null;
	replaceNode.data = value;
}


3. indexOf(Objec value) 메소드
사용자가 찾고자하는 요소(value)의 위치(index)를 반환하는 메소드다.
만약, 찾고자하는 요소가 중복되면 가장먼저 나오는 요소의 인덱스를반환하게 구현한다(기존에 indexOf메소드로 그렇게되어있다)

중요한점은 객체끼리 비교할 때는 동등연산자(==)가 아니라 .equals로 해야한다. 동등연산자를 쓰면 주소를 비교하기 때문이다. 우리는 값을 비교해야한다.

public int indexOf(Object value) {
	int index = 0;
	
	for(Node<E> x = head; x != null; x=x.next) {
		if(value.equals(x.data)) {
			return index;
		}
		index++;
	}
	//찾고자 하는 요소를 찾지 못했을 경우 -1 반환
	return -1;
}

4. contains(Object value)메소드
- 사용자가 찾고자 하는 요소(value)가 존재하는지, 안하는지만 확인하면된다. indexOf는 해당위치를 반환하지만 이거는 그냥 여부만 반환하면된다.

public boolean contains(Object item) {
	return indexOf(item) >= 0;
}

5. isEmpty() 메소드
- 리스트가 비어있을경우 true, 아니면 false를 반환

public boolean isEmpty() {
	return size == 0;
}


6. clear() 메소드
- 객체 자체를 null해주기 보다는 모든 노드를 하나하나 null해주는 것이 자바의 가비지 컬렉터가 명시적으로 해당 메모리를 안쓴다고 인지하기 때문에 메모리 관리효율에서 더 좋다.

public void clear() {
	for(Node<E> x = head; x != null;) {
		Node<E> nextNode = x.next;
		x.data = null;
		x.next = null;
		x = nextNode;
	}
	head = tail = null;
	size = 0;
}


7. clone()메소드
- 사용자가 사용하고 있던 LinkedList를 하나 복제하고 싶을 때 쓰는 메소드이다.
- 단순히 '=' 연산으로 객체를 복사하게되면 주소를 복사하기때문에 복사한 객체에서 데이터를 수정하면 원본객체까지 영향을 미치게된다.
- 즉, 얕은 복사가 되는것이다.

SLinkedList<Integer> original = new SLinkedList<>();
original.add(10);

SLinkedList<Integer> copy = original;
copy.add(20);

//original 리스트 조회
for(int i = 0; i<original.size(); i++) {
	System.out.println("index " + i + "data = " + original.get(i));
}

//copy 리스트 조회
for(int i = 0; i<copy.size(); i++) {
	System.out.println("index " + i + "data = " + copy.get(i));
}

//결과 둘다 값이 같아져버린다.
//즉, 객체가 하나로 같은걸 바라보고있는것이다.

따라서 이러한 얕은 복사를 방지하기 위해 깊은 복사를 하는데, 이때 clone()을 쓴다.
Object에 있는 메소드이지만 접근제어자가 protected로 되어있어 우리가 만든 것 처럼 사용자 클래스의 경우 Cloneable 인터페이스를 implement 해야한다.

즉, public class LinkedList<E> implements List<E> 에 Cloneable도 추가해주어야 한다. 만약 안하고서 구현하면 CloneNotSupportedException 에러가 난다.

그리고나서 clone()을 구현하면 되는데, 다음과 같이 재정의를 하면 된다.

public Object clone() throws CloneNotSupportedException {
 
	@SuppressWarnings("unchecked")
	SLinkedList<? super E> clone = (SLinkedList<? super E>) super.clone();
 
	clone.head = null;
	clone.tail = null;
	clone.size = 0;
 
	for (Node<E> x = head; x != null; x = x.next) {
		clone.addLast(x.data);
	}
 
	return clone;
}
 

super.clone() 을 해주면, 객체 자체는 생성되나 내부까지 데이터 복제가 이루어지는 것이 아닌 얕은복사가 되어버린다. 그렇기 때문에 새로 만들어진 객체의 내부에 데이터를 새로 설정해주어야 한다.

즉, 각 노드를 일단 끊고, 처음부터 끝까지 현재 리스트의 데이터를 clone 리스트에 넣어주어야 한다.
=====================================================================
//Student클래스가 Comparable을 구현하지 않았을 경우
//1. 명시적으로 Arrays.sort()에 정렬방법을 알려주던가
//2. Student 클래스에 정렬방법을 구현하던가
public class test {
	public static void main(String[] args) {
		SLinkedList<Student> list = new SLinkedList<>();
 
		list.add(new Student("김자바", 92));
		list.add(new Student("이시플", 72));
		list.add(new Student("조시샵", 98));
		list.add(new Student("파이손", 51));
		
		list.sort(); //여기서 에러가난다.
		
		for(int i = 0; i < list.size(); i++) {
			System.out.println(list.get(i));
		}
	}
}
 
class Student {
	String name;
	int score;
	
	Student(String name, int score){
		this.name = name;
		this.score = score;
	}
	
	public String toString() {
		return "이름 : " + name + "\t성적 : " + score;
	}
}
==================================================================
1. Comparator의 구현을 통해 명시적으로 Arrays.sort()에 파라미터로 넘기는 방법
public class test {
	public static void main(String[] args) {
		SLinkedList<Student> list = new SLinkedList<>();
 
		list.add(new Student("김자바", 92));
		list.add(new Student("이시플", 72));
		list.add(new Student("조시샵", 98));
		list.add(new Student("파이손", 51));
 
		list.sort(customComp);	// Comparator을 파라미터로 넘겨준다.
        
		for(int i = 0; i < list.size(); i++) {
			System.out.println(list.get(i));
		}
		
	}
	// 사용자 설정 comparator(비교기)
	static Comparator<Student> customComp = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			return o2.score - o1.score; //내림차순
		}
	};
 
}
 
class Student {
	String name;
	int score;
	
	Student(String name, int score){
		this.name = name;
		this.score = score;
	}
	
	public String toString() {
		return "이름 : " + name + "\t성적 : " + score;
	}
}
========================================================================
2. Comparable의 구현을 통해 객체의 정렬방법을 설정하는 방법

public class test {
	public static void main(String[] args) {
		SLinkedList<Student> list = new SLinkedList<>();
 
		list.add(new Student("김자바", 92));
		list.add(new Student("이시플", 72));
		list.add(new Student("조시샵", 98));
		list.add(new Student("파이손", 51));
 
		list.sort();
		for(int i = 0; i < list.size(); i++) {
			System.out.println(list.get(i));
		}
		
	}
}
 
class Student implements Comparable<Student> {
	String name;
	int score;
	
	Student(String name, int score){
		this.name = name;
		this.score = score;
	}
	
	public String toString() {
		return "이름 : " + name + "\t성적 : " + score;
	}
 
	@Override
	public int compareTo(Student o) {
		return o.score - this.score;
	}
}
==========================================================================
//제네릭 클래스 사용
class ClassName<E> {
	
	private E element;	// 제네릭 타입 변수
	
	void set(E element) {	// 제네릭 파라미터 메소드
		this.element = element;
	}
	
	E get() {	// 제네릭 타입 반환 메소드
		return element;
	}
	
}
 
class Main {
	public static void main(String[] args) {
		
		ClassName<String> a = new ClassName<String>();
		ClassName<Integer> b = new ClassName<Integer>();
		
		a.set("10");
		b.set(10);
	
		System.out.println("a data : " + a.get());
		// 반환된 변수의 타입 출력 
		System.out.println("a E Type : " + a.get().getClass().getName());
		
		System.out.println();
		System.out.println("b data : " + b.get());
		// 반환된 변수의 타입 출력 
		System.out.println("b E Type : " + b.get().getClass().getName());
		
	}
}

//결과
a data : 10
a E Type : java.lang.String

b data : 10
b E Type : java.lang.Integer
=============================================================================
//제네릭을 두개쓰고싶을때
class ClassName<K, V> {	
	private K first;	// K 타입(제네릭)
	private V second;	// V 타입(제네릭) 
	
	void set(K first, V second) {
		this.first = first;
		this.second = second;
	}
	
	K getFirst() {
		return first;
	}
	
	V getSecond() {
		return second;
	}
}
 
// 메인 클래스 
class Main {
	public static void main(String[] args) {
		
		ClassName<String, Integer> a = new ClassName<String, Integer>();
		
		a.set("10", 10);
 
 
		System.out.println("  fisrt data : " + a.getFirst());
		// 반환된 변수의 타입 출력 
		System.out.println("  K Type : " + a.getFirst().getClass().getName());
		
		System.out.println("  second data : " + a.getSecond());
		// 반환된 변수의 타입 출력 
		System.out.println("  V Type : " + a.getSecond().getClass().getName());
	}
}

//출력
first data : 10
K TYPE : java.lang.String
second data : 10
V Type : java.lang.Integer
=================================================================================
//제네릭 메서드
위의 클래스와 다르게 반환타입 이전에 <> 제네릭타입을 선언한다.
// 제네릭 클래스
class ClassName<E> {
	
	private E element;	// 제네릭 타입 변수
	
	void set(E element) {	// 제네릭 파라미터 메소드
		this.element = element;
	}
	
	E get() {	// 제네릭 타입 반환 메소드 
		return element;
	}
	
	// 제네릭 메소드, o라는 매개변수에는 Integer, String, Class를 던져줬다(아래 함수호출에서)
	// 이렇게 클래스에서 지정한 제네릭유형과 별도로 메소드에서 독립적으로 제네릭 유형을 선언하여 쓸 수 있다.
	<T> T genericMethod(T o) {	
		return o;
	}
 
	
}
 
public class Main {
	public static void main(String[] args) {
		
		ClassName<String> a = new ClassName<String>();
		ClassName<Integer> b = new ClassName<Integer>();
		
		a.set("10");
		b.set(10);
	
		System.out.println("a data : " + a.get());
		// 반환된 변수의 타입 출력 
		System.out.println("a E Type : " + a.get().getClass().getName());
		
		System.out.println();
		System.out.println("b data : " + b.get());
		// 반환된 변수의 타입 출력 
		System.out.println("b E Type : " + b.get().getClass().getName());
		System.out.println();
		
		// 제네릭 메소드 Integer
		// 제네릭 타입으로 받기 때문에 타입에맞게 결과가 나온다.
		System.out.println("<T> returnType : " + a.genericMethod(3).getClass().getName()); 
		
		// 제네릭 메소드 String
		System.out.println("<T> returnType : " + a.genericMethod("ABCD").getClass().getName());
		
		// 제네릭 메소드 ClassName
		System.out.println("<T> returnType : " + a.genericMethod(b).getClass().getName());
	}
}

//결과
a data : 10
a E Type : java.lang.String

b data : 10
b E Type : java.lang.Integer

<T> returnType : java.lang.Integer
<T> returnType : java.lang.String
<T> returnType : ClassName

=====================================================================
그러면 위와같은 방식이 왜 필요한가?? -> 정적메소드로 선언할 때 필요
위에서 제네릭은 유형을 외부에서 지정해주는걸 볼 수 있다.(외부에서 파라미터로 넘기면 그거를 타입으로 지정한다, 클래스도 마찬가지)

하지만, static은 프로그램 실행시 메모리에 이미 올라가있는것이다.
이말은 객체생성을 통해 접근 필요없이(위에서 a.set(10)이럴 필요없다는뜻이다 ) 클래스 이름을 통해 바로 쓸 수 있다.

근데... 어떻게 객체가 생성되기전에 타입을 가져오는거지?

일단 아래에 예시를 보자(에러나는 경우)
 class ClassName<E> {
 
	/*
	 * 클래스와 같은 E 타입이더라도
	 * static 메소드는 객체가 생성되기 이전 시점에
	 * 메모리에 먼저 올라가기 때문에
	 * E 유형을 클래스로부터 얻어올 방법이 없다.
	 */
	static E genericMethod(E o) {	// error!
		return o;
	}
	
}
 
class Main {
 
	public static void main(String[] args) {
 
		// ClassName 객체가 생성되기 전에 접근할 수 있으나 유형을 지정할 방법이 없어 에러남
		ClassName.getnerMethod(3);
 
	}
}
==========================================================================
이렇기 때문에 제네릭이 사용되는 메소드를 정적메소드로 두고 싶은 경우 제네릭 클래스와 별도로 독립적인 제네릭이 사용되어야 한다는 것이다.
// 제네릭 클래스
class ClassName<E> {
 
	private E element; // 제네릭 타입 변수
 
	void set(E element) { // 제네릭 파라미터 메소드
		this.element = element;
	}
 
	E get() { // 제네릭 타입 반환 메소드
		return element;
	}
 
	// 아래 메소드의 E타입은 제네릭 클래스의 E타입과 다른 독립적인 타입이다.
	static <E> E genericMethod1(E o) { // 제네릭 메소드
		return o;
	}
 
	static <T> T genericMethod2(T o) { // 제네릭 메소드
		return o;
	}
 
}
 
public class Main {
	public static void main(String[] args) {
 
		ClassName<String> a = new ClassName<String>();
		ClassName<Integer> b = new ClassName<Integer>();
 
		a.set("10");
		b.set(10);
 
		System.out.println("a data : " + a.get());
		// 반환된 변수의 타입 출력
		System.out.println("a E Type : " + a.get().getClass().getName());
 
		System.out.println();
		System.out.println("b data : " + b.get());
		// 반환된 변수의 타입 출력
		System.out.println("b E Type : " + b.get().getClass().getName());
		System.out.println();
 
		// 제네릭 메소드1 Integer
		System.out.println("<E> returnType : " + ClassName.genericMethod1(3).getClass().getName());
 
		// 제네릭 메소드1 String
		System.out.println("<E> returnType : " + ClassName.genericMethod1("ABCD").getClass().getName());
 
		// 제네릭 메소드2 ClassName a
		System.out.println("<T> returnType : " + ClassName.genericMethod1(a).getClass().getName());
 
		// 제네릭 메소드2 Double
		System.out.println("<T> returnType : " + ClassName.genericMethod1(3.0).getClass().getName());
	}
}

//결과
a data : 10
a E Type : java.lang.String

b data : 10
b E Type : java.lang.Integer

<E> returnType : java.lang.Integer
<E> returnType : java.lang.String
<T> returnType : ClassName
<T> returnType : java.lang.Double
============================================================
