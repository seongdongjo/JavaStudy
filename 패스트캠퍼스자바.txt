A -> 65 인코딩
65-> A 디코딩

각 나라별 문자세트가 다르니 호환이 안된다 그래서, 하나의 코드표로 통일하자 -> 유니코드(2byte표현)
-> 16비트 (2의 16승)

'a' -> 2byte 문자 -> 16bit -> 표현값개수 65536개 -> 문자라서 첫번째자리를 부호에 사용하지않기때문에 65536개이다.
short도 2byte이지만 부호가 표현되야하니 -32768~32767
"a" -> 문자열

//char는 자바에서 유니코드(2byte 문자체계)를 사용하므로 2byte이다
//c언어는 아스키코드를 사용하기 때문에 1byte크기를 갖는다.

유니코드란?

세계 각 국의 언어를 통일된 방법으로 표현할 수 있게 제안된 국제적인 코드 규약이다.
컴퓨터가 미국에서 개발되어져 영어를 바탕으로 정의되어 있다.
영어는 26자의 알파벳과 몇 가지 특수 문자를 표현하기에 1 byte로 충분했기 때문에
문자가 1 byte로 표현되고 있지만,
동양 3국의 한글, 한자 또는 일어 등과 같은 문자는 1 byte로는 표현이 불가능하기에
2 byte로 문자를 표현하는 유니코드가 만들어 졌다.

=======================================================================


//강제로
char ch1='A';
System.out.println((int)ch1);

int ch3 = 67;
System.out.println((char)ch3);


//변하지 않는 값은 + 공통적으로 쓰이는 -> final int max_num = 100;
//max_num = 20; 은 불가능

========================================================================
#)map 사용
public static void main(String[] args) {
	HashMap<String,Integer> map = new HashMap<String,Integer>();
	
	//키는 String, value는 Integer
	map.put("Soraka",450);
	map.put("Garen",4800);
	map.put("Garen",450); //중복된 key는 선언은 가능하지만 젤 마지막 선언된것이 덮어씌운다
	
	System.out.println("Map value: " + map.get("Garen"));  //450
	System.out.println("Map value: " + map.size());  //2
	
	map.replace("Garen", 160); //Key값의 내용을 변경
	
	System.out.println("Key Exist: " + map.containsKey("Garen")); //key가 존재하는지 확인
	System.out.println("Value Exist: " + map.containsValue(160)); //value가 존재하는지 확인
	
	System.out.println("Map Empty: " + map.isEmpty()); //map의 크기가 0인지 확인
	
	map.remove("Garen");
}

=========================================================================
#)HashMap은 Map인터페이스에 속해있는 컬렉션이다.따라서, map인터페이스의 기본 기능들을 전부구현할 수 있다
#)map의 keyset메서드 사용
public class Sample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("people", "사람");
        map.put("baseball", "야구");
        System.out.println(map.keySet());  // 키출력 --> [baseball, people] 출력
    }
}
==========================================================================
for(String key : map.keySet()) {
	System.out.println("Value: " + map.get(key));
}

==============================================================================
#)jackson이란
Java Object를 JSON으로 변환하거나 JSON을 Java Object로 변환하는데 사용할 수 있는 Java 라이브러리입니다.

==============================================================================
package ch03;

public class FunctionTest {
	public static int addNum(int num1, int num2) {
		int result;
		result = num1 + num2;
		return result;
	}
	
	public static void sayHello(String greeting) {
		System.out.println(greeting);
	}
	public static int calcSum() {
		int sum = 0;
		int i;
		for(i = 0; i<=100; i++) {
			sum += i; 
		}
		return sum;
	}
	
	public static void main(String[] args) {
		int n1=10;
		int n2=20;
		
		int total = addNum(n1,n2);
		System.out.println(total);
		
		sayHello("안녕하세요");
		
		total = calcSum();
		System.out.println(total);
	}
}

//스택: 함수가 호출될 때 지역변수들이 사용하는 메모리
//스택: 함수의 수행이 끝나면 자동으로 반환되는 메모리

=====================================================================================
package ch04;

public class Student {
	public int studentID;
	public String studentName;
	public String address;
	
	public void showStudentInfo() {
		System.out.println(studentID + "학번의 이름은" + studentName + "이고 주소는" + address + "입니다.");
	}
	
	public String getStudentName() {
		return studentName;
	}
	
	public void setStudentName(String name) {
		studentName = name;
	}
}
----------------
package ch04;

public class MainStudent {
	public static void main(String[] args) {
		Student studentLee = new Student(); //인스턴스라고한다, 같은 패키지내에서는 import 안한다
		Student studentKim = new Student();
		
		//인스턴스들은(studentLee, studentKim) 동적메모리(Heap)에 할당된다.
		//c나 c++에서는 사용한 동적메모리를 프로그래머가 해제시켜야한다.(free, delete)
		//자바에서는 가비지컬렉터가 주기적으로 사용하지 않는 메모리를 수거한다.
		//하나의 클래스로부터 여러개의 인스턴스가 생성되고 각각 다른 메모리 주소를 가지게 된다.
		
		studentLee.studentID = 12345;
		studentLee.setStudentName("Lee");
		studentLee.address = "서울 강남구";
		
		studentLee.showStudentInfo();
		
		System.out.println(studentKim); //ch04.Student@36aa7bc2 -> 객체의 위치를 가리키는(Heap에 있는 인스턴스를 가리킨다) 주소값이다. (물리적 메모리주소가 아니라 JVM이 준 가상 주소)
		//그래서 studentKim. (점.)을 찍음으로써 접근
		System.out.println(studentLee);
		
		//인스턴스 : new 키워드를 사용하여 클래스를 메모리에 생성한 상태(힙)
		//참조변수: 메모리에 생성된 인스턴스를 가리키는 변수(스택)
		//참조값: 생성된 인스턴스의 메모리 주소값
	}
}
=========================================================================================
package ch06;

public class Student { //멤버변수는 알아서 초기화된다. null, 0
	public int studentNumber;
	public String studentName;
	public int grade;
	
	public Student() {
		System.out.println("생성자");
	}
	
	public Student(int studentNumber, String studentName, int grade) {
		this.studentNumber = studentNumber; //변수이름이 다르면 this붙일필요가없다
		this.studentName = studentName;
		this.grade = grade;
	}
	
	public String showStudentInfo() {
		int i; //i는 초기화되지 않는다.(지역변수라서)
		return studentName + "학생의 학번은" + studentNumber + "이고, " + grade + "학년 입니다.";
	}
}
----------------
package ch06;

public class StudentMain {
	public static void main(String[] args) {
		Student studentLee = new Student();
		Student studentKim = new Student(123456, "Kim", 3);
		
		System.out.println(studentKim.showStudentInfo()); 
		
		System.out.println(studentLee.showStudentInfo()); //null,0~
	}
}
============================================================================================
package ch09;

public class Student {
	int studentId;
	String studentName;
	
	Subject korea; //class내에서 쓸수있도록(전역변수? 느낌)
	Subject math;
	
	Student(int studentId, String studentName) {
		this.studentId = studentId;
		this.studentName = studentName;
		
		korea = new Subject();
		math = new Subject();
	}
	
	public void setKoreaSubject(String name, int score) {
		korea.subjectName = name;
		korea.score = score;
	}
	
	public void setMathSubject(String name, int score) {
		math.subjectName = name;
		math.score = score;
	}
	
	public void showScoreInfo() {
		int total = korea.score + math.score;
		System.out.println(studentName + "학생의 총점은" + total + "점 입니다.");
	}
}
-------------------
package ch09;

public class Subject {
	String subjectName;
	int score;
	int subjectId;
}
-------------------
package ch09;

public class SubjectMain {
	public static void main(String[] args) {
		Student studentLee = new Student(100, "Lee");
		studentLee.setKoreaSubject("국어", 100);
		studentLee.setMathSubject("수학", 99);
		
		Student studentKim = new Student(200, "Kim");
		studentKim.setKoreaSubject("국어", 80);
		studentKim.setMathSubject("수학", 100);
		
		studentLee.showScoreInfo();
		studentKim.showScoreInfo();
	}
}
=======================================================================================
package ch10;

public class BirthDay {
	private int day; //같은 클래스내에서만 접근 -> private
	private int month;
	private int year;
	
	private boolean isVaild; //기본값이 false
	
	public int getDay() {
		return day;
	}
	public void setDay(int day) {
		this.day = day;
	}
	public int getMonth() {
		return month;
	}
	public void setMonth(int month) {
		if(month < 1 || month > 13) {
			isVaild = false;
		}
		else {
			isVaild = true;
			this.month = month;
		}
	}
	public int getYear() {
		return year;
	}
	public void setYear(int year) {
		this.year = year;
	}
	
	public void showDate() {
		if(isVaild) { //true이면
			System.out.println(year + "년 " + month + "월 " + day + "일 입니다.");
		}
		else {
			System.out.println("유효하지 않은 날짜입니다.");
		}
	}
}
----------------
package ch10;

public class BirthDayMain {
	public static void main(String[] args) {
		BirthDay date = new BirthDay();
		date.setYear(2019);
		
		//private를 쓰는이유는 
		//date.month = 100 이렇게 범위를 벗어난값을 바로 대입가능하기 때문이다.
		//그래서 setter를 통해 제약을 걸었다.
		
		//date.setMonth(13);  month가 1~12사이가 아닌것은 처리 xx, BirthDay클래스에서 처리했다, 유효하지 않은 날짜라고 뜬다.
		date.setDay(30);
	}
}
=========================================================================
package ch11;

public class MakeReport {

	StringBuffer buffer = new StringBuffer(); //append메서드로 String을 연결한다
	
	private String line = "===========================================\n";
	private String title = "  이름\t   주소 \t\t  전화번호  \n";
	private void makeHeader()
	{
		buffer.append(line);
		buffer.append(title);
		buffer.append(line);
	}
	
	private void generateBody()
	{
		buffer.append("James \t");
		buffer.append("Seoul Korea \t");
		buffer.append("010-2222-3333\n");
		
		buffer.append("Tomas \t");
		buffer.append("NewYork US \t");
		buffer.append("010-7777-0987\n");
	}
	
	private void makeFooter()
	{
		
		buffer.append(line);
	}
	
	public String getReport()
	{
		makeHeader();
		generateBody();
		makeFooter();
		return buffer.toString();
	}
}
-----------------
package ch11;

public class MainReport {

	public static void main(String[] args) {

		MakeReport report = new MakeReport();
		String builder = report.getReport();
		
		System.out.println(builder);
	}

}
====================================================================
package ch12;

public class Person {
	String name;
	int age;
	
	public Person() {
		//age = 10;
		//name = "test"
		//this위에 쓰면 안된다. 객체가 만들어지기 전이기 때문에
		this("no name", 1);
	}
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	public void showPerson() {
		System.out.println(name + ", " + age);
	}
	public Person getPerson() { 
		return this; //객체자신을 반환
	}
	
	public static void main(String[] args) {
		Person person = new Person();
		person.showPerson(); //no name, 1
		
		System.out.println(person);  //ch12.Person@1175e2db
		
		Person person2 = person.getPerson(); //person2도 person을 바라본다.
		System.out.println(person2); //ch12.Person@1175e2db 같다.  this == main의 Person 이 같은 Heap공간의 Person을 가리킨다
		
	}
}
===============================================================================
package ch14;

public class Student {
	String studentName;
	int money;
	
	public Student(String studentName, int money) {
		this.studentName = studentName;
		this.money = money;
	}
	
	public void takeBus(Bus bus) {
		bus.take(1000); //버스를타면 1000원을 지불
		this.money -= 1000;
	}
	
	public void takeSubway(Subway subway) {
		subway.take(1200);
		this.money -= 1200;
	}
	
	public void showInfo() {
		System.out.println(studentName + "님의 남은 돈은 " + money + "원 입니다.");
	}
	
}
--------------
package ch14;

public class Subway {
	int lineNumber;
	int passengerCount; //승객수
	int money;
	
	public Subway(int busNumber) {
		this.lineNumber = busNumber;
	}
	
	public void take(int money) {
		this.money = money;
		passengerCount++;
	}
	
	public void showsubwayInfo() {
		System.out.println(lineNumber + "번의 승객 수는 " + passengerCount + "명 이고, 수입은 " + money + "원 입니다.");
	}
}
---------------
package ch14;

public class TakeTransTest {

	public static void main(String[] args) {
		Student studentJ = new Student("James", 5000);
		Student studentT = new Student("Tomas", 10000);
		
		Bus bus100 = new Bus(100);  //버스넘버
		Bus bus500 = new Bus(500);
		
		studentJ.takeBus(bus100); //studentJ가 bus100을 탔다.
		
		Subway greenSubway = new Subway(2); //lineNumber
		studentT.takeSubway(greenSubway);
		
		studentJ.showInfo();
		studentT.showInfo();
		
		bus100.showBusInfo();
		greenSubway.showsubwayInfo();
	}

	/*
	 * James님의 남은 돈은 4000원 입니다. 
	 * Tomas님의 남은 돈은 8800원 입니다. 
	 * 100번의 승객 수는 1명 이고, 수입은
	 * 1000원 입니다. 2번의 승객 수는 1명 이고, 수입은 1200원 입니다.
	 */
}
========================================================================
package ch16;

public class Employee {
	//static변수는 프로그램이 실행되면서 메모리에 로드될때 같이 적재된다. (객체 생성 전)
	public static int serialNum = 1000; //public이라서 외부에서 클래스.serialNum 접근가능하다
	
		private int employeeId;
		private String employeeName;
		private String department;
			
		public Employee()
		{
			serialNum++;
			employeeId = serialNum;
		}
		
		public int getEmployeeId() {
			return employeeId;
		}
		public void setEmployeeId(int employeeId) {
			this.employeeId = employeeId;
		}
		public String getEmployeeName() {
			return employeeName;
		}
		public void setEmployeeName(String employeeName) {
			this.employeeName = employeeName;
		}
		public String getDepartment() {
			return department;
		}
		public void setDepartment(String department) {
			this.department = department;
		}
}
--------------
package ch16;

public class EmployeeTest {

	public static void main(String[] args) {
		Employee employeeLee = new Employee();
		employeeLee.setEmployeeName("이순신");
				
		Employee employeeKim = new Employee();
		employeeKim.setEmployeeName("김유신");
				
		System.out.println(employeeLee.getEmployeeName() + "," + employeeLee.getEmployeeId());
		System.out.println(employeeKim.getEmployeeName() + "," + employeeKim.getEmployeeId());
		
		System.out.println(Employee.serialNum); //static변수는 클래스로 바로 접근 가능
	}
}
===================================================================
package ch17;

public class Employee {
	private static int serialNum = 1000; //private로 고쳤다 -> getter로 가져와야한다
		
		private int employeeId;
		private String employeeName;
		private String department;
			
		public Employee()
		{
			serialNum++;
			employeeId = serialNum;
		}
		
		public static int getSerialNum() {
			return serialNum;
		}
	
		public static void setSerialNum(int serialNum) { //serialNum을 직접 변경할 때
			int i = 0;
			
		//	employeeName = "Lee";  //오류발생 static이라서
			Employee.serialNum = serialNum; //공통으로 쓰는 static값 변경
		}
	
		public int getEmployeeId() {
			return employeeId;
		}
		public void setEmployeeId(int employeeId) {
			this.employeeId = employeeId;
		}
		public String getEmployeeName() {
			return employeeName;
		}
		public void setEmployeeName(String employeeName) {
			this.employeeName = employeeName;
		}
		public String getDepartment() {
			return department;
		}
		public void setDepartment(String department) {
			this.department = department;
		}
}
----------------
package ch17;

public class EmployeeTest {

	public static void main(String[] args) {
		Employee employeeLee = new Employee();
		employeeLee.setEmployeeName("이순신");
				
		Employee employeeKim = new Employee();
		employeeKim.setEmployeeName("김유신");
				
		System.out.println(employeeLee.getEmployeeName() + "," + employeeLee.getEmployeeId());
		System.out.println(employeeKim.getEmployeeName() + "," + employeeKim.getEmployeeId());
		
		System.out.println(Employee.getSerialNum()); //SerialNum은 private라서 getter로 가져옴
	}
}
---------------------
package ch17;

public class EmployeeTest2 {

	public static void main(String[] args) {
		System.out.println(Employee.getSerialNum());
		Employee.setSerialNum(1003);
		System.out.println(Employee.getSerialNum());
	}

}
================================================================================
package singleton18;

public class Company {
	//싱글톤 패턴: 프로그램에서 인스턴스가 단 한 개만 생성되어야 하는 경우 사용하는 디자인 패턴
	//Timezone같은 시간은 인스턴스를 각각 가질수없다. (동일한시간을 가져야하니까)
	//회사라는 객체는 하나여야만한다.(사원도 또 늘어나니까)
	//이런경우 싱글톤패턴이 필요
	
	//static은 프로그램실행될 때 메모리에 로드된다. 따라서 한번만 만든다.
	private static Company instance = new Company(); //유일한 객체를 한번만 미리만들어놓는다.
	
	//컴파일러가 기본으로 생성하는 외부에서 Company를 마음대로 new할 수 없도록
	private Company() {}
	
	//클래스로 바로 접근할수있게끔 static까지 
	public static Company getInstance() {
		if(instance == null) {
			instance = new Company();
		}
		return instance;
	}
}
---------------
package singleton18;

import java.util.Calendar;

public class CompanyTest {
	public static void main(String[] args) {
		Company company1 = Company.getInstance(); //static이라 클래스로 접근
		Company company2 = Company.getInstance();
		
		System.out.println(company1); //값이 같다.
		System.out.println(company2);
		
		Calendar calendar = Calendar.getInstance(); //이것도 마찬가지
		
	}
}
=======================================================================
package singletontest;

public class CarFactory {
	private static CarFactory instance = new CarFactory();
		
		private CarFactory() {}
		
		public static CarFactory getInstance() {
			if(instance == null) {
				instance = new CarFactory();
			}
			return instance;
		}
		
		//공장안에서 Car를 만들기 때문에
		public Car createCar() { //반환은 Car
			
			Car car = new Car(); 
			return car;
		}
}
---------------
package singletontest;

public class Car {
	private static int serialNum = 10000;
	private int carNum;
	
	public Car() {
		serialNum++;
		carNum = serialNum;
	}

	public int getCarNum() {
		return carNum;
	}

	public void setCarNum(int carNum) {
		this.carNum = carNum;
	}
	
	
}
----------------
package singletontest;

public class CarFactoryTest {

	public static void main(String[] args) {
		CarFactory factory = CarFactory.getInstance();
		Car mySonata = factory.createCar();
		Car yourSonata = factory.createCar();
		
		System.out.println(mySonata.getCarNum());
		System.out.println(yourSonata.getCarNum());
	}

}
=================================================================
package taxi;

public class Student {
	String studentName;
	int grade;
	int money;
	
	public Student(String studentName, int money) {
		this.studentName = studentName;
		this.money = money;
	}
	
	public void takeTaxi(Taxi taxi) {
		taxi.take(10000);  //taxi객체 money증가
		this.money -= 10000;
	}
	
	public void showInfo() {
		System.out.println(studentName + "님의 남은 돈은 " + money + "원 입니다.");
	}
}
----------------
package taxi;

public class Student {
	String studentName;
	int grade;
	int money;
	
	public Student(String studentName, int money) {
		this.studentName = studentName;
		this.money = money;
	}
	
	public void takeTaxi(Taxi taxi) {
		taxi.take(10000);  //taxi객체 money증가
		this.money -= 10000;
	}
	
	public void showInfo() {
		System.out.println(studentName + "님의 남은 돈은 " + money + "원 입니다.");
	}
}
-----------------
package taxi;

public class Taxi {
	String companyName;
	int money;
	
	public Taxi(String companyName) {
		this.companyName = companyName;
	}
	
	public void take(int money) {
		this.money += money;
	}
	
	public void showTaxiInfo() {
		System.out.println(companyName + "택시 수입은 " + money + "원 입니다.");
	}
}
========================================================================================
#)배열
int[] arr1 = new int[10];
int arr2[] = new int[10];
int[] arr3 = new int[] {10,20,30};
int[] arr4 = {10,20,30};

int[] arr5;
arr5 = new int[] {10,20,30};

for(int i = 0, num=1; i<arr.length; i++) {
	arr[i] = num++;
}

//처음부터 끝까지 돌릴때
for(int num : arr) {
	total += num;
}
--------------
//length를 활용하여 오류나는경우 -> length는 5인데 실제데이터는 3개만 들어가있다.
double[] dArr = new double[5];

dArr[0] = 1.1;
dArr[1] = 1.1;
dArr[2] = 1.1;

double mtotal = 1;
for(int i = 0; i<dArr.lengthl i++) {
	mtotal *= dArr[i];
}
--------------
//해결법: 요소의 개수에 대한 변수(count)를 유지
double[] dArr = new double[5];
int count = 0;
dArr[0] = 1.1; count++;
dArr[1] = 1.1; count++;
dArr[2] = 1.1; count++;

double mtotal = 1;
for(int i = 0; i<count; i++) {
	mtotal *= dArr[i];
}
----------------
package ch20;

public class CharArrayTest {
	public static void main(String[] args) {
		char[] alphabets = new char[26];
		char ch = 'A';
		
		for(int i =0; i<alphabets.length; i++) {
			alphabets[i] = ch++;
		}
		for(char alpha : alphabets) {
			System.out.println(alpha + ", " + (int)alpha);
		}
	}
}
==========================================================================================
package ch21;

public class Book {
	private String title;
	private String author;
	
	public Book() {}
	public Book(String title, String author) {
		this.title = title;
		this.author = author;
	}
	
	public String getTitle() {
		return title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public String getAuthor() {
		return author;
	}
	public void setAuthor(String author) {
		this.author = author;
	}
	
	public void showInfo() {
		System.out.println(title + ", " + author);
	}
	
}
------------------
package ch21;

public class BookTest {

	public static void main(String[] args) {
		Book[] library = new Book[5]; //null로 초기화, new한다고 Book개게가 만들어지는게 아니다.
		
		library[0] = new Book("태백산맥1", "조정래"); //객체를 만들어서 넣어야한다. 
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		for(Book book : library) {
			System.out.println(book); //ch21.Book@36aa7bc2  처럼 각기다른 5개 나옴
			book.showInfo();
		}
		
		
	}

}
--------------------
package ch21;

public class ObjectCopyTest {
	public static void main(String[] args) {
		Book[] library = new Book[5]; //null로 초기화, new한다고 Book개게가 만들어지는게 아니다.
		Book[] copyLibrary = new Book[5];
		
		library[0] = new Book("태백산맥1", "조정래"); //객체를 만들어서 넣어야한다. 
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		System.arraycopy(library, 0, copyLibrary, 0, 5); //library 0번쨰부터 복사해서 copyLibrary의 0에서5까지 넣어라(주소가 같은 상태이다)
	
		//기존 book
		for(Book book : library) {
			System.out.println(book);  //주소가같다.
			book.showInfo();
		}
		
		//복사한
		for(Book book : copyLibrary) { //주소가같다.
			System.out.println(book); 
			book.showInfo();
		}
		
		//주소가같아서 library0번째만 바꿧는데 copyLibrary도 같이 바뀐다.
		library[0].setAuthor("박완서");
		library[0].setTitle("나목");
		
	}
	//이런게 얕은복사이다.
}
-------------------
package ch21;

public class ObjectCopyTest2 {
	public static void main(String[] args) {
		Book[] library = new Book[5]; 
		Book[] copyLibrary = new Book[5];
		
		library[0] = new Book("태백산맥1", "조정래");
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		//깊은 복사 방식
		copyLibrary[0] = new Book();
		copyLibrary[1] = new Book();
		copyLibrary[2] = new Book();
		copyLibrary[3] = new Book();
		copyLibrary[4] = new Book();
		
		for(int i =0; i<library.length; i++) {
			copyLibrary[i].setAuthor(library[i].getAuthor());
			copyLibrary[i].setTitle(library[i].getTitle());
		}
		
		
		//주소가같아서 library0번째만 바꿧는데 copyLibrary[0]는 안바뀐다.
		library[0].setAuthor("박완서");
		library[0].setTitle("나목");
		
				//기존 book
				for(Book book : library) {
					System.out.println(book);  //주소가다르다
					book.showInfo();
				}
				
				//복사한
				for(Book book : copyLibrary) { //주소가 다르다
					System.out.println(book); 
					book.showInfo();
				}
	}
}
==============================================================================
package ch22;

public class TwoDimensionTest {
	public static void main(String[] args) {
		int[][] arr = { {1,2,3}, {4,5,6,7}};
		//int[][] arr = new int[3][4];
		
		int i, j;
		
		for(i =0; i<arr.length; i++) {
			for(j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j] + " ");
			}
			System.out.println(", \t" + arr[i].length);
			System.out.println();
		}
	}
}
/* 결과
 * 1 2 3 , 3
 * 
 * 4 5 6 7 , 4
 */
 ==========================================================
 package ch23;

import java.util.ArrayList;

import ch21.Book;

public class ArrayListTest {

	public static void main(String[] args) {
		//기존 배열방식은 길이가 고정이라서 배열의 길이가 커지면 배열을 재할당하고 복사해야했다.
		//ArrayList는 동적
		
		ArrayList<Book> library = new ArrayList<Book>(); //book객체를 가리키는 주소가 array형식으로 만들겠다.
				
				library.add(new Book("태백산맥1", "조정래"));
				library.add(new Book("태백산맥2", "조정래"));
				library.add(new Book("태백산맥3", "조정래"));
				library.add(new Book("태백산맥4", "조정래"));
				library.add(new Book("태백산맥5", "조정래"));
				
				for(int i =0; i<library.size(); i++) {
					library.get(i).showInfo();
				}
			}

}
==============================================================
package ch24;

public class Subject {
	private String name; //과목이름
	private int scorePoint; //점수
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getScorePoint() {
		return scorePoint;
	}
	public void setScorePoint(int scorePoint) {
		this.scorePoint = scorePoint;
	}
}
----------------
package ch24;

import java.util.ArrayList;

public class Student {
	int studentID;
	String studentName;
	ArrayList<Subject> subjectList; //이게 Has-A 방식 (subject를 상속받는게아니라) -> 클래스가 다른 클래스를 포함하는 관계
		
	public Student(int studentID, String studentName){
		this.studentID = studentID;
		this.studentName = studentName;
		
		subjectList = new ArrayList<Subject>();
	}
	
	public void addSubject(String name, int score){
		Subject subject = new Subject();
		
		subject.setName(name);
		subject.setScorePoint(score);
		subjectList.add(subject);
	}
	
	public void showStudentInfo()
	{
		int total = 0;
		
		for(Subject s : subjectList){
			
			total += s.getScorePoint();
			System.out.println("학생 " + studentName + "의 " + s.getName() + " 과목 성적은 " + 
			        s.getScorePoint() + "입니다.");
		}
			
		System.out.println("학생 " + studentName + "의 총점은 " + total + " 입니다.");
	}
}
-----------------
package ch24;

public class StudentTest {
	public static void main(String[] args) {
		Student studentLee = new Student(1001, "Lee");
		
		studentLee.addSubject("국어", 100);
		studentLee.addSubject("수학", 50);
		
		Student studentKim = new Student(1002, "Kim");
		
		studentKim.addSubject("국어", 70);
		studentKim.addSubject("수학", 85);
		studentKim.addSubject("영어", 100);
		
		studentLee.showStudentInfo();
		System.out.println("======================================");
		studentKim.showStudentInfo();
	}
}
==================================================================================
package ch2;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //가격의 1퍼센트를 기존 보너스포인트에 쌓는다.
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}

-----------------
package ch2;

//만약에 VIPCustomer 클래스없이 Customer로만 만들려면 if문돌려서 gold,silver 분류해서 할인율, 또 요구조건이 생기면 계속 if문 쓰면 너무 번거롭다.
//그래서 VIPCustomer로 별도로 뺸다.
public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio; //VIP에만 있는 변수
	
	public VIPCustomer() { //생성자
		//super();
		customerGrade = "VIP";//덮어쓰기    //오류 발생 -> extends를 해야한다(protected라서), private은 extends해도 안됨.
		bonusRatio = 0.05; //덮어쓰기 마찬가지 
		salesRatio = 0.1;
	}
	
	public int getAgentID() { //안씀
		return agentID;
	}
}

---------------------
package ch2;

public class CustomerTest {
	public static void main(String[] args) {
		Customer customerLee = new Customer();
		customerLee.setCustomerName("이순신");
		customerLee.setCustomerID(10010);
		customerLee.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee.showCustomerInfo());
			
			
		VIPCustomer customerKim = new VIPCustomer();  //new VIPCustomer()를 호출하면 Customer()생성자가 먼저 호출된다.
		customerKim.setCustomerName("김유신"); //부모의 메서드
		customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim.showCustomerInfo()); //vip로 생성자만들었으니 잘나온다.
	}
}
이순신님의 등급은 SILVER이며, 보너스 포인트는 1000입니다
김유신님의 등급은 VIP이며, 보너스 포인트는 10000입니다
=============================================================================
package ch3;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public Customer(int customerID, String customerName) {
		this.customerID = customerID;
		this.customerName = customerName;
		
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //가격의 1퍼센트를 기존 보너스포인트에 쌓는다, 현재는 vip는 계산이안됨,vip에서 bonusratio를 재정의해도 calcPrice에서 찾아가지못함.
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}
-------------------
package ch3;

public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio; //VIP에만 있는 변수
	
	public VIPCustomer() {
		//super();
		customerGrade = "VIP"; 
		bonusRatio = 0.05;
		salesRatio = 0.1;
	}
	
	public VIPCustomer(int customerID, String customerName) {
		super(customerID, customerName);
		customerGrade = "VIP"; //덮어쓰기 super()에서 정의된 customerGrade를   
		bonusRatio = 0.05; //마찬가지로 덮어쓰기
		salesRatio = 0.1;
		//아직 보너스포인트, 가격은 정의안함
	}
	
	public int getAgentID() {
		return agentID;
	}
}
----------------------
package ch3;

public class CustomerTest {
	public static void main(String[] args) {
		Customer customerLee = new Customer(); //디폴트 생성자
		customerLee.setCustomerName("이순신");
		customerLee.setCustomerID(10010);
		customerLee.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee.showCustomerInfo());
		
		Customer customerLee2 = new Customer(10030, "홍길동");
		//customerLee.setCustomerName("홍길동");
		//customerLee.setCustomerID(10010);
		customerLee2.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee2.showCustomerInfo());
			
			
		VIPCustomer customerKim = new VIPCustomer();  //new VIPCustomer()를 호출하면 Customer()생성자가 먼저 호출된다.
		customerKim.setCustomerName("김유신"); //부모의 메서드
		customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim.showCustomerInfo());
		
		VIPCustomer customerKim2 = new VIPCustomer(10040, "강지은"); 
		//customerKim.setCustomerName("김유신"); //부모의 메서드
		//customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim2.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim2.showCustomerInfo());
	}
	
	//업캐스팅
	//Customer customerLee = new VIPCustomer(); 
	//customerLee.  으로 쓸수있는걸보면 Customer만 쓸수있다.(오버라이딩된거, 부모의 멤버변수만 쓸수있다)
}
==========================================================================================
package ch4;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	/*public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
		
		System.out.println("Customer() 생성자 호출");
	}*/
	
	public Customer(int customerID, String customerName) {
		this.customerID = customerID;
		this.customerName = customerName;
		
		customerGrade = "SILVER";
		bonusRatio = 0.01;
		//System.out.println("Customer(int, String) 생성자 호출");
	}
	
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}
---------------------
package ch4;

public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio;
	
	/*public VIPCustomer() {
		customerGrade = "VIP";    //오류 발생, why? customer에서 기본생성자를 주석처리 했기때문에
		bonusRatio = 0.05;
		salesRatio = 0.1;
		
		System.out.println("VIPCustomer() 생성자 호출");
	}
	*/
	
	public VIPCustomer(int customerID, String customerName) {
		super(customerID, customerName);
		
		customerGrade = "VIP";
		bonusRatio = 0.05;
		salesRatio = 0.1;
		
		//System.out.println("VIPCustomer(int, String) 생성자 호출");
	}
	
	
	//오버라이딩의 조건은 함수명, 매개변수, 타입까지 다 같아야한다.
	@Override
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price - (int)(price * salesRatio);
	}



	public int getAgentID() {
		return agentID;
	}
	
	@Override
	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade +  
				"이며, 보너스 포인트는 " + bonusPoint + "입니다(vip)";  //여기쓰인 변수들은 부모의 변수를 쓰고있다.
	}
}
---------------------
package ch4;

public class CustomerTest {
	public static void main(String[] args) {
			//함수의 이름이 주소값이다.
		 	//메서드는 명령어의 set이고 프로그램이 로드되면 메서드 영역(코드영역)에 명령어 set이 위치
			//해당 메서드가 호출되면 명령어 set이 있는 주소를 찾아 명령어가 실행됨
			//이때 메서드에서 사용하는 변수들은 스택메모리에 위치한다
			//따라서 다른 인스턴스라도 같은 메서드의 코드는 같으므로 같은 메서드가 호출됨
			//인스턴스가 생성되면 변수는 힙메모리에 따로 생성되지만, 메서드 명령어 set은 처음 한번만 로드됨
		
			//가상메소드란
			//상속에서 상위클래스와 하위 클래스에 같은 이름의 메서드((재정의함수)가 존재할 때 호출되는 메소드는 인스턴스에 따라 결정된다.
			//선언한 클래스형이 아닌 생성된 인스턴스의 메서드를 호출하는것
			//그떄, 인스턴스의 메서드가 호출되는 기술을 가상메서드라고한다.
		
			//같은 객체의 인스턴스를 여러개 생성한다고 해서 메소드도 여러개 생성되지 않는다.
			//즉, new Customer 를 여러번한다고 해서 a라는 메서드가 여러개 생성되지 않는다.(하나를 공유(메모리주소로))
			//예외적으로 사용하는 지역변수는 stack에 생성되서 잡힘
		
			Customer customerLee = new Customer(10010, "이순신");
			customerLee.bonusPoint = 1000;
			System.out.println(customerLee.showCustomerInfo());
			
			VIPCustomer customerKim = new VIPCustomer(10020, "김유신");
			customerKim.bonusPoint = 10000;
			System.out.println(customerKim.showCustomerInfo());
			
			int priceLee = customerLee.calcPrice(10000); //구입가격대입
			int priceKim = customerKim.calcPrice(10000); //구입가격대입
			
			System.out.println(customerLee.showCustomerInfo() + " 지불금액은 " + priceLee + "원 입니다.");
			System.out.println(customerKim.showCustomerInfo() + " 지불금액은 " + priceKim + "원 입니다.");
			
			//업캐스팅
			Customer customerNo = new VIPCustomer(10030, "나몰라"); 
			customerNo.bonusPoint = 10000;
			int priceNo = customerNo.calcPrice(10000); //오버라이딩한 VIPCustomer를 찾아간다.
			System.out.println(customerNo.showCustomerInfo() + " 지불금액은 " + priceNo  + "원 입니다."); //오버라이딩한 show를 찾아간다
			
			//나몰라님의 등급은 VIP이며, 보너스 포인트는 10500입니다 지불금액은 9000원 입니다.
		}
}
=============================================================================================
package ch6;

import java.util.ArrayList;
//정보은닉, 상속과 더불어 다형성은 객체지향 프로그래밍의 가장 큰 특징 중 하나이다.
class Animal{
	
	public void move() {
		System.out.println("동물이 움직입니다.");
	}
	
	public void eating() {
		
	}
}

class Human extends Animal{
	@Override
	public void move() {
		System.out.println("사람이 두발로 걷습니다.");
	}
	
	public void readBooks() {
		System.out.println("사람이 책을 읽습니다.");
	}
}

class Tiger extends Animal{
	@Override
	public void move() {
		System.out.println("호랑이가 네 발로 뜁니다.");
	}
	
	public void hunting() {
		System.out.println("호랑이가 사냥을 합니다.");
	}
}


class Eagle extends Animal{
	@Override
	public void move() {
		System.out.println("독수리가 하늘을 날아갑니다.");
	}
	
	public void flying() {
		System.out.println("독수리가 날개를 쭉 펴고 멀리 날아갑니다");
	}
}

public class AnimalTest {
	public static void main(String[] args) {

		Animal hAnimal = new Human();
		Animal tAnimal = new Tiger();
		Animal eAnimal = new Eagle();
		
		//출력방법 1
		AnimalTest test = new AnimalTest(); //밑에 moveAnimal함수쓸려고 갹체 생성
		test.moveAnimal(hAnimal);
		test.moveAnimal(tAnimal);
		test.moveAnimal(eAnimal);
		
		
		//출력방법2
		ArrayList<Animal> animalList = new ArrayList<Animal>();
		animalList.add(hAnimal);
		animalList.add(tAnimal);
		animalList.add(eAnimal);
		
		for(Animal animal : animalList) {
			animal.move();
		}
	}	
	//main밖에서 함수정의해야한다.
	public void moveAnimal(Animal animal) {
		animal.move(); //이런게 다형성이다. 같은 move라는 메서드이지만 출력결과는 다르다.
		
	}
	
}
===========================================================================================
package ch6;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer()
	{
		initCustomer();
	}

	public Customer(int customerID, String customerName){
		this.customerID = customerID;
		this.customerName = customerName;
		
		initCustomer();
	}
	
	private void initCustomer() //회원등급과 보너스포인트비율을 초기화
	{
		customerGrade = "SILVER";
		bonusRatio = 0.01;	
	}
	
	public int calcPrice(int price){
		bonusPoint += price * bonusRatio;
		return price;
	}
	
	public String showCustomerInfo(){
		return customerName + " 님의 등급은 " + customerGrade + "이며, 보너스 포인트는 " + bonusPoint + "입니다.";  
	}
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}
}
---------------
package ch6;

public class GoldCustomer extends Customer{

	double saleRatio;
		
		public GoldCustomer(int customerID, String customerName){
			super(customerID, customerName);
		
			customerGrade = "GOLD"; //부모의 멤버변수니까 showInfo는 오버라이딩 안했음. 
			bonusRatio = 0.02;   	//부모의 멤버변수
			saleRatio = 0.1;		//내꺼
		
		}
		@Override
		public int calcPrice(int price){
			bonusPoint += price * bonusRatio;
			return price - (int)(price * saleRatio);
		}
}
-------------------
package ch6;

public class VIPCustomer extends Customer{
	private int agentID;
	double saleRatio;
	
	public VIPCustomer(int customerID, String customerName, int agentID){
		super(customerID, customerName);
	
		customerGrade = "VIP";
		bonusRatio = 0.05;
		saleRatio = 0.1;
		this.agentID = agentID;
	}
	@Override
	public int calcPrice(int price){
		bonusPoint += price * bonusRatio;
		return price - (int)(price * saleRatio);
	}
	@Override
	public String showCustomerInfo(){
		return super.showCustomerInfo() + " 담당 상담원 번호는 " + agentID + "입니다";  //super.showInfo로 부모메소드부른후 뒤에 문자열 추가
	}

	public int getAgentID(){
		return agentID;
	}
}
-----------------
package ch6;

import java.util.ArrayList;

public class CustomerTest {
	public static void main(String[] args) {
			
			ArrayList<Customer> customerList = new ArrayList<Customer>();
			
			Customer customerLee = new Customer(10010, "이순신");
			Customer customerShin = new Customer(10020, "신사임당");
			Customer customerHong = new GoldCustomer(10030, "홍길동");
			Customer customerYul = new GoldCustomer(10040, "이율곡");
			Customer customerKim = new VIPCustomer(10050, "김유신", 12345);
			
			customerList.add(customerLee);
			customerList.add(customerShin);
			customerList.add(customerHong);
			customerList.add(customerYul);
			customerList.add(customerKim);
			
			System.out.println("====== 고객 정보 출력 =======");
			
			for( Customer customer : customerList){
				System.out.println(customer.showCustomerInfo());
			}
			
			System.out.println("====== 할인율과 보너스 포인트 계산 =======");
			
			int price = 10000;
			for( Customer customer : customerList){
				int cost = customer.calcPrice(price); //재정의된 calcPrice를 찾는다.
				System.out.println(customer.getCustomerName() +" 님이 " +  + cost + "원 지불하셨습니다."); //Customer로 업캐스팅 했기때문에 Customer의 bonusPoint를 가져올수있다.
				System.out.println(customer.getCustomerName() +" 님의 현재 보너스 포인트는 " + customer.bonusPoint + "점입니다."); //new로 생성할 때는 vip,customer,gold로 구분했기때문에 알아서 bonusPoint 찾아간다.
			}
		}
}
===================================================================
package ch8;

import java.util.ArrayList;

//다운캐스팅은 명시적으로 해야한다.
//Customer vc = new VIPCustomer(); 묵시적
//VIPCustomer vCustomer = (VIPCustomer)vc; 명시적(다운캐스팅)

	class Animal{
		
		public void move() {
			System.out.println("동물이 움직입니다.");
		}
		
		public void eating() {
			
		}
	}

	class Human extends Animal{
		public void move() {
			System.out.println("사람이 두발로 걷습니다.");
		}
		
		public void readBooks() {
			System.out.println("사람이 책을 읽습니다.");
		}
	}

	class Tiger extends Animal{
		
		public void move() {
			System.out.println("호랑이가 네 발로 뜁니다.");
		}
		
		public void hunting() {
			System.out.println("호랑이가 사냥을 합니다.");
		}
	}


	class Eagle extends Animal{
		public void move() {
			System.out.println("독수리가 하늘을 날아갑니다.");
		}
		
		public void flying() {
			System.out.println("독수리가 날개를 쭉 펴고 멀리 날아갑니다");
		}
	}
public class AnimalTest {
	public static void main(String[] args) {
		Animal hAnimal = new Human();  
		Animal tAnimal = new Tiger();
		Animal eAnimal = new Eagle();
		
		/*AnimalTest test = new AnimalTest();
		test.moveAnimal(hAnimal);  //함수에전달(다형성)
		test.moveAnimal(tAnimal);
		test.moveAnimal(eAnimal);
		*/
		
		//다운캐스팅
		ArrayList<Animal> animalList = new ArrayList<Animal>();
		animalList.add(hAnimal);
		animalList.add(tAnimal);
		animalList.add(eAnimal);
		
		AnimalTest test = new AnimalTest();
		test.testDownCasting(animalList);
		
		
		
	/*	for(Animal animal : animalList) {
			animal.move();
		}
		*/	
	}
	
	//다시 원래 자기타입으로 되돌리고 싶으면 다운캐스팅 쓰고 그게아니면 그냥 다형성을 쓰는게 좋다 (moveAnimal 함수처럼)
	public void testDownCasting(ArrayList<Animal> list) {
			
			for(int i =0; i<list.size(); i++) {
				Animal animal = list.get(i);
			
				if ( animal instanceof Human) { //animal이 Human타입이냐
					Human human = (Human)animal;
					human.readBooks();
				}
				else if( animal instanceof Tiger) {
					Tiger tiger = (Tiger)animal;
					tiger.hunting();
				}
				else if( animal instanceof Eagle) {
					Eagle eagle = (Eagle)animal;
					eagle.flying();
				}
				else {
					System.out.println("error");
				}
			
			}
		}
	
	
	
	/*
	 * public void moveAnimal(Animal animal) { animal.move();
	 * 
	 * }
	 */
	}
======================================================================================================
#)추상클래스
추상의 반댓말은 구체적
추상클래스란 우리가 클래스를 구성할 떄 메서드를 구현하는데 추상클래스는 메서드의 선언만있다.
추상클래스는 new할수없음.(인스턴스화 할수없다)
abstract예약어사용

int add(int x, int y);   -> 추상메서드(함수내용은 정의하지않음), 메서드선언만했다.
위와같은 추상메서드를 포함한것이 추상클래스이다.

=========================================================================================================
package ch9;

//부모
public abstract class  Computer { //추상클래스는 상속을위한 클래스다.
	
	//메서드선언만했다.(추상메서드)
	//상속받을 애들을 구체적으로 어떻게 구현할지 모르기때문에 display,typing은 자식이 알아서해라
	//컴퓨터는 공통으로쓸 turnOn, turnOff만 구현하고 display(), typing()은 구현하지않았다. 하위클래스로 책임전가
	abstract void display();
	abstract void typing();
	
	//일반메서드
	public void turnOn() {
		System.out.println("전원을 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("전원을 끕니다.");
	}
}
---------------
package ch9;

public class DeskTop extends Computer{

	@Override
	void display() {
		System.out.println("DeskTop display");
	}

	@Override
	void typing() {
		System.out.println("DeskTop typing");
	}

	@Override
	public void turnOff() { //재정의도 가능
		System.out.println("Desktop turnoff");
	}
}
------------------
package ch9;
//추상클래스를 상속받으면 메소드를 다 구현해야된다. 안하면 abstract를 붙여야한다.
public abstract class NoteBook extends Computer{ //추상클래스 (구현안한 메서드가 display()가있는데 이거를 구현안하면 abstract를 붙힌다)
	@Override
	public void typing() {
		System.out.println("NoteBook typing");		
	}
}
-------------------
package ch9;

public class MyNoteBook extends NoteBook{ //추상클래스인 NoteBook을 상속받음(부모가 구현안한 display()를 구현)

	@Override
	void display() {
		System.out.println("MyNoteBook display");		
	}
}
------------------
package ch9;

public class ComputerTest {

	public static void main(String[] args) {
		Computer computer = new DeskTop(); //Computer는 추상클래스(인스턴스화할수없다new), DeskTop은 일반클래스
		computer.display(); //오버라이딩된 인스턴스의 메서드를 찾아간다(desktop) -> 가상메서드
		computer.turnOff();
		
		NoteBook myNote = new MyNoteBook();
	}
}
==================================================================================
jdk(라이브러리) -> 안에도 라이브러리있음. -> 내가 필요한 경우 가져다쓰지만 내가 구성을한다.

안드로이드(프레임워크) -> 프레임워크를 도입한다는 애기는 이미 흐름이 정의되있다. 내가 어떤클래스를 넣으면 어떻게연동되고, 내가 값을 넣으면 어떻게 답이오고 영향을 주는지 등등
화면이 어떻게돌아가고 클로즈가되고 destroy가 된다 등은 안드로이드 내부에 이미정의되있지만(프레임워크) 실제로 화면에서 어떤위젯이 올라가고 어떤액션을 할지는 우리가 짜는것이다.
화면에 여러가지생성과정, 소멸과정 등은 정해져있지만 거기에 들어가는 기능들은 우리가해야한다.

프레임워크에서 많이쓰는 패턴중에하나가 템플릿메서드패턴이다.
- 추상 메서드나 구현된 메서드를 활용하여 코드의 흐름(시나리오)를 정의하는 메서드
- final로 선언하여 하위클래스에서 재정의 할 수 없게한다.(흐름은 변하면안되기때문에)
- 하위클래스에서 다르게 구현되어야 하는 부분은 추상메서드로 선언하여 하위 클래스에서 구현하도록 함

==================================================================================
package ch10;

public abstract class Car {
	//선언만했다.
	public abstract void drive(); //AI, 직접운전은 drive메서드는 자식이 구현해라
	public abstract void stop(); //마찬가지
	
	//시동은 공통이니까 구현했음
	public void startCar() {
		System.out.println("시동을 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("시동을 끕니다.");
	}
			
	public void washCar() {} //구현되긴했다.
	
	final public void run() {
		//시동을걸고 운전하다가 일이생기면 멈추고 시동꺼라 -> 시나리오(이거는 변하면안된다) -> run메서드를 재정의하면안되니까 final로 선언
		startCar(); //일반
		drive(); //추상
		stop(); //추상 
		turnOff(); //일반
		washCar(); //재정의할수있게끔(ai에서만 써도됨), 일반자동차는 재정의안했음
	}
}
------------------
package ch10;

public class AICar extends Car{
	
	//Car에서 상속받은 추상메서드 drive, stop 구현
	@Override
	public void drive() {
		System.out.println("자율 주행합니다.");
		System.out.println("자동차가 스스로 방향을 바꿉니다.");
	}

	@Override
	public void stop() {
		System.out.println("스스로 멈춥니다.");		
	}

	@Override
	public void washCar() {
		System.out.println("자동 세차를 합니다.");
	}
	
	
}
-----------------------
package ch10;

public class ManualCar extends Car{

	@Override
	public void drive() {
		System.out.println("사람이 운전합니다.");
		System.out.println("사람이 핸들을 조작합니다.");		
	}

	@Override
	public void stop() {
		System.out.println("브레이크를 밟아서 정지합니다.");		
	}

}
------------------------
package ch10;

public class CarTest {

	public static void main(String[] args) {
		Car aiCar = new AICar();
		aiCar.run();
		System.out.println("=================");
		Car manualCar = new ManualCar();
		manualCar.run();
	}
}
========================================================================
package ch10;

//이렇게 상수는 따로 빼서 쓴다.
public class Define {

	public static final int MIN = 1;
	public static final int MAX = 999999;
	public static final double PI = 3.14;
	public static final String GREETING = "Good Morning!";
	public static final int MATH_CODE = 1001;
	public static final int CHEMISTRY_CODE = 1002;
	
}
-------------------
package ch10;

public class UsingDefine {

	public static void main(String[] args) {

		System.out.println(Define.GREETING);
		System.out.println(Define.MIN);
		System.out.println(Define.MAX);
		System.out.println(Define.MATH_CODE);
		System.out.println(Define.CHEMISTRY_CODE);
		System.out.println("원주률은" + Define.PI + "입니다.");
	}

}
===========================================================================
#)인터페이스
인터페이스에서 메소드를 선언하면 모든 메소드가 자동으로 public abstract로 선언이된다.
모든 변수는 상수로 선언된다. public static final

interface 인터페이스 이름 {
	(public static final)float pi = 3.14F;
	public void makeSomthing(); //알아서 public abstract 으로 바뀜
}

============================================================================
#)인터페이스가 하는일
클래스나 프로그램이 제공하는 기능을 명시적으로 선언
클라이언트는 인터페이스에 선언된 메서드 명세만 보고 이를 구현한 클래스를 사용할 수 있음
클라이언트는 서버가 어떻게 구현되있는 모른다 -> 그래서 서버와 클라이언트 사이에 선언된 인터페이스 명세를 보고 클라이언트가 쓴다.(서버의 메서드가 어떻게 구현되있는지는 궁금하지않음)
어떤 객체가 하나의 인터페이스 타입이라는 것은 그 인터페이스가 제공하는 모든 메서드를 구현했다는 의미이다.
단, 클라이언트가 쓸때는 모든 메서드를 쓸필요는 없다. 서버만 모든 메서드를 구현
인터페이스를 구현한 다양한 객체를 사용함 -> 다형성

인터페이스를 쓰고있는 여러 클래스가 있어도 동일한 방식으로 쓰인다.

ex) jdbc 인터페이스 (connection도 인터페이스이다. -> 서드파티에서 메서드 구현했고 클라이언트는 골라쓰기만하면된다)

================================================================================
package ch11;

public interface Calc {

	double PI = 3.14; //static으로 바뀜
	int ERROR = -99999999;
	
	int add(int num1, int num2); //인터페이스는 abstract와 달리 상속이아니라 구현이라는 것이다.(Calculator에서 구현해야됨)
	int substract(int num1, int num2);
	int times(int num1, int num2);
	int divide(int num1, int num2);
	
}
-----------------
package ch11;

public abstract class Calculator implements Calc{ //abstract를 붙여야됨. implements를 붙이는순간 4개의 메서드를 구현해야되는데 2개만 구현했음
	//또, implement메서드는 자동으로 abstract가 붙기때문에 4개를 다 구현하지 않으면 abstract로 클래스를 만들어야한다.

	@Override
	public int add(int num1, int num2) {
		return num1 + num2;
	}
	
	@Override
	public int substract(int num1, int num2) {
		return num1 - num2;
	}
}

-------------------
package ch11;

public class CompleteCalc extends Calculator{
	
	@Override
	public int times(int num1, int num2) {
		return num1 * num2;
	}

	@Override
	public int divide(int num1, int num2) {
		if( num2 == 0 )
			return ERROR;
		else 
			return num1 / num2;
	}
	
	public void showInfo() {
		System.out.println("모두 구현하였습니다.");
	}
}
-----------------
package ch11;

import java.util.Scanner;

public class CalculatorTest {

	public static void main(String[] args) {
		Calc calc = new CompleteCalc(); //타입이 Calc이다.(인터페이스) 형변환, 인터페이스를 구현한 클래스는 인터페이스형으로 선언한 변수로 형 변환 할 수 있다.
		//형변환이된경우 인터페이스에 선언된 메서드만을 사용가능하다.
		int num1 = 10;
		int num2 = 2;
		
		System.out.println(num1 + "+" + num2 + "=" + calc.add(num1, num2));
		System.out.println(num1 + "-" + num2 + "=" +calc.substract(num1, num2));
		System.out.println(num1 + "*" + num2 + "=" +calc.times(num1, num2));
		System.out.println(num1 + "/" + num2 + "=" +calc.divide(num1, num2));
		
	}
}
==============================================================================
//인터페이스를 활용한 dao구현
dao인터페이스를 하나만들고 하나는 oracle, 또 하나는 mysql, 또 하나는 mssql용으로 만든다.
그러면 사용자는 implements로 바꾸기만 하면된다.
이런게 다형성이다. 똑같은 인터페이스를 활용해서 메서드를 활용하지만 결과는다르다.

===============================================================================
//인터페이스에서 모든 변수는 상수로 변환된다. public static final
//인터페이스에서 모든 선언된 메서드는 추상메서드로 선언된다.
//자바8이후에 디폴트메서드가있는데 implements가 된 클래스쪽에서 공통으로(기본적으로 제공) 사용할 수 있는 기본메서드이다. 오버라이딩로 가능
default void description() { //인터페이스쪽 
	System.out.println("정수계산기를 구현합니다.");
}

@Override //implements쪽 (class ~~~ implements ~~~~) 되는데 여기는 new로 인스턴스화를 해야된다. class이기때문에 하지만 정적메서드는 static이라 안해도된다.(아래참조)
public void description() {
	System.out.println("재정의");
}
==============================================================================
//또 자바8이후에 정적메서드를 제공한다.
위와 다르게 인스턴스 생성(new)과 관계없이 인터페이스 타입으로 사용할 수 있는 메서드
//자바 9이후에는 private메서드가 있다.
private이기때문에 인터페이스 내부에서만 사용하기 위해 구현하는 메서드
default메서드나 static메서드에서 사용한다.
=============================================================================
package ch14;

public interface Calc {

	double PI = 3.14;
	int ERROR = -99999999;
	
	int add(int num1, int num2);
	int substract(int num1, int num2);
	int times(int num1, int num2);
	int divide(int num1, int num2);
	
	default void description() {
		System.out.println("정수 계산기를 구현합니다.");
		myMethod(); 
	}
	
	static int total(int[] arr) { //arr의 합구하기
		int total = 0;
		
		for(int i: arr) {
			total += i;
		}
		mystaticMethod(); //static메서드에서 private static호출가능(private이기때문에 클래스안에서만)
		return total;
	}
	
	private void myMethod() { //버전때문에 지금 private는 안된다. 상속받은 CompleteCalc에서 구현하라고 에러가뜸
		System.out.println("private method");
	}
	
	private static void mystaticMethod() { 
		System.out.println("private static method");
	}
}
--------------
package ch14;

public abstract class Calculator implements Calc{ //implements를 하면 4개 함수 (add등)다 구현해야하는데 2개만해서 abstract붙혔다.

	@Override
	public int add(int num1, int num2) {
		return num1 + num2;
	}

	@Override
	public int substract(int num1, int num2) {
		return num1 - num2;
	}
}

---------------
package ch14;

public class CompleteCalc extends Calculator{ //Calc interface의 private myMethod, mystaticMethod는 재정의,구현할수없다.
	//즉, private메서드는 재정의할수없다.
	@Override
	public int times(int num1, int num2) {
		return num1 * num2;
	}

	@Override
	public int divide(int num1, int num2) {
		if( num2 == 0 )
			return ERROR;
		else 
			return num1 / num2;
	}
	
	public void showInfo() { //내 함수
		System.out.println("모두 구현하였습니다.");
	}

	@Override
	public void description() { //Calc interface에 있는 default메서드이다.
		System.out.println("CompleteCalc에서 재정의한 default 메서드");
		//super.description(); 부모에있는걸쓰는게아니라 재정의하겠다. 위에서
	}
}
----------------
package ch14;

public class CalculatorTest {

	public static void main(String[] args) {
		Calc calc = new CompleteCalc();
		int num1 = 10;
		int num2 = 2;
		
		System.out.println(num1 + "+" + num2 + "=" + calc.add(num1, num2));
		System.out.println(num1 + "-" + num2 + "=" +calc.substract(num1, num2));
		System.out.println(num1 + "*" + num2 + "=" +calc.times(num1, num2));
		System.out.println(num1 + "/" + num2 + "=" +calc.divide(num1, num2));
	
		calc.description();
		
		int[] arr = {1,2,3,4,5};
		int sum = Calc.total(arr); //total이라는 정적메서드이기때문에 바로 클래스를 호출했다.(private로 선언된 mystaticMethod도 호출했다 total에 같이선언되있으니)
		System.out.println(sum);
	}
}
====================================================================
#)여러 인터페이스 구현
//자바의 인터페이스에는 구현코드가 없으므로 하나의 클래스가 여러 인터페이스는 구현할수있음

buy(인터페이스)   sell(인터페이스)
       \	      /
      Customer(구현클래스) implements가 2개이다.

//그렇다면 클래스에서 상속은 왜 하나만 될까
예를들어 
a라는 클래스에서 b(클래스)가 a를 상속받고, c(클래스)가 상속받고 a라는 클래스에서 정의한 a라는 메서드를 b,c클래스에서 재정의하고나서
d라는 클래스가 d extends b extends c라고 한다면 무슨 메서드를 써야할지모른다. -> 따라서 다중상속이 안되는이유는 이러한 다이아몬드 상속때문이다.(c++은 가능하다. 어느클래스의 메서드를 써라는것을 지정가능)

static메서드는 인터페이스이름으로 호출
디폴트메서드가 중복되는 경우는 구현하는 클래스에서 재정의해야한다.(여러인터페이스호출시)

여러인터페이스를 구현한 클래스는 인터페이스 타입으로 형변환되는 경우 해당인터페이스에 선언된 메서드만 사용가능하다.
예를들어 buy로 인터페이스 타입선언되면 buy인터페이스 기능만 쓸수있다.

package ch15;

public interface Buy {

	void buy();
	
	default void order() {
		System.out.println("구매 주문");
	}
}
--------------
package ch15;

public interface Sell {

	void sell();
	
	default void order() {
		System.out.println("판매 주문");
	}
}
--------------
package ch15;

public class Customer implements Buy, Sell{

	@Override
	public void sell() {
		System.out.println("customer sell");
	}

	@Override
	public void buy() {
		System.out.println("customer buy");		
	}

	@Override
	public void order() { //default메서드를 재정의했다. 재정의나 명시적으로 누구의 메서드쓸지인지 선언 안하면에러가난다. 왜냐하면 buy,sell 디폴트메서드가 중복되기때문에
		//명시적으로 누구의 디폴트메서드를 쓸지 정의해야한다.
		//Sell.super.order();
		//아니면 그냥 재정의하던지
		System.out.println("customer order");
	}

	public void sayHello() { //내함수
		System.out.println("Hello");
	}

}
-----------------
package ch15;

public class CustomerTest {

	public static void main(String[] args) {

		Customer customer = new Customer();
		customer.buy();
		customer.sell();
		customer.sayHello();
		
		Buy buyer = customer; //type을 바꾼다.(업캐스팅)
		buyer.buy();
		
		Sell seller = customer;
		seller.sell();
		
		buyer.order(); //디폴트메서드로 정의한 order는 공통적으로 쓸수있다.
		seller.order();
	}
}
====================================================================
//인터페이스 상속
인터페이스 사이에도 상속을 사용할 수 있다.
extends 키워드를 사용
인터페이스는 다중상속이 가능하고 구현 코드의 상속이 아니므로 타입상속이라고 한다.

package ch15;

public interface X {

	void x();
}
------------
package ch15;

public interface Y {

	void y();
}
-------------
package ch15;

public interface MyInterface extends X, Y{  //인터페이스를 상속받음.

	void myMethod();
}
---------------
package ch15;

public class MyClass implements MyInterface{ //인터페이스 기능을 다 구현해야한다.

	@Override
	public void x() {
		System.out.println("x()");
	}

	@Override
	public void y() {
		System.out.println("y()");		
	}

	@Override
	public void myMethod() {
		System.out.println("myMethod()");		
	}
}
----------------
package ch15;

public class MyClassTest {

	public static void main(String[] args) {

		MyClass mClass = new MyClass(); //인터페이스는 클래스를 만들수없으니
		
		X xClass = mClass; //x로 타입이 되면 x만 쓸수있다.
		xClass.x();
		
		
		Y yClass = mClass;
		yClass.y();
		
		MyClass iClass = mClass;
		iClass.x();
		iClass.y();
		iClass.myMethod();
	}

}
========================================================
	   shelf  queue
(extends)\     /(implements)
		BookShelf

책이 순서대로 대여가 되는 도서관구현(FIFO)
shelf클래스를 상속받고 queue를 구현한다.

package ch15;

import java.util.ArrayList;

public class Shelf {

	 protected ArrayList<String> shelf; //상속받기위해 protected
	 
	 public Shelf() {
		 shelf = new ArrayList<String>();
	 }
	 
	 public ArrayList<String> getShelf(){
		 return shelf;
	 }
	 
	 public int getCount() {
		 return shelf.size();
	 }
	 
}
---------------
package ch15;

public interface Queue {

	//함수 3개선언
	void enQueue(String title);
	String deQueue(); //꺼내면 책의 이름을 반환
	
	int getSize(); //몇개가있느냐
}
---------------
package ch15;

public class BookShelf extends Shelf implements Queue{

	@Override
	public void enQueue(String title) {
		shelf.add(title); //shelf의 기능
	}

	@Override
	public String deQueue() {
		return shelf.remove(0); 
	}
 
	@Override
	public int getSize() {
		return getCount();
	}

}
------------------
package ch15;

public class BookShelfTest {

	public static void main(String[] args) {

		Queue bookQueue = new BookShelf(); //큐타입, 인터페이스는 new해서 못만든다.
		bookQueue.enQueue("태백산맥1");
		bookQueue.enQueue("태백산맥2");
		bookQueue.enQueue("태백산맥3");
		
		System.out.println(bookQueue.deQueue());
		System.out.println(bookQueue.deQueue());
		System.out.println(bookQueue.deQueue());
	}

}
=========================================================================
//상담원 작업분배 
//1. 우선배분(priority)
//2. 가장일이적은(leastjob)
//3. 
package ch16.scheduler;

public interface Scheduler {
	public void getNextCall();
	public void sendCallToAgent();
}
---------------
package ch16.scheduler;

public class PriorityAllocation implements Scheduler{

	@Override
	public void getNextCall() {
		System.out.println("고객등급이 높은 고객의 call을 먼저 가져옵니다");
		
	}

	@Override
	public void sendCallToAgent() {
		System.out.println("업무 숙련도가 높은 상담원에게 먼저 배분합니다");		
	}

}
-----------------
package ch16.scheduler;

public class LeastJob implements Scheduler{

	@Override
	public void getNextCall() {
		System.out.println("상담 전화를 순서대로 대기열에서 가져옵니다.");
		
	}

	@Override
	public void sendCallToAgent() {
		System.out.println("현재 상담업무가 없거나 상담대기가 가장 적은 상담원에게 할당합니다.");
		
	}

}
-------------------
package ch16.scheduler;

public class RoundRobin implements Scheduler{

	@Override
	public void getNextCall() {
		System.out.println("상담 전화를 순서대로 대기열에서 가져옵니다.");
	}

	@Override
	public void sendCallToAgent() {
		System.out.println("다음 순서의 상담원에게 배분합니다.");
	}

}
-----------------------
package ch16.scheduler;

import java.io.IOException;

public class SchedulerTest {

	public static void main(String[] args) throws IOException {

		System.out.println("전화 상담원 할당 방식을 선택하세요");
		System.out.println("R : 한명씩 차례대로");
		System.out.println("L : 대기가 적은 상담원 우선");
		System.out.println("P : 우선순위가 높은 고객우선 숙련도 높은 상담원");
		
		int ch = System.in.read();
		Scheduler scheduler = null; //인터페이스
		
		if ( ch == 'R' || ch =='r') {
			scheduler = new RoundRobin();
		}
		else if ( ch == 'L' || ch =='l') {
			scheduler = new LeastJob();
		}
		else if ( ch == 'P' || ch =='p') {
			scheduler = new PriorityAllocation();
		}
		else {
			System.out.println("지원되지 않는 기능입니다.");
			return;
		}
		
		scheduler.getNextCall();
		scheduler.sendCallToAgent();
	}

}
===============================================================












