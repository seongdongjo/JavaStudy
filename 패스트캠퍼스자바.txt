A -> 65 인코딩
65-> A 디코딩

각 나라별 문자세트가 다르니 호환이 안된다 그래서, 하나의 코드표로 통일하자 -> 유니코드(2byte표현)
-> 16비트 (2의 16승)

'a' -> 2byte 문자 -> 16bit -> 표현값개수 65536개 -> 문자라서 첫번째자리를 부호에 사용하지않기때문에 65536개이다.
short도 2byte이지만 부호가 표현되야하니 -32768~32767
"a" -> 문자열

//char는 자바에서 유니코드(2byte 문자체계)를 사용하므로 2byte이다
//c언어는 아스키코드를 사용하기 때문에 1byte크기를 갖는다.

유니코드란?

세계 각 국의 언어를 통일된 방법으로 표현할 수 있게 제안된 국제적인 코드 규약이다.
컴퓨터가 미국에서 개발되어져 영어를 바탕으로 정의되어 있다.
영어는 26자의 알파벳과 몇 가지 특수 문자를 표현하기에 1 byte로 충분했기 때문에
문자가 1 byte로 표현되고 있지만,
동양 3국의 한글, 한자 또는 일어 등과 같은 문자는 1 byte로는 표현이 불가능하기에
2 byte로 문자를 표현하는 유니코드가 만들어 졌다.

=======================================================================
//강제로
char ch1='A';
System.out.println((int)ch1);

int ch3 = 67;
System.out.println((char)ch3);


//변하지 않는 값은 + 공통적으로 쓰이는 -> final int max_num = 100;
//max_num = 20; 은 불가능

========================================================================
list, set 은 iterator사용가능
map은 사용할려면 entryset 같은걸로 바꾸고 해야됌. -> foreach쓰기위해서

#)map 사용
public static void main(String[] args) {
	HashMap<String,Integer> map = new HashMap<String,Integer>();
	
	//키는 String, value는 Integer
	map.put("Soraka",450);
	map.put("Garen",4800);
	map.put("Garen",450); //중복된 key는 선언은 가능하지만 젤 마지막 선언된것이 덮어씌운다
	
	System.out.println("Map value: " + map.get("Garen"));  //450
	System.out.println("Map value: " + map.size());  //2
	
	map.replace("Garen", 160); //Key값의 내용을 변경
	
	System.out.println("Key Exist: " + map.containsKey("Garen")); //key가 존재하는지 확인
	System.out.println("Value Exist: " + map.containsValue(160)); //value가 존재하는지 확인
	
	System.out.println("Map Empty: " + map.isEmpty()); //map의 크기가 0인지 확인
	
	map.remove("Garen");
}

=========================================================================
#)HashMap은 Map인터페이스에 속해있는 컬렉션이다.따라서, map인터페이스의 기본 기능들을 전부구현할 수 있다
#)map의 keyset메서드 사용
public class Sample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("people", "사람");
        map.put("baseball", "야구");
        System.out.println(map.keySet());  // 키출력 --> [baseball, people] 출력
    }
}
==========================================================================
for(String key : map.keySet()) {
	System.out.println("Value: " + map.get(key));
}

==============================================================================
#)jackson이란
Java Object를 JSON으로 변환하거나 JSON을 Java Object로 변환하는데 사용할 수 있는 Java 라이브러리입니다.

==============================================================================
package ch03;

public class FunctionTest {
	public static int addNum(int num1, int num2) {
		int result;
		result = num1 + num2;
		return result;
	}
	
	public static void sayHello(String greeting) {
		System.out.println(greeting);
	}
	public static int calcSum() {
		int sum = 0;
		int i;
		for(i = 0; i<=100; i++) {
			sum += i; 
		}
		return sum;
	}
	
	public static void main(String[] args) {
		int n1=10;
		int n2=20;
		
		int total = addNum(n1,n2);
		System.out.println(total);
		
		sayHello("안녕하세요");
		
		total = calcSum();
		System.out.println(total);
	}
}

//스택: 함수가 호출될 때 지역변수들이 사용하는 메모리
//스택: 함수의 수행이 끝나면 자동으로 반환되는 메모리

=====================================================================================
package ch04;

public class Student {
	public int studentID; //public이다.
	public String studentName;
	public String address;
	
	public void showStudentInfo() {
		System.out.println(studentID + "학번의 이름은" + studentName + "이고 주소는" + address + "입니다.");
	}
	
	public String getStudentName() {
		return studentName;
	}
	
	public void setStudentName(String name) {
		studentName = name;
	}
}
----------------
package ch04;

public class MainStudent {
	public static void main(String[] args) {
		Student studentLee = new Student(); //인스턴스라고한다, 같은 패키지내에서는 import 안한다
		Student studentKim = new Student();
		
		//인스턴스들은 동적메모리(Heap)에 할당된다, 참조변수는 스택에 올라간다.
		//c나 c++에서는 사용한 동적메모리를 프로그래머가 해제시켜야한다.(free, delete)
		//자바에서는 가비지컬렉터가 주기적으로 사용하지 않는 메모리를 수거한다.
		//하나의 클래스로부터 여러개의 인스턴스가 생성되고 각각 다른 메모리 주소를 가지게 된다.
		
		studentLee.studentID = 12345;
		studentLee.setStudentName("Lee");
		studentLee.address = "서울 강남구";
		
		studentLee.showStudentInfo();
		
		System.out.println(studentKim); //ch04.Student@36aa7bc2 -> 객체의 위치를 가리키는(Heap에 있는 인스턴스를 가리킨다) 주소값이다. (물리적 메모리주소가 아니라 JVM이 준 가상 주소)
		//그래서 studentKim. (점.)을 찍음으로써 접근
		System.out.println(studentLee);
		
		//인스턴스 : new 키워드를 사용하여 클래스를 메모리에 생성한 상태(힙)
		//참조변수: 메모리에 생성된 인스턴스를 가리키는 변수(스택)
		//참조값: 생성된 인스턴스의 메모리 주소값
	}
}
=========================================================================================
package ch06;

public class Student { //멤버변수는 알아서 초기화된다. null, 0
	public int studentNumber;
	public String studentName;
	public int grade;
	
	public Student() {
		System.out.println("생성자");
	}
	
	public Student(int studentNumber, String studentName, int grade) {
		this.studentNumber = studentNumber; //변수이름이 다르면 this붙일필요가없다
		this.studentName = studentName;
		this.grade = grade;
	}
	
	public String showStudentInfo() {
		int i; //i는 초기화되지 않는다.(지역변수라서)
		return studentName + "학생의 학번은" + studentNumber + "이고, " + grade + "학년 입니다.";
	}
}
----------------
package ch06;

public class StudentMain {
	public static void main(String[] args) {
		Student studentLee = new Student();
		Student studentKim = new Student(123456, "Kim", 3);
		
		System.out.println(studentKim.showStudentInfo()); 
		
		System.out.println(studentLee.showStudentInfo()); //null,0~
	}
}
============================================================================================
package ch09;

public class Student {
	int studentId;
	String studentName;
	
	Subject korea; //class내에서 쓸수있도록(전역변수? 느낌)
	Subject math;
	
	Student(int studentId, String studentName) { //학생을 만들 때 subject를 생성
		this.studentId = studentId;
		this.studentName = studentName;
		
		korea = new Subject();
		math = new Subject();
	}
	
	public void setKoreaSubject(String name, int score) {
		korea.subjectName = name;
		korea.score = score;
	}
	
	public void setMathSubject(String name, int score) {
		math.subjectName = name;
		math.score = score;
	}
	
	public void showScoreInfo() {
		int total = korea.score + math.score;
		System.out.println(studentName + "학생의 총점은" + total + "점 입니다.");
	}
}
-------------------
package ch09;

public class Subject {
	String subjectName;
	int score;
	int subjectId;
}
-------------------
package ch09;

public class SubjectMain {
	public static void main(String[] args) {
		Student studentLee = new Student(100, "Lee");
		studentLee.setKoreaSubject("국어", 100);
		studentLee.setMathSubject("수학", 99);
		
		Student studentKim = new Student(200, "Kim");
		studentKim.setKoreaSubject("국어", 80);
		studentKim.setMathSubject("수학", 100);
		
		studentLee.showScoreInfo();
		studentKim.showScoreInfo();
	}
}
=======================================================================================
package ch10;

public class BirthDay {
	private int day; //같은 클래스내에서만 접근 -> private
	private int month;
	private int year;
	
	private boolean isVaild; //기본값이 false
	
	public int getDay() {
		return day;
	}
	public void setDay(int day) {
		this.day = day;
	}
	public int getMonth() {
		return month;
	}
	public void setMonth(int month) {
		if(month < 1 || month > 13) {
			isVaild = false;
		}
		else {
			isVaild = true;
			this.month = month;
		}
	}
	public int getYear() {
		return year;
	}
	public void setYear(int year) {
		this.year = year;
	}
	
	public void showDate() {
		if(isVaild) { //true이면
			System.out.println(year + "년 " + month + "월 " + day + "일 입니다.");
		}
		else {
			System.out.println("유효하지 않은 날짜입니다.");
		}
	}
}
----------------
package ch10;

public class BirthDayMain {
	public static void main(String[] args) {
		BirthDay date = new BirthDay();
		date.setYear(2019);
		
		//private를 쓰는이유는 
		//date.month = 100 이렇게 범위를 벗어난값을 바로 대입가능하기 때문이다.
		//그래서 setter를 통해 제약을 걸었다.
		
		//date.setMonth(13);  month가 1~12사이가 아닌것은 처리 xx, BirthDay클래스에서 처리했다, 유효하지 않은 날짜라고 뜬다.
		date.setDay(30);
	}
}
=========================================================================
package ch11;

public class MakeReport {

	StringBuffer buffer = new StringBuffer(); //append메서드로 String을 연결한다
	
	private String line = "===========================================\n";
	private String title = "  이름\t   주소 \t\t  전화번호  \n";
	private void makeHeader()
	{
		buffer.append(line);
		buffer.append(title);
		buffer.append(line);
	}
	
	private void generateBody()
	{
		buffer.append("James \t");
		buffer.append("Seoul Korea \t");
		buffer.append("010-2222-3333\n");
		
		buffer.append("Tomas \t");
		buffer.append("NewYork US \t");
		buffer.append("010-7777-0987\n");
	}
	
	private void makeFooter()
	{
		
		buffer.append(line);
	}
	
	public String getReport()
	{
		makeHeader();
		generateBody();
		makeFooter();
		return buffer.toString();
	}
}
-----------------
package ch11;

public class MainReport {

	public static void main(String[] args) {

		MakeReport report = new MakeReport();
		String builder = report.getReport();
		
		System.out.println(builder);
	}

}
====================================================================
package ch12;

public class Person {
	String name;
	int age;
	
	public Person() {
		//age = 10;
		//name = "test"
		//this위에 쓰면 안된다. 객체가 만들어지기 전이기 때문에
		this("no name", 1);
	}
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	public void showPerson() {
		System.out.println(name + ", " + age);
	}
	public Person getPerson() { 
		return this; //객체자신을 반환
	}
	
	public static void main(String[] args) {
		Person person = new Person();
		person.showPerson(); //no name, 1
		
		System.out.println(person);  //ch12.Person@1175e2db
		
		Person person2 = person.getPerson(); //person2도 person을 바라본다.
		System.out.println(person2); //ch12.Person@1175e2db 같다.  this == main의 Person 이 같은 Heap공간의 Person을 가리킨다
		
	}
}
===============================================================================
package ch14;

public class Student {
	String studentName;
	int money;
	
	public Student(String studentName, int money) {
		this.studentName = studentName;
		this.money = money;
	}
	
	public void takeBus(Bus bus) {
		bus.take(1000); //버스를타면 1000원을 지불
		this.money -= 1000;
	}
	
	public void takeSubway(Subway subway) {
		subway.take(1200);
		this.money -= 1200;
	}
	
	public void showInfo() {
		System.out.println(studentName + "님의 남은 돈은 " + money + "원 입니다.");
	}
	
}
--------------
package ch14;

public class Subway {
	int lineNumber;
	int passengerCount; //승객수
	int money;
	
	public Subway(int busNumber) {
		this.lineNumber = busNumber;
	}
	
	public void take(int money) {
		this.money = money;
		passengerCount++;
	}
	
	public void showsubwayInfo() {
		System.out.println(lineNumber + "번의 승객 수는 " + passengerCount + "명 이고, 수입은 " + money + "원 입니다.");
	}
}
---------------
package ch14;

public class TakeTransTest {

	public static void main(String[] args) {
		Student studentJ = new Student("James", 5000);
		Student studentT = new Student("Tomas", 10000);
		
		Bus bus100 = new Bus(100);  //버스넘버
		Bus bus500 = new Bus(500);
		
		studentJ.takeBus(bus100); //studentJ가 bus100을 탔다.
		
		Subway greenSubway = new Subway(2); //lineNumber
		studentT.takeSubway(greenSubway);
		
		studentJ.showInfo();
		studentT.showInfo();
		
		bus100.showBusInfo();
		greenSubway.showsubwayInfo();
	}

	/*
	 * James님의 남은 돈은 4000원 입니다. 
	 * Tomas님의 남은 돈은 8800원 입니다. 
	 * 100번의 승객 수는 1명 이고, 수입은
	 * 1000원 입니다. 2번의 승객 수는 1명 이고, 수입은 1200원 입니다.
	 */
}
========================================================================
package ch16;

public class Employee {
	//static변수는 프로그램이 실행되면서 메모리에 로드될때 같이 적재된다. (객체 생성 전)
	public static int serialNum = 1000; //public이라서 외부에서 클래스.serialNum 접근가능하다
	
		private int employeeId;
		private String employeeName;
		private String department;
			
		public Employee() //클래스만들때마다 serialNum은 증가
		{
			serialNum++;
			employeeId = serialNum;
		}
		
		public int getEmployeeId() {
			return employeeId;
		}
		public void setEmployeeId(int employeeId) {
			this.employeeId = employeeId;
		}
		public String getEmployeeName() {
			return employeeName;
		}
		public void setEmployeeName(String employeeName) {
			this.employeeName = employeeName;
		}
		public String getDepartment() {
			return department;
		}
		public void setDepartment(String department) {
			this.department = department;
		}
}
--------------
package ch16;

public class EmployeeTest {

	public static void main(String[] args) {
		Employee employeeLee = new Employee();
		employeeLee.setEmployeeName("이순신");
				
		Employee employeeKim = new Employee();
		employeeKim.setEmployeeName("김유신");
				
		System.out.println(employeeLee.getEmployeeName() + "," + employeeLee.getEmployeeId());
		System.out.println(employeeKim.getEmployeeName() + "," + employeeKim.getEmployeeId());
		
		System.out.println(Employee.serialNum); //static변수는 클래스로 바로 접근 가능
	}
}
===================================================================
package ch17;

public class Employee {
	private static int serialNum = 1000; //private로 고쳤다 -> getter로 가져와야한다
		
		private int employeeId;
		private String employeeName;
		private String department;
			
		public Employee()
		{
			serialNum++;
			employeeId = serialNum;
		}
		
		public static int getSerialNum() {
			return serialNum;
		}
	
		public static void setSerialNum(int serialNum) { //serialNum을 직접 변경할 때
			int i = 0;
			
		//	employeeName = "Lee";  //오류발생 static이라서 -> 함수가 static이니까 employee는 메모리에 없다. 클래스가 만들어지기 전이라서
			Employee.serialNum = serialNum; //공통으로 쓰는 static값 변경
		}
	
		public int getEmployeeId() {
			return employeeId;
		}
		public void setEmployeeId(int employeeId) {
			this.employeeId = employeeId;
		}
		public String getEmployeeName() {
			return employeeName;
		}
		public void setEmployeeName(String employeeName) {
			this.employeeName = employeeName;
		}
		public String getDepartment() {
			return department;
		}
		public void setDepartment(String department) {
			this.department = department;
		}
}
----------------
package ch17;

public class EmployeeTest {

	public static void main(String[] args) {
		Employee employeeLee = new Employee();
		employeeLee.setEmployeeName("이순신");
				
		Employee employeeKim = new Employee();
		employeeKim.setEmployeeName("김유신");
				
		System.out.println(employeeLee.getEmployeeName() + "," + employeeLee.getEmployeeId());
		System.out.println(employeeKim.getEmployeeName() + "," + employeeKim.getEmployeeId());
		
		System.out.println(Employee.getSerialNum()); //SerialNum은 private라서 getter로 가져옴
	}
}
---------------------
package ch17;

public class EmployeeTest2 {

	public static void main(String[] args) {
		System.out.println(Employee.getSerialNum());
		Employee.setSerialNum(1003);
		System.out.println(Employee.getSerialNum());
	}

}
================================================================================
package singleton18;

public class Company {
	//싱글톤 패턴: 프로그램에서 인스턴스가 단 한 개만 생성되어야 하는 경우 사용하는 디자인 패턴
	//Timezone같은 시간은 인스턴스를 각각 가질수없다. (동일한시간을 가져야하니까)
	//회사라는 객체는 하나여야만한다.(사원도 또 늘어나니까)
	//이런경우 싱글톤패턴이 필요
	
	//static은 프로그램실행될 때 메모리에 로드된다. 따라서 한번만 만든다.
	private static Company instance = new Company(); //유일한 객체를 한번만 미리만들어놓는다.
	
	//컴파일러가 기본으로 생성하는 외부에서 Company를 마음대로 new할 수 없도록
	private Company() {}
	
	//클래스로 바로 접근할수있게끔 static까지 
	public static Company getInstance() {
		if(instance == null) {
			instance = new Company();
		}
		return instance;
	}
}
---------------
package singleton18;

import java.util.Calendar;

public class CompanyTest {
	public static void main(String[] args) {
		Company company1 = Company.getInstance(); //static이라 클래스로 접근
		Company company2 = Company.getInstance();
		
		System.out.println(company1); //값이 같다.
		System.out.println(company2);
		
		Calendar calendar = Calendar.getInstance(); //이것도 마찬가지
		
	}
}
=======================================================================
package singletontest;

public class CarFactory {
	private static CarFactory instance = new CarFactory();
		
		private CarFactory() {}
		
		public static CarFactory getInstance() {
			if(instance == null) {
				instance = new CarFactory();
			}
			return instance;
		}
		
		//공장안에서 Car를 만들기 때문에
		public Car createCar() { //반환은 Car
			
			Car car = new Car(); 
			return car;
		}
}
---------------
package singletontest;

public class Car {
	private static int serialNum = 10000;
	private int carNum;
	
	public Car() {
		serialNum++;
		carNum = serialNum;
	}

	public int getCarNum() {
		return carNum;
	}

	public void setCarNum(int carNum) {
		this.carNum = carNum;
	}
	
	
}
----------------
package singletontest;

public class CarFactoryTest {

	public static void main(String[] args) {
		CarFactory factory = CarFactory.getInstance();
		Car mySonata = factory.createCar();
		Car yourSonata = factory.createCar();
		
		System.out.println(mySonata.getCarNum());
		System.out.println(yourSonata.getCarNum());
	}

}
=================================================================
package taxi;

public class Student {
	String studentName;
	int grade;
	int money;
	
	public Student(String studentName, int money) {
		this.studentName = studentName;
		this.money = money;
	}
	
	public void takeTaxi(Taxi taxi) {
		taxi.take(10000);  //taxi객체 money증가
		this.money -= 10000;
	}
	
	public void showInfo() {
		System.out.println(studentName + "님의 남은 돈은 " + money + "원 입니다.");
	}
}
-----------------
package taxi;

public class Taxi {
	String companyName;
	int money;
	
	public Taxi(String companyName) {
		this.companyName = companyName;
	}
	
	public void take(int money) {
		this.money += money;
	}
	
	public void showTaxiInfo() {
		System.out.println(companyName + "택시 수입은 " + money + "원 입니다.");
	}
}
========================================================================================
#)배열
int[] arr1 = new int[10];
int arr2[] = new int[10];
int[] arr3 = new int[] {10,20,30};
int[] arr4 = {10,20,30};

int[] arr5;
arr5 = new int[] {10,20,30};

for(int i = 0, num=1; i<arr.length; i++) {
	arr[i] = num++;
}

//처음부터 끝까지 돌릴때
for(int num : arr) {
	total += num;
}
--------------
//length를 활용하여 오류나는경우 -> length는 5인데 실제데이터는 3개만 들어가있다.
double[] dArr = new double[5];

dArr[0] = 1.1;
dArr[1] = 1.1;
dArr[2] = 1.1;

double mtotal = 1;
for(int i = 0; i<dArr.lengthl i++) {
	mtotal *= dArr[i];
}
--------------
//해결법: 요소의 개수에 대한 변수(count)를 유지 -> count를 1씩증가(for문돌리기위해 길이)
double[] dArr = new double[5];
int count = 0;
dArr[0] = 1.1; count++;
dArr[1] = 1.1; count++;
dArr[2] = 1.1; count++;

double mtotal = 1;
for(int i = 0; i<count; i++) {
	mtotal *= dArr[i];
}
----------------
package ch20;

public class CharArrayTest {
	public static void main(String[] args) {
		char[] alphabets = new char[26];
		char ch = 'A';
		
		for(int i =0; i<alphabets.length; i++) {
			alphabets[i] = ch++;
		}
		for(char alpha : alphabets) {
			System.out.println(alpha + ", " + (int)alpha);
		}
	}
}
==========================================================================================
package ch21;

public class Book {
	private String title;
	private String author;
	
	public Book() {}
	public Book(String title, String author) {
		this.title = title;
		this.author = author;
	}
	
	public String getTitle() {
		return title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public String getAuthor() {
		return author;
	}
	public void setAuthor(String author) {
		this.author = author;
	}
	
	public void showInfo() {
		System.out.println(title + ", " + author);
	}
	
}
------------------
package ch21;

public class BookTest {

	public static void main(String[] args) {
		Book[] library = new Book[5]; //null로 초기화, new한다고 Book객체가 만들어지는게 아니다.
		
		library[0] = new Book("태백산맥1", "조정래"); //객체를 만들어서 넣어야한다. 
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		for(Book book : library) {
			System.out.println(book); //ch21.Book@36aa7bc2  처럼 각기다른 5개 나옴
			book.showInfo();
		}
		
		
	}

}
--------------------
package ch21;

public class ObjectCopyTest {
	public static void main(String[] args) {
		Book[] library = new Book[5]; //null로 초기화, new한다고 Book개게가 만들어지는게 아니다.
		Book[] copyLibrary = new Book[5];
		
		library[0] = new Book("태백산맥1", "조정래"); //객체를 만들어서 넣어야한다. 
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		System.arraycopy(library, 0, copyLibrary, 0, 5); //library 0번쨰부터 복사해서 copyLibrary의 0에서5까지 넣어라(주소가 같은 상태이다)
	
		//기존 book
		for(Book book : library) {
			System.out.println(book);  //주소가같다.
			book.showInfo();
		}
		
		//복사한
		for(Book book : copyLibrary) { //주소가같다.
			System.out.println(book); 
			book.showInfo();
		}
		
		//주소가같아서 library0번째만 바꿧는데 copyLibrary도 같이 바뀐다.
		library[0].setAuthor("박완서");
		library[0].setTitle("나목");
		
	}
	//이런게 얕은복사이다.
}
-------------------
package ch21;

public class ObjectCopyTest2 {
	public static void main(String[] args) {
		Book[] library = new Book[5]; 
		Book[] copyLibrary = new Book[5];
		
		library[0] = new Book("태백산맥1", "조정래");
		library[1] = new Book("태백산맥2", "조정래");
		library[2] = new Book("태백산맥3", "조정래");
		library[3] = new Book("태백산맥4", "조정래");
		library[4] = new Book("태백산맥5", "조정래");
		
		//깊은 복사 방식
		copyLibrary[0] = new Book();
		copyLibrary[1] = new Book();
		copyLibrary[2] = new Book();
		copyLibrary[3] = new Book();
		copyLibrary[4] = new Book();
		
		for(int i =0; i<library.length; i++) {
			copyLibrary[i].setAuthor(library[i].getAuthor());
			copyLibrary[i].setTitle(library[i].getTitle());
		}
		
		
		//주소가같아서 library0번째만 바꿧는데 copyLibrary[0]는 안바뀐다.
		library[0].setAuthor("박완서");
		library[0].setTitle("나목");
		
				//기존 book
				for(Book book : library) {
					System.out.println(book);  //주소가다르다
					book.showInfo();
				}
				
				//복사한
				for(Book book : copyLibrary) { //주소가 다르다
					System.out.println(book); 
					book.showInfo();
				}
	}
}
==============================================================================
package ch22;

public class TwoDimensionTest {
	public static void main(String[] args) {
		int[][] arr = { {1,2,3}, {4,5,6,7}};
		//int[][] arr = new int[3][4];
		
		int i, j;
		
		for(i =0; i<arr.length; i++) {
			for(j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j] + " ");
			}
			System.out.println(", \t" + arr[i].length);
			System.out.println();
		}
	}
}
/* 결과
 * 1 2 3 , 3
 * 
 * 4 5 6 7 , 4
 */
 ==========================================================
 package ch23;

import java.util.ArrayList;

import ch21.Book;

public class ArrayListTest {

	public static void main(String[] args) {
		//기존 배열방식은 길이가 고정이라서 배열의 길이가 커지면 배열을 재할당하고 복사해야했다.
		//ArrayList는 동적
		
		ArrayList<Book> library = new ArrayList<Book>(); //book객체를 가리키는 주소가 array형식으로 만들겠다.
				
				library.add(new Book("태백산맥1", "조정래"));
				library.add(new Book("태백산맥2", "조정래"));
				library.add(new Book("태백산맥3", "조정래"));
				library.add(new Book("태백산맥4", "조정래"));
				library.add(new Book("태백산맥5", "조정래"));
				
				for(int i =0; i<library.size(); i++) {
					library.get(i).showInfo();
				}
			}

}
==============================================================
package ch24;

public class Subject {
	private String name; //과목이름
	private int scorePoint; //점수
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getScorePoint() {
		return scorePoint;
	}
	public void setScorePoint(int scorePoint) {
		this.scorePoint = scorePoint;
	}
}
----------------
package ch24;

import java.util.ArrayList;

public class Student {
	int studentID;
	String studentName;
	ArrayList<Subject> subjectList; //이게 Has-A 방식 (subject를 상속받는게아니라) -> 클래스가 다른 클래스를 포함하는 관계
		
	public Student(int studentID, String studentName){
		this.studentID = studentID;
		this.studentName = studentName;
		
		subjectList = new ArrayList<Subject>();
	}
	
	public void addSubject(String name, int score){
		Subject subject = new Subject();
		
		subject.setName(name); //입력받은 이름 
		subject.setScorePoint(score); //입력받은 점수
		
		subjectList.add(subject); //리스트에 add
	}
	
	public void showStudentInfo()
	{
		int total = 0;
		
		for(Subject s : subjectList){
			
			total += s.getScorePoint();
			System.out.println("학생 " + studentName + "의 " + s.getName() + " 과목 성적은 " + 
			        s.getScorePoint() + "입니다.");
		}
			
		System.out.println("학생 " + studentName + "의 총점은 " + total + " 입니다.");
	}
}
-----------------
package ch24;

public class StudentTest {
	public static void main(String[] args) {
		Student studentLee = new Student(1001, "Lee");
		
		studentLee.addSubject("국어", 100);
		studentLee.addSubject("수학", 50);
		
		Student studentKim = new Student(1002, "Kim");
		
		studentKim.addSubject("국어", 70);
		studentKim.addSubject("수학", 85);
		studentKim.addSubject("영어", 100);
		
		studentLee.showStudentInfo();
		System.out.println("======================================");
		studentKim.showStudentInfo();
	}
}
==================================================================================
package ch2;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public int calcPrice(int price) { //입력받은 price
		bonusPoint += price * bonusRatio; //가격의 1퍼센트를 기존 보너스포인트에 쌓는다.
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}

-----------------
package ch2;

//만약에 VIPCustomer 클래스없이 Customer로만 만들려면 if문돌려서 gold,silver 분류해서 할인율, 또 요구조건이 생기면 계속 if문 쓰면 너무 번거롭다.
//그래서 VIPCustomer로 별도로 뺸다.
public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio; //VIP에만 있는 변수
	
	public VIPCustomer() { //생성자
		//super();
		customerGrade = "VIP";//덮어쓰기    //오류 발생 -> extends를 해야한다(protected라서), private은 extends해도 안됨.
		bonusRatio = 0.05; //덮어쓰기 마찬가지 
		salesRatio = 0.1;
	}
	
	public int getAgentID() { //안씀
		return agentID;
	}
}

---------------------
package ch2;

public class CustomerTest {
	public static void main(String[] args) {
		Customer customerLee = new Customer();
		customerLee.setCustomerName("이순신");
		customerLee.setCustomerID(10010);
		customerLee.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee.showCustomerInfo());
			
			
		VIPCustomer customerKim = new VIPCustomer();  //new VIPCustomer()를 호출하면 Customer()생성자가 먼저 호출된다.
		customerKim.setCustomerName("김유신"); //부모의 메서드
		customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim.showCustomerInfo()); //vip로 생성자만들었으니 잘나온다.
	}
}
이순신님의 등급은 SILVER이며, 보너스 포인트는 1000입니다
김유신님의 등급은 VIP이며, 보너스 포인트는 10000입니다
=============================================================================
package ch3;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public Customer(int customerID, String customerName) {
		this.customerID = customerID;
		this.customerName = customerName;
		
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //가격의 1퍼센트를 기존 보너스포인트에 쌓는다, 현재는 vip는 계산이안됨,vip에서 bonusratio를 재정의해도 calcPrice에서 찾아가지못함.
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}
-------------------
package ch3;

public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio; //VIP에만 있는 변수
	
	public VIPCustomer() { //덮어쓰기
		//super();
		customerGrade = "VIP"; 
		bonusRatio = 0.05;
		salesRatio = 0.1;
	}
	
	public VIPCustomer(int customerID, String customerName) {
		super(customerID, customerName);
		customerGrade = "VIP"; //덮어쓰기 super()에서 정의된 customerGrade를   
		bonusRatio = 0.05; //마찬가지로 덮어쓰기
		salesRatio = 0.1;
		//아직 보너스포인트, 가격은 정의안함
	}
	
	public int getAgentID() {
		return agentID;
	}
}
----------------------
package ch3;

public class CustomerTest {
	public static void main(String[] args) {
		Customer customerLee = new Customer(); //디폴트 생성자
		customerLee.setCustomerName("이순신");
		customerLee.setCustomerID(10010);
		customerLee.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee.showCustomerInfo());
		
		Customer customerLee2 = new Customer(10030, "홍길동");
		//customerLee.setCustomerName("홍길동");
		//customerLee.setCustomerID(10010);
		customerLee2.bonusPoint = 1000; //원래 가지고있던 보너스포인트
		System.out.println(customerLee2.showCustomerInfo());
			
			
		VIPCustomer customerKim = new VIPCustomer();  //new VIPCustomer()를 호출하면 Customer()생성자가 먼저 호출된다.
		customerKim.setCustomerName("김유신"); //부모의 메서드
		customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim.showCustomerInfo());
		
		VIPCustomer customerKim2 = new VIPCustomer(10040, "강지은"); 
		//customerKim.setCustomerName("김유신"); //부모의 메서드
		//customerKim.setCustomerID(10020);    //부모의 메서드
		customerKim2.bonusPoint = 10000;      //부모의 멤버변수
		System.out.println(customerKim2.showCustomerInfo());
	}
	
	//업캐스팅
	//Customer customerLee = new VIPCustomer(); 
	//customerLee.  으로 쓸수있는걸보면 Customer만 쓸수있다.(오버라이딩된거, 부모의 멤버변수만 쓸수있다)
}
==========================================================================================
package ch4;

public class Customer {
	protected int customerID; //private는 자식이여도 직접 수정은 못한다. -> setter로 가능
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	/*public Customer() {
		customerGrade = "SILVER";
		bonusRatio = 0.01;
		
		System.out.println("Customer() 생성자 호출");
	}*/
	
	public Customer(int customerID, String customerName) {
		this.customerID = customerID;
		this.customerName = customerName;
		
		customerGrade = "SILVER";
		bonusRatio = 0.01;
		//System.out.println("Customer(int, String) 생성자 호출");
	}
	
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price;
	}
	
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}

	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade + 
				"이며, 보너스 포인트는 " + bonusPoint + "입니다";
		
	}
}
---------------------
package ch4;

public class VIPCustomer extends Customer{
	private int agentID;
	double salesRatio;
	
	/*public VIPCustomer() {
		customerGrade = "VIP";    //오류 발생, why? customer에서 기본생성자를 주석처리 했기때문에
		bonusRatio = 0.05;
		salesRatio = 0.1;
		
		System.out.println("VIPCustomer() 생성자 호출");
	}
	*/
	
	public VIPCustomer(int customerID, String customerName) {
		super(customerID, customerName);
		
		customerGrade = "VIP";
		bonusRatio = 0.05;
		salesRatio = 0.1;
		
		//System.out.println("VIPCustomer(int, String) 생성자 호출");
	}
	
	
	//오버라이딩의 조건은 함수명, 매개변수, 타입까지 다 같아야한다.
	@Override
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price - (int)(price * salesRatio);
	}



	public int getAgentID() {
		return agentID;
	}
	
	@Override
	public String showCustomerInfo() {
		return customerName + "님의 등급은 " + customerGrade +  
				"이며, 보너스 포인트는 " + bonusPoint + "입니다(vip)";  //여기쓰인 변수들은 부모의 변수를 쓰고있다.
	}
}
---------------------
package ch4;

public class CustomerTest {
	public static void main(String[] args) {
			//함수의 이름이 주소값이다.
		 	//메서드는 명령어의 set이고 프로그램이 로드되면 메서드 영역(코드영역)에 명령어 set이 위치
			//해당 메서드가 호출되면 명령어 set이 있는 주소를 찾아 명령어가 실행됨
			//이때 메서드에서 사용하는 변수들은 스택메모리에 위치한다
			//따라서 다른 인스턴스라도 같은 메서드의 코드는 같으므로 같은 메서드가 호출됨
			//인스턴스가 생성되면 변수는 힙메모리에 따로 생성되지만, 메서드 명령어 set은 처음 한번만 로드됨
		
			//가상메소드란
			//상속에서 상위클래스와 하위 클래스에 같은 이름의 메서드((재정의함수)가 존재할 때 호출되는 메소드는 인스턴스에 따라 결정된다.
			//선언한 클래스형이 아닌 생성된 인스턴스의 메서드를 호출하는것
			//그떄, 인스턴스의 메서드가 호출되는 기술을 가상메서드라고한다.
		
			//같은 객체의 인스턴스를 여러개 생성한다고 해서 메소드도 여러개 생성되지 않는다.
			//즉, new Customer 를 여러번한다고 해서 a라는 메서드가 여러개 생성되지 않는다.(하나를 공유(메모리주소로))
			//예외적으로 사용하는 지역변수는 stack에 생성되서 잡힘
		
			//VIP의 멤버변수 private int agentID;  double salesRatio;
			Customer customerLee = new Customer(10010, "이순신");
			customerLee.bonusPoint = 1000;
			System.out.println(customerLee.showCustomerInfo());
			
			VIPCustomer customerKim = new VIPCustomer(10020, "김유신");
			customerKim.bonusPoint = 10000;
			System.out.println(customerKim.showCustomerInfo());
			
			int priceLee = customerLee.calcPrice(10000); //구입가격대입
			int priceKim = customerKim.calcPrice(10000); //구입가격대입
			
			System.out.println(customerLee.showCustomerInfo() + " 지불금액은 " + priceLee + "원 입니다.");
			System.out.println(customerKim.showCustomerInfo() + " 지불금액은 " + priceKim + "원 입니다.");
			
			//업캐스팅
			Customer customerNo = new VIPCustomer(10030, "나몰라"); 
			customerNo.bonusPoint = 10000;
			int priceNo = customerNo.calcPrice(10000); //오버라이딩한 VIPCustomer를 찾아간다.
			System.out.println(customerNo.showCustomerInfo() + " 지불금액은 " + priceNo  + "원 입니다."); //오버라이딩한 show를 찾아간다
			
			//나몰라님의 등급은 VIP이며, 보너스 포인트는 10500입니다 지불금액은 9000원 입니다.
		}
}
=============================================================================================
package ch6;

import java.util.ArrayList;
//정보은닉, 상속과 더불어 다형성은 객체지향 프로그래밍의 가장 큰 특징 중 하나이다.
class Animal{
	
	public void move() {
		System.out.println("동물이 움직입니다.");
	}
	
	public void eating() {
		
	}
}

class Human extends Animal{
	@Override
	public void move() {
		System.out.println("사람이 두발로 걷습니다.");
	}
	
	public void readBooks() {
		System.out.println("사람이 책을 읽습니다.");
	}
}

class Tiger extends Animal{
	@Override
	public void move() {
		System.out.println("호랑이가 네 발로 뜁니다.");
	}
	
	public void hunting() {
		System.out.println("호랑이가 사냥을 합니다.");
	}
}


class Eagle extends Animal{
	@Override
	public void move() {
		System.out.println("독수리가 하늘을 날아갑니다.");
	}
	
	public void flying() {
		System.out.println("독수리가 날개를 쭉 펴고 멀리 날아갑니다");
	}
}

public class AnimalTest {
	public static void main(String[] args) {

		Animal hAnimal = new Human();//업캐스팅 됬지만 오버라이딩된 메서드를 찾아간다.
		Animal tAnimal = new Tiger();
		Animal eAnimal = new Eagle();
		
		//출력방법 1
		AnimalTest test = new AnimalTest(); //밑에 moveAnimal함수쓸려고 갹체 생성
		test.moveAnimal(hAnimal);
		test.moveAnimal(tAnimal);
		test.moveAnimal(eAnimal);
		
		
		//출력방법2
		ArrayList<Animal> animalList = new ArrayList<Animal>();
		animalList.add(hAnimal);
		animalList.add(tAnimal);
		animalList.add(eAnimal);
		
		for(Animal animal : animalList) {
			animal.move();
		}
	}	
	//main밖에서 함수정의해야한다.
	public void moveAnimal(Animal animal) {
		animal.move(); //이런게 다형성이다. 같은 move라는 메서드이지만 출력결과는 다르다.
		
	}
	
}
===========================================================================================
package ch6;

public class Customer {
	protected int customerID;
	protected String customerName;
	protected String customerGrade;
	int bonusPoint;
	double bonusRatio;
	
	public Customer()
	{
		initCustomer();
	}

	public Customer(int customerID, String customerName){
		this.customerID = customerID;
		this.customerName = customerName;
		
		initCustomer();
	}
	
	private void initCustomer() //회원등급과 보너스포인트비율을 초기화
	{
		customerGrade = "SILVER";
		bonusRatio = 0.01;	
	}
	
	public int calcPrice(int price){
		bonusPoint += price * bonusRatio;
		return price;
	}
	
	public String showCustomerInfo(){
		return customerName + " 님의 등급은 " + customerGrade + "이며, 보너스 포인트는 " + bonusPoint + "입니다.";  
	}
	
	public int getCustomerID() {
		return customerID;
	}

	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public String getCustomerGrade() {
		return customerGrade;
	}

	public void setCustomerGrade(String customerGrade) {
		this.customerGrade = customerGrade;
	}
}
---------------
package ch6;

public class GoldCustomer extends Customer{

	double saleRatio;
		
		public GoldCustomer(int customerID, String customerName){
			super(customerID, customerName);
		
			customerGrade = "GOLD"; //부모의 멤버변수니까 showInfo는 오버라이딩 안했음. 
			bonusRatio = 0.02;   	//부모의 멤버변수
			saleRatio = 0.1;		//내꺼
		
		}
		@Override
		public int calcPrice(int price){
			bonusPoint += price * bonusRatio;
			return price - (int)(price * saleRatio);
		}
}
-------------------
package ch6;

public class VIPCustomer extends Customer{
	private int agentID;
	double saleRatio;
	
	public VIPCustomer(int customerID, String customerName, int agentID){
		super(customerID, customerName);
	
		customerGrade = "VIP";
		bonusRatio = 0.05;
		saleRatio = 0.1;
		this.agentID = agentID;
	}
	@Override
	public int calcPrice(int price){
		bonusPoint += price * bonusRatio;
		return price - (int)(price * saleRatio);
	}
	@Override
	public String showCustomerInfo(){
		return super.showCustomerInfo() + " 담당 상담원 번호는 " + agentID + "입니다";  //super.showInfo로 부모메소드부른후 뒤에 문자열 추가
	}

	public int getAgentID(){
		return agentID;
	}
}
-----------------
package ch6;

import java.util.ArrayList;

public class CustomerTest {
	public static void main(String[] args) {
			
			ArrayList<Customer> customerList = new ArrayList<Customer>();
			
			Customer customerLee = new Customer(10010, "이순신");
			Customer customerShin = new Customer(10020, "신사임당");
			Customer customerHong = new GoldCustomer(10030, "홍길동");
			Customer customerYul = new GoldCustomer(10040, "이율곡");
			Customer customerKim = new VIPCustomer(10050, "김유신", 12345);
			
			customerList.add(customerLee);
			customerList.add(customerShin);
			customerList.add(customerHong);
			customerList.add(customerYul);
			customerList.add(customerKim);
			
			System.out.println("====== 고객 정보 출력 =======");
			
			for( Customer customer : customerList){
				System.out.println(customer.showCustomerInfo());
			}
			
			System.out.println("====== 할인율과 보너스 포인트 계산 =======");
			
			int price = 10000;
			
			for( Customer customer : customerList){
				int cost = customer.calcPrice(price); //재정의된 calcPrice를 찾는다.
				System.out.println(customer.getCustomerName() +" 님이 " +  + cost + "원 지불하셨습니다."); //Customer로 업캐스팅 했기때문에 Customer의 bonusPoint를 가져올수있다.
				System.out.println(customer.getCustomerName() +" 님의 현재 보너스 포인트는 " + customer.bonusPoint + "점입니다.");
			}
		}
}
===================================================================
package ch8;

import java.util.ArrayList;

//다운캐스팅은 명시적으로 해야한다.
//Customer vc = new VIPCustomer(); 묵시적(업캐스팅)
//VIPCustomer vCustomer = (VIPCustomer)vc; 명시적(다운캐스팅)

	class Animal{
		
		public void move() {
			System.out.println("동물이 움직입니다.");
		}
		
		public void eating() {
			
		}
	}

	class Human extends Animal{
		public void move() {
			System.out.println("사람이 두발로 걷습니다.");
		}
		
		public void readBooks() {
			System.out.println("사람이 책을 읽습니다.");
		}
	}

	class Tiger extends Animal{
		
		public void move() {
			System.out.println("호랑이가 네 발로 뜁니다.");
		}
		
		public void hunting() {
			System.out.println("호랑이가 사냥을 합니다.");
		}
	}


	class Eagle extends Animal{
		public void move() {
			System.out.println("독수리가 하늘을 날아갑니다.");
		}
		
		public void flying() {
			System.out.println("독수리가 날개를 쭉 펴고 멀리 날아갑니다");
		}
	}
public class AnimalTest {
	public static void main(String[] args) {
		Animal hAnimal = new Human();  
		Animal tAnimal = new Tiger();
		Animal eAnimal = new Eagle();
		
		/*AnimalTest test = new AnimalTest();
		test.moveAnimal(hAnimal);  //함수에전달(다형성)
		test.moveAnimal(tAnimal);
		test.moveAnimal(eAnimal);
		*/
		
		//다운캐스팅
		ArrayList<Animal> animalList = new ArrayList<Animal>();
		animalList.add(hAnimal);
		animalList.add(tAnimal);
		animalList.add(eAnimal);
		
		AnimalTest test = new AnimalTest();
		test.testDownCasting(animalList);
		
		
		
	/*	for(Animal animal : animalList) {
			animal.move();
		}
		*/	
	}
	
	//다시 원래 자기타입으로 되돌리고 싶으면 다운캐스팅 쓰고 그게아니면 그냥 다형성을 쓰는게 좋다 (moveAnimal 함수처럼)
	public void testDownCasting(ArrayList<Animal> list) {
			
			for(int i =0; i<list.size(); i++) {
				Animal animal = list.get(i);
			
				if ( animal instanceof Human) { //animal이 Human타입이냐
					Human human = (Human)animal;
					human.readBooks();
				}
				else if( animal instanceof Tiger) {
					Tiger tiger = (Tiger)animal;
					tiger.hunting();
				}
				else if( animal instanceof Eagle) {
					Eagle eagle = (Eagle)animal;
					eagle.flying();
				}
				else {
					System.out.println("error");
				}
			
			}
		}
	
	
	
	/*
	 * public void moveAnimal(Animal animal) { animal.move();
	 * 
	 * }
	 */
	}
======================================================================================================
#)추상클래스
추상의 반댓말은 구체적
추상클래스란 우리가 클래스를 구성할 떄 메서드를 구현하는데 추상클래스는 메서드의 선언만있다.
추상클래스는 new할수없음.(인스턴스화 할수없다)
abstract예약어사용

int add(int x, int y);   -> 추상메서드(함수내용은 정의하지않음), 메서드선언만했다.
위와같은 추상메서드를 포함한것이 추상클래스이다.

=========================================================================================================
package ch9;

//부모
public abstract class  Computer { //추상클래스는 상속을위한 클래스다.
	
	//메서드선언만했다.(추상메서드)
	//상속받을 애들을 구체적으로 어떻게 구현할지 모르기때문에 display,typing은 자식이 알아서해라
	//컴퓨터는 공통으로쓸 turnOn, turnOff만 구현하고 display(), typing()은 구현하지않았다. 하위클래스로 책임전가
	abstract void display();
	abstract void typing();
	
	//일반메서드
	public void turnOn() {
		System.out.println("전원을 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("전원을 끕니다.");
	}
}
---------------
package ch9;

public class DeskTop extends Computer{

	@Override
	void display() {
		System.out.println("DeskTop display");
	}

	@Override
	void typing() {
		System.out.println("DeskTop typing");
	}

	@Override
	public void turnOff() { //재정의도 가능
		System.out.println("Desktop turnoff");
	}
}
------------------
package ch9;
//추상클래스를 상속받으면 메소드를 다 구현해야된다. 안하면 abstract를 붙여야한다.
public abstract class NoteBook extends Computer{ //추상클래스 (구현안한 메서드가 display()가있는데 이거를 구현안하면 abstract를 붙힌다)
	@Override
	public void typing() {
		System.out.println("NoteBook typing");		
	}
}
-------------------
package ch9;

public class MyNoteBook extends NoteBook{ //추상클래스인 NoteBook을 상속받음(부모가 구현안한 display()를 구현)

	@Override
	void display() {
		System.out.println("MyNoteBook display");		
	}
}
------------------
package ch9;

public class ComputerTest {

	public static void main(String[] args) {
		Computer computer = new DeskTop(); //Computer는 추상클래스(인스턴스화할수없다new), DeskTop은 일반클래스
		computer.display(); //오버라이딩된 인스턴스의 메서드를 찾아간다(desktop) -> 가상메서드
		computer.turnOff();
		
		NoteBook myNote = new MyNoteBook();
	}
}
==================================================================================
jdk(라이브러리) -> 안에도 라이브러리있음. -> 내가 필요한 경우 가져다쓰지만 내가 구성을한다.

안드로이드(프레임워크) -> 프레임워크를 도입한다는 애기는 이미 흐름이 정의되있다. 내가 어떤클래스를 넣으면 어떻게연동되고, 내가 값을 넣으면 어떻게 답이오고 영향을 주는지 등등
화면이 어떻게돌아가고 클로즈가되고 destroy가 된다 등은 안드로이드 내부에 이미정의되있지만(프레임워크) 실제로 화면에서 어떤위젯이 올라가고 어떤액션을 할지는 우리가 짜는것이다.
화면에 여러가지생성과정, 소멸과정 등은 정해져있지만 거기에 들어가는 기능들은 우리가해야한다.

프레임워크에서 많이쓰는 패턴중에하나가 템플릿메서드패턴이다.
- 추상 메서드나 구현된 메서드를 활용하여 코드의 흐름(시나리오)를 정의하는 메서드
- final로 선언하여 하위클래스에서 재정의 할 수 없게한다.(흐름은 변하면안되기때문에)
- 하위클래스에서 다르게 구현되어야 하는 부분은 추상메서드로 선언하여 하위 클래스에서 구현하도록 함

==================================================================================
package ch10;

public abstract class Car {
	//선언만했다.
	public abstract void drive(); //AI, 직접운전은 drive메서드는 자식이 구현해라
	public abstract void stop(); //마찬가지
	
	//시동은 공통이니까 구현했음
	public void startCar() {
		System.out.println("시동을 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("시동을 끕니다.");
	}
			
	public void washCar() {} //구현되긴했다.
	
	final public void run() {
		//시동을걸고 운전하다가 일이생기면 멈추고 시동꺼라 -> 시나리오(이거는 변하면안된다) -> run메서드를 재정의하면안되니까 final로 선언
		startCar(); //일반
		drive(); //추상
		stop(); //추상 
		turnOff(); //일반
		washCar(); //재정의할수있게끔(ai에서만 써도됨), 일반자동차는 재정의안했음
	}
}
------------------
package ch10;

public class AICar extends Car{
	
	//Car에서 상속받은 추상메서드 drive, stop 구현
	@Override
	public void drive() {
		System.out.println("자율 주행합니다.");
		System.out.println("자동차가 스스로 방향을 바꿉니다.");
	}

	@Override
	public void stop() {
		System.out.println("스스로 멈춥니다.");		
	}

	@Override
	public void washCar() {
		System.out.println("자동 세차를 합니다.");
	}
	
	
}
-----------------------
package ch10;

public class ManualCar extends Car{

	@Override
	public void drive() {
		System.out.println("사람이 운전합니다.");
		System.out.println("사람이 핸들을 조작합니다.");		
	}

	@Override
	public void stop() {
		System.out.println("브레이크를 밟아서 정지합니다.");		
	}

}
------------------------
package ch10;

public class CarTest {

	public static void main(String[] args) {
		Car aiCar = new AICar();
		aiCar.run();
		System.out.println("=================");
		Car manualCar = new ManualCar();
		manualCar.run();
	}
}
========================================================================
package ch10;

//이렇게 상수는 따로 빼서 쓴다.
public class Define {

	public static final int MIN = 1;
	public static final int MAX = 999999;
	public static final double PI = 3.14;
	public static final String GREETING = "Good Morning!";
	public static final int MATH_CODE = 1001;
	public static final int CHEMISTRY_CODE = 1002;
	
}
-------------------
package ch10;

public class UsingDefine {

	public static void main(String[] args) {

		System.out.println(Define.GREETING);
		System.out.println(Define.MIN);
		System.out.println(Define.MAX);
		System.out.println(Define.MATH_CODE);
		System.out.println(Define.CHEMISTRY_CODE);
		System.out.println("원주률은" + Define.PI + "입니다.");
	}

}
===========================================================================
#)인터페이스
인터페이스에서 메소드를 선언하면 모든 메소드가 자동으로 public abstract로 선언이된다.
모든 변수는 상수로 선언된다. public static final

interface 인터페이스 이름 {
	(public static final)float pi = 3.14F;
	public void makeSomthing(); //알아서 public abstract 으로 바뀜
}

============================================================================
#)인터페이스가 하는일
클래스나 프로그램이 제공하는 기능을 명시적으로 선언
클라이언트는 인터페이스에 선언된 메서드 명세만 보고 이를 구현한 클래스를 사용할 수 있음
클라이언트는 서버가 어떻게 구현되있는 모른다 -> 그래서 서버와 클라이언트 사이에 선언된 인터페이스 명세를 보고 클라이언트가 쓴다.(서버의 메서드가 어떻게 구현되있는지는 궁금하지않음)
어떤 객체가 하나의 인터페이스 타입이라는 것은 그 인터페이스가 제공하는 모든 메서드를 구현했다는 의미이다.
단, 클라이언트가 쓸때는 모든 메서드를 쓸필요는 없다. 서버만 모든 메서드를 구현
인터페이스를 구현한 다양한 객체를 사용함 -> 다형성

인터페이스를 쓰고있는 여러 클래스가 있어도 동일한 방식으로 쓰인다.

ex) jdbc 인터페이스 (connection도 인터페이스이다. -> 서드파티에서 메서드 구현했고 클라이언트는 골라쓰기만하면된다)

================================================================================
package ch11;

public interface Calc {

	double PI = 3.14; //static으로 바뀜
	int ERROR = -99999999;
	
	int add(int num1, int num2); //인터페이스는 abstract와 달리 상속이아니라 구현이라는 것이다.(Calculator에서 구현해야됨)
	int substract(int num1, int num2);
	int times(int num1, int num2);
	int divide(int num1, int num2);
	
}
-----------------
package ch11;

public abstract class Calculator implements Calc{ //abstract를 붙여야됨. implements를 붙이는순간 4개의 메서드를 구현해야되는데 2개만 구현했음
	//또, implement메서드는 자동으로 abstract가 붙기때문에 4개를 다 구현하지 않으면 abstract로 클래스를 만들어야한다.

	@Override
	public int add(int num1, int num2) {
		return num1 + num2;
	}
	
	@Override
	public int substract(int num1, int num2) {
		return num1 - num2;
	}
}

-------------------
package ch11;

public class CompleteCalc extends Calculator{
	
	@Override
	public int times(int num1, int num2) {
		return num1 * num2;
	}

	@Override
	public int divide(int num1, int num2) {
		if( num2 == 0 )
			return ERROR;
		else 
			return num1 / num2;
	}
	
	public void showInfo() {
		System.out.println("모두 구현하였습니다.");
	}
}
-----------------
package ch11;

import java.util.Scanner;

public class CalculatorTest {

	public static void main(String[] args) {
		Calc calc = new CompleteCalc(); //타입이 Calc이다.(인터페이스) 형변환, 인터페이스를 구현한 클래스는 인터페이스형으로 선언한 변수로 형 변환 할 수 있다.
		//형변환이된경우 인터페이스에 선언된 메서드만을 사용가능하다.
		int num1 = 10;
		int num2 = 2;
		
		System.out.println(num1 + "+" + num2 + "=" + calc.add(num1, num2));
		System.out.println(num1 + "-" + num2 + "=" +calc.substract(num1, num2));
		System.out.println(num1 + "*" + num2 + "=" +calc.times(num1, num2));
		System.out.println(num1 + "/" + num2 + "=" +calc.divide(num1, num2));
		
	}
}
==============================================================================
//인터페이스를 활용한 dao구현
dao인터페이스를 하나만들고 하나는 oracle, 또 하나는 mysql, 또 하나는 mssql용으로 만든다.
그러면 사용자는 implements로 바꾸기만 하면된다.
이런게 다형성이다. 똑같은 인터페이스를 활용해서 메서드를 활용하지만 결과는다르다.

===============================================================================
//인터페이스에서 모든 변수는 상수로 변환된다. public static final
//인터페이스에서 모든 선언된 메서드는 추상메서드로 선언된다.
//자바8이후에 디폴트메서드가있는데 implements가 된 클래스쪽에서 공통으로(기본적으로 제공) 사용할 수 있는 기본메서드이다. 오버라이딩로 가능
default void description() { //인터페이스쪽 
	System.out.println("정수계산기를 구현합니다.");
}

@Override //implements쪽 (class ~~~ implements ~~~~) 되는데 여기는 new로 인스턴스화를 해야된다. class이기때문에 하지만 정적메서드는 static이라 안해도된다.(아래참조)
public void description() {
	System.out.println("재정의");
}
==============================================================================
//또 자바8이후에 정적메서드를 제공한다.
위와 다르게 인스턴스 생성(new)과 관계없이 인터페이스 타입으로 사용할 수 있는 메서드
//자바 9이후에는 private메서드가 있다.
private이기때문에 인터페이스 내부에서만 사용하기 위해 구현하는 메서드
default메서드나 static메서드에서 사용한다.
=============================================================================
package ch14;

public interface Calc {

	double PI = 3.14;
	int ERROR = -99999999;
	
	int add(int num1, int num2);
	int substract(int num1, int num2);
	int times(int num1, int num2);
	int divide(int num1, int num2);
	
	default void description() {
		System.out.println("정수 계산기를 구현합니다.");
		myMethod(); 
	}
	
	static int total(int[] arr) { //arr의 합구하기
		int total = 0;
		
		for(int i: arr) {
			total += i;
		}
		mystaticMethod(); //static메서드에서 private static호출가능(private이기때문에 클래스안에서만)
		return total;
	}
	
	private void myMethod() { //버전때문에 지금 private는 안된다. 상속받은 CompleteCalc에서 구현하라고 에러가뜸
		System.out.println("private method");
	}
	
	private static void mystaticMethod() { 
		System.out.println("private static method");
	}
}
--------------
package ch14;

public abstract class Calculator implements Calc{ //implements를 하면 4개 함수 (add등)다 구현해야하는데 2개만해서 abstract붙혔다.

	@Override
	public int add(int num1, int num2) {
		return num1 + num2;
	}

	@Override
	public int substract(int num1, int num2) {
		return num1 - num2;
	}
}

---------------
package ch14;

public class CompleteCalc extends Calculator{ //Calc interface의 private myMethod, mystaticMethod는 재정의,구현할수없다.
	//즉, private메서드는 재정의할수없다.
	@Override
	public int times(int num1, int num2) {
		return num1 * num2;
	}

	@Override
	public int divide(int num1, int num2) {
		if( num2 == 0 )
			return ERROR;
		else 
			return num1 / num2;
	}
	
	public void showInfo() { //내 함수
		System.out.println("모두 구현하였습니다.");
	}

	@Override
	public void description() { //Calc interface에 있는 default메서드이다.
		System.out.println("CompleteCalc에서 재정의한 default 메서드");
		//super.description(); 부모에있는걸쓰는게아니라 재정의하겠다. 위에서
	}
}
----------------
package ch14;

public class CalculatorTest {

	public static void main(String[] args) {
		Calc calc = new CompleteCalc();
		int num1 = 10;
		int num2 = 2;
		
		System.out.println(num1 + "+" + num2 + "=" + calc.add(num1, num2));
		System.out.println(num1 + "-" + num2 + "=" +calc.substract(num1, num2));
		System.out.println(num1 + "*" + num2 + "=" +calc.times(num1, num2));
		System.out.println(num1 + "/" + num2 + "=" +calc.divide(num1, num2));
	
		calc.description();
		
		int[] arr = {1,2,3,4,5};
		int sum = Calc.total(arr); //total이라는 정적메서드이기때문에 바로 클래스를 호출했다.(private로 선언된 mystaticMethod도 호출했다 total에 같이선언되있으니)
		System.out.println(sum);
	}
}
====================================================================
#)여러 인터페이스 구현
//자바의 인터페이스에는 구현코드가 없으므로 하나의 클래스가 여러 인터페이스는 구현할수있음

buy(인터페이스)   sell(인터페이스)
       \	      /
      Customer(구현클래스) implements가 2개이다.

//그렇다면 클래스에서 상속은 왜 하나만 될까
예를들어 
a라는 클래스에서 b(클래스)가 a를 상속받고, c(클래스)가 상속받고 a라는 클래스에서 정의한 a라는 메서드를 b,c클래스에서 재정의하고나서
d라는 클래스가 d extends b extends c라고 한다면 무슨 메서드를 써야할지모른다. -> 따라서 다중상속이 안되는이유는 이러한 다이아몬드 상속때문이다.(c++은 가능하다. 어느클래스의 메서드를 써라는것을 지정가능)

static메서드는 인터페이스이름으로 호출
디폴트메서드가 중복되는 경우는 구현하는 클래스에서 재정의해야한다.(여러인터페이스호출시)

여러인터페이스를 구현한 클래스는 인터페이스 타입으로 형변환되는 경우 해당인터페이스에 선언된 메서드만 사용가능하다.
예를들어 buy로 인터페이스 타입선언되면 buy인터페이스 기능만 쓸수있다.

package ch15;

public interface Buy {

	void buy();
	
	default void order() {
		System.out.println("구매 주문");
	}
}
--------------
package ch15;

public interface Sell {

	void sell();
	
	default void order() {
		System.out.println("판매 주문");
	}
}
--------------
package ch15;

public class Customer implements Buy, Sell{

	@Override
	public void sell() {
		System.out.println("customer sell");
	}

	@Override
	public void buy() {
		System.out.println("customer buy");		
	}

	@Override
	public void order() { //default메서드를 재정의했다. 재정의나 명시적으로 누구의 메서드쓸지인지 선언 안하면에러가난다. 왜냐하면 buy,sell 디폴트메서드가 중복되기때문에
		//명시적으로 누구의 디폴트메서드를 쓸지 정의해야한다.
		//Sell.super.order();
		//아니면 그냥 재정의하던지
		System.out.println("customer order");
	}

	public void sayHello() { //내함수
		System.out.println("Hello");
	}

}
-----------------
package ch15;

public class CustomerTest {

	public static void main(String[] args) {

		Customer customer = new Customer();
		customer.buy();
		customer.sell();
		customer.sayHello();
		
		Buy buyer = customer; //type을 바꾼다.(업캐스팅)
		buyer.buy();
		
		Sell seller = customer;
		seller.sell();
		
		buyer.order(); //디폴트메서드로 정의한 order는 공통적으로 쓸수있다.
		seller.order();
	}
}
====================================================================
//인터페이스 상속
인터페이스 사이에도 상속을 사용할 수 있다.
extends 키워드를 사용
인터페이스는 다중상속이 가능하고 구현 코드의 상속이 아니므로 타입상속이라고 한다.

package ch15;

public interface X {

	void x();
}
------------
package ch15;

public interface Y {

	void y();
}
-------------
package ch15;

public interface MyInterface extends X, Y{  //인터페이스를 상속받음.

	void myMethod();
}
---------------
package ch15;

public class MyClass implements MyInterface{ //인터페이스 기능을 다 구현해야한다.

	@Override
	public void x() {
		System.out.println("x()");
	}

	@Override
	public void y() {
		System.out.println("y()");		
	}

	@Override
	public void myMethod() {
		System.out.println("myMethod()");		
	}
}
----------------
package ch15;

public class MyClassTest {

	public static void main(String[] args) {

		MyClass mClass = new MyClass(); //인터페이스는 클래스를 만들수없으니
		
		X xClass = mClass; //x로 타입이 되면 x만 쓸수있다.
		xClass.x();
		
		
		Y yClass = mClass;
		yClass.y();
		
		MyClass iClass = mClass;
		iClass.x();
		iClass.y();
		iClass.myMethod();
	}

}
========================================================
	   shelf  queue
(extends)\     /(implements)
		BookShelf

책이 순서대로 대여가 되는 도서관구현(FIFO)
shelf클래스를 상속받고 queue를 구현한다.

package ch15;

import java.util.ArrayList;

public class Shelf {

	 protected ArrayList<String> shelf; //상속받기위해 protected
	 
	 public Shelf() {
		 shelf = new ArrayList<String>();
	 }
	 
	 public ArrayList<String> getShelf(){
		 return shelf;
	 }
	 
	 public int getCount() {
		 return shelf.size();
	 }
	 
}
---------------
package ch15;

public interface Queue {

	//함수 3개선언
	void enQueue(String title);
	String deQueue(); //꺼내면 책의 이름을 반환
	
	int getSize(); //몇개가있느냐
}
---------------
package ch15;

public class BookShelf extends Shelf implements Queue{

	@Override
	public void enQueue(String title) {
		shelf.add(title); //shelf의 기능
	}

	@Override
	public String deQueue() {
		return shelf.remove(0); 
	}
 
	@Override
	public int getSize() {
		return getCount();
	}

}
------------------
package ch15;

public class BookShelfTest {

	public static void main(String[] args) {

		Queue bookQueue = new BookShelf(); //큐타입, 인터페이스는 new해서 못만든다.
		bookQueue.enQueue("태백산맥1");
		bookQueue.enQueue("태백산맥2");
		bookQueue.enQueue("태백산맥3");
		
		System.out.println(bookQueue.deQueue());
		System.out.println(bookQueue.deQueue());
		System.out.println(bookQueue.deQueue());
	}

}
=========================================================================
//상담원 작업분배 
//1. 우선배분(priority)
//2. 가장일이적은(leastjob)
//3. 
package ch16.scheduler;

public interface Scheduler {
	public void getNextCall();
	public void sendCallToAgent();
}
---------------
package ch16.scheduler;

public class PriorityAllocation implements Scheduler{

	@Override
	public void getNextCall() {
		System.out.println("고객등급이 높은 고객의 call을 먼저 가져옵니다");
		
	}

	@Override
	public void sendCallToAgent() {
		System.out.println("업무 숙련도가 높은 상담원에게 먼저 배분합니다");		
	}

}
-----------------
package ch16.scheduler;

public class LeastJob implements Scheduler{

	@Override
	public void getNextCall() {
		System.out.println("상담 전화를 순서대로 대기열에서 가져옵니다.");
		
	}

	@Override
	public void sendCallToAgent() {
		System.out.println("현재 상담업무가 없거나 상담대기가 가장 적은 상담원에게 할당합니다.");
		
	}

}
-------------------
package ch16.scheduler;

public class RoundRobin implements Scheduler{

	@Override
	public void getNextCall() {
		System.out.println("상담 전화를 순서대로 대기열에서 가져옵니다.");
	}

	@Override
	public void sendCallToAgent() {
		System.out.println("다음 순서의 상담원에게 배분합니다.");
	}

}
-----------------------
package ch16.scheduler;

import java.io.IOException;

public class SchedulerTest {

	public static void main(String[] args) throws IOException {

		System.out.println("전화 상담원 할당 방식을 선택하세요");
		System.out.println("R : 한명씩 차례대로");
		System.out.println("L : 대기가 적은 상담원 우선");
		System.out.println("P : 우선순위가 높은 고객우선 숙련도 높은 상담원");
		
		int ch = System.in.read();
		Scheduler scheduler = null; //인터페이스
		
		if ( ch == 'R' || ch =='r') {
			scheduler = new RoundRobin(); //인터페이스에만 있는 메서드만쓸수있다. RoundRobin에 재정의 된것
		}
		else if ( ch == 'L' || ch =='l') {
			scheduler = new LeastJob();
		}
		else if ( ch == 'P' || ch =='p') {
			scheduler = new PriorityAllocation();
		}
		else {
			System.out.println("지원되지 않는 기능입니다.");
			return;
		}
		
		scheduler.getNextCall();
		scheduler.sendCallToAgent();
	}

}
===============================================================
package ch16.gamelevel;

public abstract class PlayerLevel {
	
	public abstract void run();
	public abstract void jump();
	public abstract void turn();
	public abstract void showLevelMessage();
	
	
	final public void go(int count) { //템플릿메서드패턴
		run();
		for(int i = 0; i<count; i++) {
			jump();
		}
		turn();
	}

}
------------------
package ch16.gamelevel;

public class BeginnerLevel extends PlayerLevel{

	@Override
	public void run() {
		System.out.println("천천히 달립니다.");
	}

	@Override
	public void jump() {
		System.out.println("jump 못하지롱");
	}

	@Override
	public void turn() {
		System.out.println("turn 못하지롱");
	}

	@Override
	public void showLevelMessage() {
		System.out.println("****** 초급자 레벨입니다. ******");
	}

}
-------------------
package ch16.gamelevel;

public class AdvancedLevel extends PlayerLevel{

	@Override
	public void run() {
		System.out.println("빨리 달립니다.");
	}

	@Override
	public void jump() {
		System.out.println("높이 jump 합니다.");
	}

	@Override
	public void turn() {
		System.out.println("turn 못하지롱");
	}

	@Override
	public void showLevelMessage() {
		System.out.println("****** 중급자 레벨입니다. ******");
	}
}
---------------------
package ch16.gamelevel;

public class SuperLevel extends PlayerLevel{

	@Override
	public void run() {
		System.out.println("엄청 빠르게 달립니다.");
	}

	@Override
	public void jump() {
		System.out.println("아주 높이jump 합니다.");
	}

	@Override
	public void turn() {
		System.out.println("turn 합니다.");
	}

	@Override
	public void showLevelMessage() {
		System.out.println("****** 고급자 레벨입니다. ******");
	}
}
-----------------
package ch16.gamelevel;

public class UltraSuperLevel extends PlayerLevel{

	@Override
	public void run() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void jump() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void turn() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void showLevelMessage() {
		// TODO Auto-generated method stub
		
	}

}
--------------------
package ch16.gamelevel;

public class Player {
	
	private PlayerLevel level;
	
	public Player(){
		level = new BeginnerLevel();
		level.showLevelMessage();
	}
	
	
	public PlayerLevel getLevel() {
		return level;
	}
	
	public void upgradeLevel( PlayerLevel level ) {
		this.level = level;
		level.showLevelMessage();
	}
	
	public void play(int count) {
		level.go(count); //go에는 해당레벨의 run,turn 등
	}

}
----------------------
package ch16.gamelevel;

public class MainBoardPlay {

	public static void main(String[] args) {

		Player player = new Player();
		player.play(1); //기본레벨플레이어에서 계속 player.upgrade하는 방식
		
		AdvancedLevel aLevel = new AdvancedLevel();
		player.upgradeLevel(aLevel);
		player.play(2);
		
		SuperLevel sLevel = new SuperLevel();
		player.upgradeLevel(sLevel);
		player.play(3);
		
	}

}
=====================================================================
//오브젝트클래스
모든 클래스의 최상위 클래스이다. 
java.lang패키지 -> import안해도된다. String, Integer, System 등
모든 클래스는 오브젝트클래스를 상속받는다.
또 재정의도 할 수 있다. 물론, 재정의 할 수 없는 것도있는데 그거는 final로 선언되서 그렇다.

모든클래스는 java.lang.Object클래스를 상속받는다.
class Student = class Student (extends Object) 이렇게 된다.

toString 메서드는 객체의 정보를 String으로 바꾸어서 사용할 때 쓰인다.
=========================================================================
package ch01;

class Book{
	
	private String title;
	private String author;
	
	public Book(String title, String author) {
		this.title = title;
		this.author = author;
	}
	
	public String toString() {
		return title + "," + author;
	}
}

public class BookTest {

	public static void main(String[] args) {

		Book book = new Book("데미안", "헤르만 헤세");
		
		System.out.println(book);
	}
}
=========================================================================
//오브젝트 클래스
equals()메서드

StudentLee(메모리를 가리키는 참조변수)-----> 힙(인스턴스)   
StudentLee2                  ----->    "
이 두 참조변수가 똑같은 힙메모리를 가리키면 두개가 같다.(물리적)

equals의 역할은 두 인스턴스의 주소값을 비교하여 true/false를 반환
하지만, 재정의해서 두인스턴스가 논리적으로 같은지 비교 가능

clone()메서드
객체의 원본을 복제하는데 사용(멤버변수 등이 똑같은)
생성자랑은 다르다.
clone()메서드를 사용하면 객체의 정보(멤버변수 값 등)가 동일한 또 다른 인스턴스가 생성되는 것이므로, 은닉, 객체 보호의 관점에서 위배 될 수 있다.
private 까지 다 복제하니까
그래서 복제해도된다라는 것을 구분하기 위해 public class Student implements Cloneable 를 붙여준다.

-----------------------------------------------------
package ch02;

public class Student implements Cloneable{

	private int studentId;
	private String studentName;

	public Student(int studentId, String studentName)
	{
		this.studentId = studentId;
		this.studentName = studentName;
	}
	
	public boolean equals(Object obj) {
		if( obj instanceof Student) { //넘어온 객체가 Student인가
			Student std = (Student)obj; //그렇다면 obj를 Student로 다운캐스팅
			if(this.studentId == std.studentId ) //id로 똑같은 학생인지 확인(주소가 서로달라도) 즉, 주소가(물리적)달라도 논리적으로 같다. 
				return true;
			else return false;
		}
		return false;
		
	}
	
	public void setStudentName(String name) {
		this.studentName = name;
	}
	@Override
	public int hashCode() {
		return studentId;
	}

	@Override
	protected Object clone() throws CloneNotSupportedException {
		// TODO Auto-generated method stub
		return super.clone();
	}
	
}
----------------
package ch02;

public class EqualTest {

	public static void main(String[] args) throws CloneNotSupportedException { //cloneable하지않는데 clone할때 예외발생처리
		Student Lee = new Student(100, "Lee");
		Student Lee2 = Lee;
		Student Shun = new Student(100, "Lee");
		
		System.out.println(Lee == Shun); // 같은 클래스로 만들었지만 false로 나온다. 다른 객체이기때문에
		System.out.println(Lee.equals(Shun)); //재정의 안하면 false로 나온다. equals의 원래 재정의를 안하면 주소값이 같느냐를 보는것이다. 근데 우리는 재정의를 했다
		System.out.println(Lee == Lee2); //true
		
		System.out.println(Lee.hashCode()); //917~  서로 메모리주소가 다르기때문에
		System.out.println(Shun.hashCode()); //199~ 다른값이 나온다.
		//하지만 우리가 hashCode()를 재정의 했기때문에 같은값이나온다(Studentid)
		
		//그렇다고 기존에 가지고있던 hashCode()는 없어지지 않는다.
		//System.out.println(System.identityHashCode(Lee));
		//System.out.println(System.identityHashCode(Shun));
		
		//이와같은 방법으로 Integer, String도 위와같이 equals, hashCode가 오버라이딩이 되어있다.
		//그래서 아래와같이 나온다.
		Integer i1 = new Integer(100); //String str1 = new String("abc");
		Integer i2 = new Integer(100); //String str2 = new String("abc");
		
		System.out.println(i1.equals(i2)); //true
		System.out.println(i1.hashCode()); //100
		System.out.println(i2.hashCode()); //100
		
		System.out.println(System.identityHashCode(i1)); //주소값은 다르다
		System.out.println(System.identityHashCode(i2)); //주소값은 다르다.
		
		Lee.setStudentName("kim");
		Student Lee3 = (Student)Lee.clone(); //클론의 return타입은 object이기때문에 다운캐스팅
		System.out.println(Lee3); //100,kim 으로 나온다. 즉, 복제하면 다가져온다.
		
		System.out.println(System.identityHashCode(Lee)); //복제를 해도 주소값은다르다.
		System.out.println(System.identityHashCode(Lee3)); //값은 다르다.
		
		
		
	}
}
=================================================================================
//String 클래스
방법1. String str1 = new String("abc"); 이거는 힙에 생성
방법2. String str2 = "abc"; //상수풀에 잡힌다.  위랑 다르다. 

즉 힙메모리는 생성될 때마다 다른 주소값을 가지지만, 상수풀의 문자열은 모두 같은 주소값을 가진다.
package ch03;

public class StringTest {

	public static void main(String[] args) {
		String str1 = new String("abc");
		String str2 = new String("abc");
		
		System.out.println(str1 == str2); //false
		
		String str3 = "abc"; //abc를 가리키는 참조변수 2개(상수풀을 가리킴)
		String str4 = "abc";
		
		System.out.println(str3 == str4); //true
	}
}

==================================================================================
여기서 한번 생성된 String은 값을 바꿀수없다. new로 하든, 상수로 만들던 바꿀수없다.  -> immutable

package ch03;

public class StringTest2 {

	public static void main(String[] args) {
		String java = new String("java");
		String android = new String("android");
		System.out.println(System.identityHashCode(java));
		
		java = java.concat(android); //위에서 선언한 java참조변수가 새로운 공간인 javaandroid를 가리키게된다. 기존에있던 "java"공간은 남아있다.
		//근데 이렇게 쓰면 메모리 낭비이다.
		
		System.out.println(java);
		System.out.println(System.identityHashCode(java)); //다른주소를 가리킨다.
		
	}
}
//출력결과
366712642
javaandroid
1829164700

//이게 단점이 문자열을 연결할 때 메모리가 계속 생성되니까 StringBuilder를 쓰는 것이다.
======================================================
String은 final이라서 변경이 안되지만 String Builder, String Buffer는 변경이 된다.
그래서, 문자열은 연결, 변경할 떄 사용하면 유용하다.

String Builder는 단일쓰레드프로그램에서 사용을 권장
String Buffer는 멀티쓰레드 프로그램에서 동기화를 보장

package ch03;

public class StringBuilderTest {

	public static void main(String[] args) {
		String java = new String("java");
		String android = new String("android");
		
		StringBuilder buffer = new StringBuilder(java);
		System.out.println(System.identityHashCode(buffer));
		buffer.append("android");
		System.out.println(System.identityHashCode(buffer));
		
		java = buffer.toString(); //문자로체인지
		System.out.println(java);
	}
}
//출력결과
366712642
366712642
javaandroid
==============================================================
//java13부터가능 text block
package ch03;

public class StringTextBlock {

	public static void main(String[] args) {
		
		String strBlock = """
				This 
				is 
				text
				block
				test.""";
		System.out.println(strBlock);
		
		System.out.println(getBlockOfHtml());
		
	}
	
	public static String getBlockOfHtml() {
		    return """
		            <html>
		                <body>
		                    <span>example text</span>
		                </body>
		            </html>""";
		
	}

}
//출력
This 
is 
text
block
test.
 <html>
     <body>
		 <span>example text</span>
	</body>
</html>
======================================================================
//동적로딩
원래는 우리가 Person jo, Student lee 이렇게 데이터타입이 binding되는데 
동적로딩은 컴파일시에 데이터타입이 binding되는것이 아닌, 실행(runntime)중에 데이터타입을 binding을 하는 방법이다.
즉, 프로그래밍시에는 문자열변수로 처리했다가 런타임시에는 원하는 클래스를 로딩하여 binding 할수있다는장점이다.
단점은 컴파일시에 타입이 정해지지않으므로 동적로딩시 오류가 발생하면 프로그램의 심각한 장애가 발생

즉, 시스템이 돌아가다가 필요한 데이터타입을 그때 클래스를 부르는게 장점이다.

package ch04;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

public class StringTest {

	public static void main(String[] args) throws ClassNotFoundException {
		Class c3 =  Class.forName("java.lang.String");
		
		//c.getConstructors(); 배열로반환된다
		
		Constructor<String>[] cons =  c3.getConstructors();
		for(Constructor con: cons) {
			System.out.println(con); //많은생성자가 있다. 
		}
		
		System.out.println();
		
		Method[] methods = c3.getMethods();
		for(Method  method : methods) {
			System.out.println(method);
		}
	}

}
============================================================================
package ch04;

public class Person {
	private String name;
	private int age;
	
	//생성자 3개
	public Person() {};
	
	public Person(String name) {
		this.name = name;
	}
	
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
	
	public String toString() {
		return name;
	}
}
---------------------
package ch04;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class ClassTest {

	public static void main(String[] args) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException,
						ClassNotFoundException, NoSuchMethodException, SecurityException {
		//기존방식
		Person person = new Person("James");
		System.out.println(person); //James
		
		//동적로딩
		//Class.forName("클래스이름") 메서드로 클래스를 동적으로 로드함(런타임시에)
		
		//Class c = String.class; 클래스 이름으로 직접 Class가져오기
		
		//생성된 인스턴스에서 Class 클래스 가져오기
		//String s = new String();
		//Class c = s.getClass(); 
		
		Class c1 = Class.forName("ch04.Person"); //class를 가져오는 방법 1
		Person person1 = (Person)c1.newInstance(); //반환값이 오브젝트라서
		person1.setName("Lee");
		System.out.println(person1); //Lee 출력(오버라이딩했으니)
		
		//class를 가져오는 방법2
		//아래까지가 실질적으로 Person kim2 = new Person("김유신"); 과 같다.
		//이런거는 local에 Person이라는 클래스가 없을 떄 쓰는것이다.
		Class c2 = person1.getClass(); //getClass를 쓸려면 이미 인스턴스가 있는상태여야한다.
		Person p = (Person)c2.newInstance();
		System.out.println(p); //null출력
		
		Class[] parameterTypes = {String.class};  //person이라는 타입의 클래스가 없는데 
		Constructor cons = c2.getConstructor(parameterTypes); //constructor정보를 가져와서 반환해준다. 
		
		Object[] initargs = {"김유신"};
		Person personLee = (Person)cons.newInstance(initargs);
		System.out.println(personLee); //김유신 출력
		
		//이런게 reflection 프로그래밍인데
		//Class 클래스를 사용하여 클래스의 정보(생성자, 변수, 메서드)등을 알수있고 인스턴스를 생성하고, 메서드를 호출하는 방식의 프로그래밍
		//로컬메모리에 객체없는경우, 원격프로그래밍, 객체의 타입을 알수없는 경우에 사용
		
		
	}
}
===========================================================================================
//자료구조
메모리상에서 관리하는 여러 구현방법들
효율적인 자료구조가 성능 좋은 알고리즘의 기반이 된다.

1. 배열
선형으로 자료를 관리. 정해진 크기의 메모리를 먼저 할당받아 사용. (어느 위치에 있는걸 가져오는게 빠르다.) 4byte씩 a[2]에서 a[0]이 메모리주소가 10이라면 a[2]는 18 
jdk클래스: ArrayList, Vector
2. 연결리스트
선형으로 자료를 관리, 자료가 추가될때마다 메모리를 할당받고, 자료는 링크로 연결된다. (자료 + 링크) 로 구성, 수행속도가 데이터가 삭제,삽입이 배열보다 빠르다.(링크연결만수정), 배열은 넣고, 삭제 시에는 나머지애들이 다 밀리거나 땡겨져야하니까 느리다.
단, 가져오는거는 맨처음부터 찾아가야하기때문에 느리다.
3.스택(선형)
가장 나중에 입력된 자료가 가장먼저 출력되는 자료구조(LIFO)
4.큐(선형)
가장 먼저 입력된 자료가 가장 먼저 출력되는 자료구조(FIFO)
맨앞은 front(자료삭제되는부분=dequeue), 맨뒤는 rear(자료추가되는부분=enqueue)
5.트리(비선형)
부모,자식노드
이진트리는 부모노드에 자식노드가 두개 이하인 트리
힙은 꽉찬(pull)이진트리는 아니지만 complete이진트리이다. 왼쪽은 채워져있는형태
힙은 MaxHeap: 부모노드는 자식노드보다 항상 크거나 같은 값을 가지는 경우(root가 젤크다)
    MinHeap : 부모노드는 자식노드보다 항상 작거나 같은 값을 가지는 경우(root가 젤작다)

이진검색트리는 값이 중복되면 안된다. 힙은 중복되도 된다.
왼쪽자식노드는 부모노드보다 작은값, 오른쪽은 부모노드보다 큰값.
검색시 절반은 계속 날라간다.
즉, 23,10,28,15,7,22,22,56순으로 넣을 때는
23을 먼저넣고 10을 넣을 때 23보다 작으면 왼쪽자식노드에 배치 .... 22를 넣을 때 중복되니까 한번만
 
6.해싱 : 자료를 검색하기 위한 자료구조
key는 유일하고 이에대한 value를 쌍으로 저장
jdk클래스 : HashMap, Properties
들어가는 순서와상관없이 꺼냈을때는 내가 넣은 순서와상관없이 출력된다.
왜냐하면 해시함수로 정해진인덱스에 넣었기떄문에


==================================================================================================
//배열구현
package ch02;

public class MyArray {

	int[] intArr;   	//int array
	int count;  		//개수
		
	public int ARRAY_SIZE;
	public static final int ERROR_NUM = -999999999;
	
	public MyArray()// 그냥 생성시 기본 배열 사이즈 10
	{
		count = 0;
		ARRAY_SIZE = 10;
		intArr = new int[ARRAY_SIZE];
	}
	
	public MyArray(int size) //사이즈 정할 때
	{
		count = 0;
		ARRAY_SIZE = size;
		intArr = new int[size];
	}
	
	public void addElement(int num)
	{
		if(count >= ARRAY_SIZE){ //꽉찼을때
			System.out.println("not enough memory");
			return;
		}
		//꽉안찼을때
		intArr[count++] = num;
				
	}

	public void insertElement(int position, int num) //position은 0부터
	{
		int i;
		
		if(count >= ARRAY_SIZE){  //꽉 찬 경우
			System.out.println("not enough memory");
			return;
		}
		
		if(position < 0 || position > count ){  //index error
			System.out.println("insert Error");
			return;
		}
		
		for( i = count-1; i >= position ; i--){ //뒤에서부터 한칸씩밀고 넣어야한다.(덮어쓰기때문에)
			intArr[i+1]  = intArr[i];        // 하나씩 이동
		}
		
		intArr[position] = num;
		count++;
	}
	
	public int removeElement(int position)
	{
		int ret = ERROR_NUM;
		
		if( isEmpty() ){
			System.out.println("There is no element");
			return ret;
		}
		
		if(position < 0 || position >= count ){  //index error, 포지션이 카운트랑같거나 크면(카운트는 인덱스 + 1이니까)
			System.out.println("remove Error");
			return ret;
		}
		
		ret = intArr[position];
		
		for(int i = position; i<count -1; i++ ) //배열안의 개수 -1 까지이다. 배열의 길이가 아니라.
		{
			intArr[i] = intArr[i+1];
		}
		count--;
		return ret;
	}
	
	public int getSize()
	{
		return count;
	}
	
	public boolean isEmpty()
	{
		if(count == 0){
			return true;
		}
		else return false;
	}
	
	public int getElement(int position)
	{
		if(position < 0 || position > count-1){
			System.out.println("검색 위치 오류. 현재 리스트의 개수는 " + count +"개 입니다.");
			return ERROR_NUM;
		}
		return intArr[position];
	}
	
	public void printAll()
	{
		if(count == 0){
			System.out.println("출력할 내용이 없습니다.");
			return;
		}
			
		for(int i=0; i<count; i++){
			System.out.println(intArr[i]);
		}
		
	}
	
	public void removeAll()
	{
		for(int i=0; i<count; i++){
			intArr[i] = 0;
		}
		count = 0;
	}
}
----------------
package ch02;

public class MyArrayTest {

	public static void main(String[] args) {

		MyArray array = new MyArray();
		array.addElement(10);
		array.addElement(20);
		array.addElement(30);
		array.insertElement(1, 50);
		array.printAll();
		
		System.out.println("===============");
		array.removeElement(1);
		array.printAll();
		System.out.println("===============");
			
		array.addElement(70);
		array.printAll();
		System.out.println("===============");
		array.removeElement(1);
		array.printAll();
		
		System.out.println("===============");
		System.out.println(array.getElement(2));
		
	}
}
================================================================
//연결리스트
package ch03;

public class MyListNode {

	private String data;       // 자료
	public MyListNode next;    // 다음 노드를 가리키는 링크
	
	public MyListNode(){
		data = null;
		next = null;
	}
	
	public MyListNode(String data){
		this.data = data;
		this.next = null;
	}
	
	public MyListNode(String data, MyListNode link){
		this.data = data;
		this.next = link;
	}
	
	public String getData(){
		return data;
	}
}
--------------
package ch03;

public class MyLinkedList {

	private MyListNode head;
	int count;
	
	public MyLinkedList()
	{
		head = null;
		count = 0;
	}
	
	public MyListNode addElement( String data ) //앞이나 뒤에 추가
	{
		
		MyListNode newNode; //새로 들어갈 애
		if(head == null){  //맨 처음일때는 링크 필요없이 데이터만 있으면 되니까
			newNode = new MyListNode(data); //들어오는 데이터로 노드생성
			head = newNode; //헤드가 첫번쨰노드가된다.
		}
		else{ //첫번째노드가 아닌경우(맨뒤인경우이다) 찾아가는 과정은 head부터 찾아가면된다. 그리고 맨마지막 노드는 가리키는 게 null이다.
			newNode = new MyListNode(data); //next = null(마지막에 넣을거기 떄문에)
			MyListNode temp = head; //헤드부터 돌수있게끔(헤드를 받아와서)
			while(temp.next != null) {//맨 뒤로 갈떄까지
				temp = temp.next;
			}
			temp.next = newNode;
		}
		count++;
		return newNode;
	}
	
	public MyListNode insertElement(int position, String data )
	{
		int i;
		MyListNode tempNode = head;
		MyListNode newNode = new MyListNode(data);
		
		if(position < 0 || position > count ){
			System.out.println("추가 할 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 앞으로 들어가는 경우
			newNode.next = head; //newNode는 맨앞에 insert하려는 노드이다. 맨앞에 넣기때문에 head를 다음요소로 가리킨다.
			head = newNode; //새로들어온게 head로 들어가고
		}
		else{
			MyListNode preNode = null;	 //중간에들어가는경우
			for(i=0; i<position; i++){
				preNode = tempNode;
				tempNode = tempNode.next;
				
			}
			newNode.next = preNode.next;
			preNode.next = newNode;
		}
		count++;
		return newNode;
	}
	
	public MyListNode removeElement(int position) //위치로 삭제
	{
		int i;
		MyListNode tempNode = head;
		MyListNode preNode = null;
		
		if(position >= count ){
			System.out.println("삭제 할 위치 오류입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 앞을 삭제하면 다음요소가 헤드가된다.
			head = tempNode.next;
		}
		else{ //중간에서 뺴는경우
			MyListNode preNode = null;	
			for(i=0; i<position; i++){ 
				preNode = tempNode;
				tempNode = tempNode.next; //for문돌리면 tempNode가 내가 지우는 노드가 된다.
			}
			preNode.next = tempNode.next;
		}
		count--;
		System.out.println(position + "번째 항목 삭제되었습니다.");
		
		return tempNode;
	}
	
	public String getElement(int position)
	{
		int i;
		MyListNode tempNode = head;
		
		if(position >= count ){
			System.out.println("검색 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return new String("error");
		}
		
		if(position == 0){  //맨 인 경우

			return head.getData();
		}
		
		for(i=0; i<position; i++){
			tempNode = tempNode.next;
			
		}
		return tempNode.getData();
	}

	public MyListNode getNode(int position)
	{
		int i;
		MyListNode tempNode = head;
		
		if(position >= count ){
			System.out.println("검색 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 인 경우

			return head;
		}
		
		for(i=0; i<position; i++){
			tempNode = tempNode.next;
			
		}
		return tempNode;
	}

	public void removeAll()
	{
		head = null;
		count = 0;
		
	}
	
	public int getSize()
	{
		return count;
	}
	
	public void printAll()
	{
		if(count == 0){
			System.out.println("출력할 내용이 없습니다.");
			return;
		}
		
		MyListNode temp = head;
		while(temp != null){
			System.out.print(temp.getData());
			temp = temp.next;
			if(temp!=null){
				System.out.print("->");
			}
		}
		System.out.println("");
	}
	
	public boolean isEmpty()
	{
		if(head == null) return true;
		else return false;
	}
	
}
-------------------
package ch03;

public class MyLinkedListTest {

	public static void main(String[] args) {

		MyLinkedList list = new MyLinkedList();
		list.addElement("A");
		list.addElement("B");
		list.addElement("C");
		list.printAll();
		list.insertElement(3, "D"); //4번쨰에 D넣어라
		list.printAll();
		list.removeElement(0); //head지우기
		list.printAll();
		list.removeElement(1);
		list.printAll();
						
		list.insertElement(0, "A-1");
		list.printAll();
		System.out.println(list.getSize());
		
		list.removeElement(0);
		list.printAll();
		System.out.println(list.getSize());
		
		list.removeAll();
		list.printAll();
		list.addElement("A");
		list.printAll();
		System.out.println(list.getElement(0));
		list.removeElement(0);
	}
}
=========================================================================
//스택
package ch02;

public class MyArray {

	int[] intArr;   	//int array
	int count;  		//개수
		
	public int ARRAY_SIZE;
	public static final int ERROR_NUM = -999999999;
	
	public MyArray()// 그냥 생성시 기본 배열 사이즈 10
	{
		count = 0;
		ARRAY_SIZE = 10;
		intArr = new int[ARRAY_SIZE];
	}
	
	public MyArray(int size) //사이즈 정할 때
	{
		count = 0;
		ARRAY_SIZE = size;
		intArr = new int[size];
	}
	
	public void addElement(int num)
	{
		if(count >= ARRAY_SIZE){ //꽉찼을때
			System.out.println("not enough memory");
			return;
		}
		//꽉안찼을때
		intArr[count++] = num;
				
	}

	public void insertElement(int position, int num) //position은 0부터
	{
		int i;
		
		if(count >= ARRAY_SIZE){  //꽉 찬 경우
			System.out.println("not enough memory");
			return;
		}
		
		if(position < 0 || position > count ){  //index error
			System.out.println("insert Error");
			return;
		}
		
		for( i = count-1; i >= position ; i--){ //뒤에서부터 한칸씩밀고 넣어야한다.(덮어쓰기때문에)
			intArr[i+1]  = intArr[i];        // 하나씩 이동
		}
		
		intArr[position] = num;
		count++;
	}
	
	public int removeElement(int position)
	{
		int ret = ERROR_NUM;
		
		if( isEmpty() ){
			System.out.println("There is no element");
			return ret;
		}
		
		if(position < 0 || position >= count ){  //index error, 포지션이 카운트랑같거나 크면(카운트는 인덱스 + 1이니까)
			System.out.println("remove Error");
			return ret;
		}
		
		ret = intArr[position];
		
		for(int i = position; i<count -1; i++ ) //배열안의 개수 -1 까지이다. 배열의 길이가 아니라.
		{
			intArr[i] = intArr[i+1];
		}
		count--;
		return ret;
	}
	
	public int getSize()
	{
		return count;
	}
	
	public boolean isEmpty()
	{
		if(count == 0){
			return true;
		}
		else return false;
	}
	
	public int getElement(int position)
	{
		if(position < 0 || position > count-1){
			System.out.println("검색 위치 오류. 현재 리스트의 개수는 " + count +"개 입니다.");
			return ERROR_NUM;
		}
		return intArr[position];
	}
	
	public void printAll()
	{
		if(count == 0){
			System.out.println("출력할 내용이 없습니다.");
			return;
		}
			
		for(int i=0; i<count; i++){
			System.out.println(intArr[i]);
		}
		
	}
	
	public void removeAll()
	{
		for(int i=0; i<count; i++){
			intArr[i] = 0;
		}
		count = 0;
	}
}
--------------
package ch04;

import ch02.MyArray;

public class MyArrayStack {

	int top;
	MyArray arrayStack; 
	
	public MyArrayStack()
	{
		top = 0;
		arrayStack = new MyArray();
	}
	
	public MyArrayStack(int size) //사이즈만큼
	{
		arrayStack = new MyArray(size);
	}
	
	public void push(int data)
	{
		if(isFull()){ //아래에 isFull함수가있다.
			System.out.println("stack is full");
			return;
		}
		
		arrayStack.addElement(data); //배열의 맨뒤로 쭉쭉 들어간다.
		top++;
	}
	
	public int pop()
	{
		if (top == 0){
			System.out.println("stack is empty");
			return MyArray.ERROR_NUM;
		}
		return arrayStack.removeElement(--top);//탑1을 지울려면 removelemnet는 인덱스요소로 지우니까 --top으로 (0)번쨰
		
	}
	
	public int peek()
	{
		if (top == 0){
			System.out.println("stack is empty");
			return MyArray.ERROR_NUM;
		}
		return arrayStack.getElement(top-1);
	}
	
	public int getSize()
	{
		return top;
	}
	
	public boolean isFull()
	{
		if(top == arrayStack.ARRAY_SIZE){ //top이 개수와같다.
			return true;
		}
		else return false;
	}
	
	public boolean isEmpty()
	{
		if (top == 0){
			return true;
		}
		else return false;
	}
	
	public void printAll()
	{
		arrayStack.printAll();
	}
}
----------------
package ch04;

public class MyArrayStackTest {

	public static void main(String[] args) {

		MyArrayStack stack = new MyArrayStack(3);
		
		stack.push(10);
		stack.push(20);
		stack.push(30);
		stack.push(40);
		
		stack.printAll();
		
		System.out.println("top element is " + stack.pop());
		stack.printAll();
		System.out.println("stack size is " + stack.getSize());
	}
}
============================================================================
//큐 구현
package ch03;

public class MyListNode {

	private String data;       // 자료
	public MyListNode next;    // 다음 노드를 가리키는 링크
	
	public MyListNode(){
		data = null;
		next = null;
	}
	
	public MyListNode(String data){
		this.data = data;
		this.next = null;
	}
	
	public MyListNode(String data, MyListNode link){
		this.data = data;
		this.next = link;
	}
	
	public String getData(){
		return data;
	}
}
--------------
package ch03;

public class MyLinkedList {

	private MyListNode head;
	int count;
	
	public MyLinkedList()
	{
		head = null;
		count = 0;
	}
	
	public MyListNode addElement( String data ) //앞이나 뒤에 추가
	{
		
		MyListNode newNode; //새로 들어갈 애
		if(head == null){  //맨 처음일때는 링크 필요없이 데이터만 있으면 되니까
			newNode = new MyListNode(data); //들어오는 데이터로 노드생성
			head = newNode; //헤드가 첫번쨰노드가된다.
		}
		else{ //첫번째노드가 아닌경우(맨뒤인경우이다) 찾아가는 과정은 head부터 찾아가면된다. 그리고 맨마지막 노드는 가리키는 게 null이다.
			newNode = new MyListNode(data); //next = null(마지막에 넣을거기 떄문에)
			MyListNode temp = head; //헤드부터 돌수있게끔(헤드를 받아와서)
			while(temp.next != null) {//맨 뒤로 갈떄까지
				temp = temp.next;
			}
			temp.next = newNode;
		}
		count++;
		return newNode;
	}
	
	public MyListNode insertElement(int position, String data )
	{
		int i;
		MyListNode tempNode = head;
		MyListNode newNode = new MyListNode(data);
		
		if(position < 0 || position > count ){
			System.out.println("추가 할 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 앞으로 들어가는 경우
			newNode.next = head; //newNode는 맨앞에 insert하려는 노드이다. 맨앞에 넣기때문에 head를 다음요소로 가리킨다.
			head = newNode; //새로들어온게 head로 들어가고
		}
		else{
			MyListNode preNode = null;	 //중간에들어가는경우
			for(i=0; i<position; i++){
				preNode = tempNode;
				tempNode = tempNode.next;
				
			}
			newNode.next = preNode.next;
			preNode.next = newNode;
		}
		count++;
		return newNode;
	}
	
	public MyListNode removeElement(int position) //위치로 삭제
	{
		int i;
		MyListNode tempNode = head;
		MyListNode preNode = null;
		
		if(position >= count ){
			System.out.println("삭제 할 위치 오류입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 앞을 삭제하면 다음요소가 헤드가된다.
			head = tempNode.next;
		}
		else{ //중간에서 뺴는경우
			MyListNode preNode = null;	
			for(i=0; i<position; i++){ 
				preNode = tempNode;
				tempNode = tempNode.next; //for문돌리면 tempNode가 내가 지우는 노드가 된다.
			}
			preNode.next = tempNode.next;
		}
		count--;
		System.out.println(position + "번째 항목 삭제되었습니다.");
		
		return tempNode;
	}
	
	public String getElement(int position)
	{
		int i;
		MyListNode tempNode = head;
		
		if(position >= count ){
			System.out.println("검색 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return new String("error");
		}
		
		if(position == 0){  //맨 인 경우

			return head.getData();
		}
		
		for(i=0; i<position; i++){
			tempNode = tempNode.next;
			
		}
		return tempNode.getData();
	}

	public MyListNode getNode(int position)
	{
		int i;
		MyListNode tempNode = head;
		
		if(position >= count ){
			System.out.println("검색 위치 오류 입니다. 현재 리스트의 개수는 " + count +"개 입니다.");
			return null;
		}
		
		if(position == 0){  //맨 인 경우

			return head;
		}
		
		for(i=0; i<position; i++){
			tempNode = tempNode.next;
			
		}
		return tempNode;
	}

	public void removeAll()
	{
		head = null;
		count = 0;
		
	}
	
	public int getSize()
	{
		return count;
	}
	
	public void printAll()
	{
		if(count == 0){
			System.out.println("출력할 내용이 없습니다.");
			return;
		}
		
		MyListNode temp = head;
		while(temp != null){
			System.out.print(temp.getData());
			temp = temp.next;
			if(temp!=null){
				System.out.print("->");
			}
		}
		System.out.println("");
	}
	
	public boolean isEmpty()
	{
		if(head == null) return true;
		else return false;
	}
	
}
--------------
package ch05;

import ch03.MyLinkedList;
import ch03.MyListNode;

interface IQueue{
	public void enQueue(String data);
	public String deQueue();
	public void printAll();
}

public class MyListQueue extends MyLinkedList implements IQueue{

	MyListNode front;
	MyListNode rear;
		
	
	public MyListQueue()
	{
		front = null;
		rear = null;
	}
	
	public void enQueue(String data)
	{
		MyListNode newNode;
		if(isEmpty())  //처음 항목
		{
			newNode = addElement(data); //맨뒤로 add되니까
			front = newNode;
			rear = newNode;
		}
		else
		{
			newNode = addElement(data);
			rear = newNode;
		}
		System.out.println(newNode.getData() + " added");
	}
	
	public String deQueue()
	{
		if(isEmpty()){
			System.out.println("Queue is Empty");
			return null;
		}
		String data = front.getData(); //맨앞에서 지워야하니까
		front = front.next; //front는 이제 front.next를 가리키면된다.
		if( front == null ){  // 근데 front가 null이면 마지막 항목이라는 소리이다.
			rear = null;
		}
		return data;
	}
	
	public void printAll()
	{
		if(isEmpty()){
			System.out.println("Queue is Empty");
			return;
		}
		MyListNode temp = front; //맨앞노드를 잠시 temp에 저장
		while(temp!= null){ 
			System.out.print(temp.getData() + ",");
			temp = temp.next; //front가 next를 가리키는 곳을 temp에 다시저장 ... 반복
		}
		System.out.println();
	}
}
------------------
package ch05;

public class MyListQueueTest {

	public static void main(String[] args) {

		MyListQueue listQueue = new MyListQueue();
		listQueue.enQueue("A");
		listQueue.enQueue("B");
		listQueue.enQueue("C");
		listQueue.enQueue("D");
		listQueue.enQueue("E");
		
		System.out.println(listQueue.deQueue());
		listQueue.printAll();
	}
}
=================================================================
//무엇이든 담을 수 있는 제레닉(일반화) 프로그래밍
여러 자료형이 쓰일 수 있는 변수일때 쓰인다. 자료형마다 클래스를 만들기에는 오버헤드라서...

package ch06;

public class Plastic {
	public String toString() {
		return "재료는 Plastic 입니다.";
	}
}
-----------
package ch06;

public class Powder {
	public String toString() {
		return "재료는 Powder 입니다.";
	}
}
-------------
package ch06; //제네릭 타입을 안쓰면 이렇게 powder,material 자료형마다 클래스를 만들어줘야한다

public class ThreeDPrinter1 {
	private Powder material;
		
	public Powder getMaterial() {
		return material;
	}

	public void setMaterial(Powder material) {
		this.material = material;
	}

}
---------------
package ch06;

public class ThreeDPrinter2 {
	private Plastic material;
		
	public Plastic getMaterial() {
		return material;
	}

	public void setMaterial(Plastic material) {
		this.material = material;
	}

}
----------------
package ch06; 

public class ThreeDPrinter3 {
	private Object material; //우리는 제네릭을 쓰지않으면 이렇게 Object를 써야한다.(변수타입을 다 받기위해서)
		
	public Object getMaterial() {
		return material;
	}

	public void setMaterial(Object material) {
		this.material = material;
	}

}
------------------
package ch06;

public class ThreeDPrinterTest {
	public static void main(String[] args) {
		Powder powder = new Powder();
		ThreeDPrinter3 printer = new ThreeDPrinter3();
		
		printer.setMaterial(powder); //object로 받는다. printer는
		
		Powder p = (Powder)printer.getMaterial(); //이렇게 오브젝트로 쓰면 다운캐스팅을 해줘야한다. 이게 번거러우니 제네릭타입이 나온것이다.
	}
}
=====================================================================================
package ch06;

public class GenericPrinter<T> {
	private T material;
	
	public void setMaterial(T material) {
		this.material = material;
	}
	
	public T getMaterial() {
		return material;
	}
	
	public String toString(){
		return material.toString();
	}
}
--------------------
package ch06;

public class GenericPrinterTest {

	public static void main(String[] args) {

		//Powder powder = new Powder();
		GenericPrinter<Powder> powderPrinter = new GenericPrinter<Powder>(); //GenericPrinter에서 <T>,T가 알아서 powder로 바뀐다.
		//GenericPrinter<Powder> powderPrinter = new GenericPrinter<>(); <powder>생략가능하다. 
		powderPrinter.setMaterial(new Powder());
		System.out.println(powderPrinter);
		Powder p = powderPrinter.getMaterial(); //다운캐스팅안해도 된다.
		
		GenericPrinter<Plastic> plasticPrinter = new GenericPrinter<Plastic>();
		plasticPrinter.setMaterial(new Plastic());
		System.out.println(plasticPrinter);
		
	}

}
==================================================================================================
//하지만, 제네릭을 쓰면 객체와 관계없는 것까지 타입으로 받을 수 있기때문에 문제가된다. 
//그래서 <T extends 클래스> 를 사용한다
//T자료형의 범위를 제한 할 수 있다.
//상속을 받지 않는 경우 T는 Object로 변환되어 Object클래스가 기본으로 제공하는 메소드만 사용가능

T에 무작위 클래스가 들어갈 수 없게 Material 클래스를 상속받은 클래스로 한정
			Material
		   /       \
		Powder    Plastic

=================================================================
package ch07;

public abstract class Material {
	
	public abstract void doPrinting(); //공통
}
-------------
package ch07;

public class Plastic extends Material{
	@Override
	public void doPrinting() {
		System.out.println("Plastic 재료로 출력합니다");
	}
	
	public String toString() {
		return "재료는 Plastic 입니다";
	}
}
-----------------
package ch07;

public class Powder extends Material{
	@Override
	public void doPrinting() {
		System.out.println("Powder 재료로 출력합니다");
	}
	
	public String toString() {
		return "재료는 Powder 입니다";
	}
}
------------------
package ch07;

public class GenericPrinter<T extends Material> { //Material을 상속받은 아이만 가능
	private T material;
	
	public void setMaterial(T material) {
		this.material = material;
	}
	
	public T getMaterial() {
		return material;
	}
	
	public String toString(){
		return material.toString();
	}
	
	public void printing() {
		material.doPrinting();
	}
}
-----------------------
package ch07;

public class GenericPrinterTest {

	public static void main(String[] args) {
		
		//Powder, Plastic은 Material을 상속받았기 때문에 GenericPrinter를 Class 생성가능
		GenericPrinter<Powder> powderPrinter = new GenericPrinter<Powder>();
		powderPrinter.setMaterial(new Powder());
		Powder powder = powderPrinter.getMaterial(); // 형변환 하지 않음
		System.out.println(powderPrinter);
		
		GenericPrinter<Plastic> plasticPrinter = new GenericPrinter<Plastic>();
		plasticPrinter.setMaterial(new Plastic());
		Plastic plastic = plasticPrinter.getMaterial(); // 형변환 하지 않음
		System.out.println(plasticPrinter);
		
	/*	GenericPrinter powderPrinter2 = new GenericPrinter(); //자료형을 안쓸수도있다.
		powderPrinter2.setMaterial(new Powder());
		Powder powder = (Powder)powderPrinter.getMaterial();
		System.out.println(powderPrinter);
		*/
		//GenericPrinter<Water> printer = new GenericPrinter<Water>();	이렇게쓸수는없다. 자식이 아니라서(extends의 장점)
	}
}
------------------------
package ch07;

public class GenericPrinterTest2 {

	public static void main(String[] args) {

		GenericPrinter<Powder> powderPrinter = new GenericPrinter<Powder>();
		powderPrinter.setMaterial(new Powder());
		powderPrinter.printing();
		
		GenericPrinter<Plastic> plasticPrinter = new GenericPrinter<Plastic>();
		plasticPrinter.setMaterial(new Plastic());
		plasticPrinter.printing();
	}
}
============================================================
//제네릭 메서드
//너비구하기
package ch08;

public class Point<T, V> { //Integer, double일수있으니
	
	T x;
	V y;
	
	Point(T x, V y){
		this.x = x;
		this.y = y;
	}
	
	public  T getX() {
			return x;
	}

	public V getY() {
		return y;
    }
}
----------------
package ch08;

public class GenericMethod {

	public static <T, V> double makeRectangle(Point<T, V> p1, Point<T, V> p2) {
		double left = ((Number)p1.getX()).doubleValue();
		double right =((Number)p2.getX()).doubleValue();
		double top = ((Number)p1.getY()).doubleValue();
		double bottom = ((Number)p2.getY()).doubleValue();
		
		double width = right - left; //거리 
		double height = bottom - top; //거리
		
		return width * height; //double로 반환
	}
	
	public static void main(String[] args) {
		
		Point<Integer, Double> p1 = new Point<Integer, Double>(0, 0.0); //한점
		Point<Integer, Double> p2 = new Point<>(10, 10.0); //자료형 생략가능 <>
		
		//static이라 클래스로 접근(굳이 함수를 static으로 선언할 필요는없다)
		double rect = GenericMethod.<Integer, Double>makeRectangle(p1, p2);
		System.out.println("두 점으로 만들어진 사각형의 넓이는 " + rect + "입니다.");
	}
}
//출력결과 : 100.0
===============================================================
//자바에서 제공되는 자료구조 구현 클래스들 - 컬렉션 프레임 워크
//java.util 패키지에 구현되어있다.

//Collection인터페이스 하위에 List, Set 인터페이스(중복허용x)가 있다.

package ch10;

public class Member {
	
	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}
}
------------------
package ch10;

import java.util.ArrayList;  // 사용할 클래스 import
import java.util.Iterator;

public class MemberArrayList {

	private ArrayList<Member> arrayList;  // ArrayList 선언 

	public MemberArrayList(){
		arrayList = new ArrayList<Member>();  //멤버로 선언한 ArrayList 생성
	}
	
	public void addMember(Member member){  //ArrayList 에 멤버 추가
		arrayList.add(member);
	}
	
	public boolean removeMember(int memberId){  // 멤버 아이디를 매개변수로, 삭제 여부를 반환
		
		//Iterator안하면 이렇게해야된다.
	/*	for(int i =0; i<arrayList.size(); i++){ // 해당 아이디를 가진 멤버를 ArrayList에서 찾음
			Member member = arrayList.get(i); //하나씩 꺼낸다.
			int tempId = member.getMemberId();
			if(tempId == memberId){            // 멤버아이디가 매개변수와 일치하면 
				arrayList.remove(i);           // 해당 멤버를 삭제
				return true;                   // true 반환
			}
		}
		*/
		
		Iterator<Member> ir = arrayList.iterator(); //<Member>라고안하면 알아서 Object로 된다
		while(ir.hasNext()) {
			Member member = ir.next();  //다음꺼를 반환후 그자리에 이동
			int tempId = member.getMemberId();
			if(tempId == memberId){            // 멤버아이디가 매개변수와 일치하면 
				arrayList.remove(member);           // 해당 멤버를 삭제
				return true;                   // true 반환
			}
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");  //for 가 끝날때 까지 return 이 안된경우
		return false;                   
	}
	
	public void showAllMember(){
		for(Member member : arrayList){
			System.out.println(member);
		}
		System.out.println();
	}
}
-------------------
package ch10;

public class MemberArrayListTest {

	public static void main(String[] args) {

		MemberArrayList memberArrayList = new MemberArrayList();
		
		Member memberLee = new Member(1001, "이순신");
		Member memberKim = new Member(1002, "김유신");
		Member memberKang = new Member(1003, "강감찬");
		Member memberHong = new Member(1004, "홍길동");
		
		memberArrayList.addMember(memberLee);
		memberArrayList.addMember(memberKim);
		memberArrayList.addMember(memberKang);
		memberArrayList.addMember(memberHong);
		
		memberArrayList.showAllMember();
		
		memberArrayList.removeMember(memberHong.getMemberId()); //한명지우기
		memberArrayList.showAllMember();
	}
}
==================================================================
//Collection요소를 순회하는 Iterator
순서가있는 List인터페이스는 Iterator를 사용하지않고 get(i)를 사용, Iterator써도됨
Set경우에는 get이 없으므로 Iterator를 쓴다.
===================================================================
//중복되지 않게 자료를 관리하는 Set 인터페이스를 구현한 클래스와 그 활용
HashSet 클래스
- Set인터페이스를 구현한 클래스
- 멤버의 중복여부를 체크하기 위해 인스턴스의 동일성을 확인해야함.
- .add될때 equals, hashCode 를 확인한다.

package ch12;

import java.util.HashSet;

public class HashSetTest {

	public static void main(String[] args) {

		HashSet<String> hashSet = new HashSet<String>();
		hashSet.add(new String("김유신"));
		hashSet.add(new String("이순신"));
		hashSet.add(new String("홍연의"));
		hashSet.add(new String("강감찬"));
		hashSet.add(new String("강감찬"));
		
		System.out.println(hashSet); //중복은 한번만출력
	}
}
=====================================================================

package ch12;

public class Member {
	
	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}

	@Override
	public int hashCode() {
		return memberId;
	}

	@Override
	public boolean equals(Object obj) {
		if( obj instanceof Member){
			Member member = (Member)obj;
			if( this.memberId == member.memberId )
				return true;
			else 
				return false;
		}
		return false;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}
}
---------------
package ch12;

import java.util.HashSet;
import java.util.Iterator;


public class MemberHashSet {
	private HashSet<Member> hashSet;

	public MemberHashSet(){
		hashSet = new HashSet<Member>();
	}
	
	public void addMember(Member member){
		hashSet.add(member);
	}
	
	public boolean removeMember(int memberId){

		Iterator<Member> ir = hashSet.iterator();
		
		while( ir.hasNext()){
			Member member = ir.next();
			int tempId = member.getMemberId();
			if( tempId == memberId){
				hashSet.remove(member);
				return true;
			}
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");
		return false;
	}
	
	public void showAllMember(){
		for(Member member : hashSet){
			System.out.println(member);
		}
		System.out.println();
	}
}
-------------------
package ch12;

public class MemberHashSetTest {

	public static void main(String[] args) {

		MemberHashSet memberHashSet = new MemberHashSet();
		
		Member memberLee = new Member(1001, "이순신");
		Member memberKim = new Member(1002, "김유신");
		Member memberKang = new Member(1003, "강감찬");
		
		
		memberHashSet.addMember(memberLee);
		memberHashSet.addMember(memberKim);
		memberHashSet.addMember(memberKang);
		memberHashSet.showAllMember();
		
		Member memberHong = new Member(1003, "홍길동");  //1003 아이디 중복(equals, hashcode안쓰면 그냥 들어간다) 
		memberHashSet.addMember(memberHong);
		memberHashSet.showAllMember();
	}
}
===========================================================================
//객체의 정렬에 사용하는 클래스 TreeSet
//Set인터페이스를 구현하여 중복을 허용하지않고, 오름차순이나 내림차순으로 객체를 정렬할수있다.
//내부적으로 이진검색트리로 구현된다.
package ch13;

import java.util.TreeSet;

public class TreeSetTest {

	public static void main(String[] args) {

		TreeSet<String> treeSet = new TreeSet<String>();
		treeSet.add("홍길동");
		treeSet.add("강감찬");
		treeSet.add("이순신");
		
		for(String str : treeSet) {
			System.out.println(str); //정렬된다.강감찬, 이순신, 홍길동 TreeSet에서 구현한 Comparable에서 String비교할수있게해놓아서
		}
	}
}
=============================================================================

package ch13;

public class Member implements Comparable<Member>{ //인터페이스추가 -> 구현해야하는 메서드가 compareTo

	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}

	@Override
	public int hashCode() {
		return memberId;
	}

	@Override
	public boolean equals(Object obj) {
		if( obj instanceof Member){
			Member member = (Member)obj;
			if( this.memberId == member.memberId )
				return true;
			else 
				return false;
		}
		return false;
	}

	@Override
	public int compareTo(Member member) {
		
		//return (this.memberId - member.memberId);   //오름차순
		return (this.memberId - member.memberId) *  (-1);   //내림 차순
		
		//left는 더 작은값, right는 더 큰값으로 해서 오름차순으로 출력
		//if(this.memberId > member.memberId)
		//	return 1;
		//else if(this.memberId < member.memberId)
		//	return -1;
		//else 
		//	return 0;
	}
}
--------------
package ch13;

import java.util.Iterator;
import java.util.TreeSet;



public class MemberTreeSet {

	private TreeSet<Member> treeSet;

	public MemberTreeSet(){
		treeSet = new TreeSet<Member>();
	}
	
	public void addMember(Member member){
		treeSet.add(member);
	}
	
	public boolean removeMember(int memberId){
		
		Iterator<Member> ir = treeSet.iterator();
		
		while( ir.hasNext()){
			Member member = ir.next();
			int tempId = member.getMemberId();
			if( tempId == memberId){
				treeSet.remove(member);
				return true;
			}
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");
		return false;
	}
	
	public void showAllMember(){
		for(Member member : treeSet){
			System.out.println(member);
		}
		System.out.println();
	}
}
--------------------
package ch13;

public class MemberTreeSetTest {

	public static void main(String[] args) {
		
		
		MemberTreeSet memberTreeSet = new MemberTreeSet();
		
		
		Member memberKim = new Member(1003, "김유신");
		Member memberLee = new Member(1001, "이순신");
		Member memberKang = new Member(1002, "강감찬");
		
		
		memberTreeSet.addMember(memberKim); //add할때마다 비교할수없기때문에 에러가난다. Comparable(compareTo), compartor(comapre)둘중에 하나를 구현해야한다
		memberTreeSet.addMember(memberLee);
		memberTreeSet.addMember(memberKang);
		memberTreeSet.showAllMember();
		
	}
}
=========================================================================
//Comparator로 구현
package ch13;

public class Member implements Comparator<Member>{ //인터페이스추가 -> 구현해야하는 메서드가 compareTo

	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member() {}

	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}

	@Override
	public int hashCode() {
		return memberId;
	}

	@Override
	public boolean equals(Object obj) {
		if( obj instanceof Member){
			Member member = (Member)obj;
			if( this.memberId == member.memberId )
				return true;
			else 
				return false;
		}
		return false;
	}

	@Override 
	public int compare(Member member1, Member member2) { //인자2개
		return (member1.memberId - member2.memberId); //앞이 크면 양수니까 오름차순으로 정렬
	}
}
--------------
package ch13;

import java.util.Iterator;
import java.util.TreeSet;



public class MemberTreeSet {

	private TreeSet<Member> treeSet;

	public MemberTreeSet(){
		treeSet = new TreeSet<Member>(new Member()); //comparator를 쓸때는 comapre가 구현된 클래스를 지정해줘야한다. new Member()이렇게하면 기본생성자도 만들어줘야한다
	}
	
	public void addMember(Member member){
		treeSet.add(member);
	}
	
	public boolean removeMember(int memberId){
		
		Iterator<Member> ir = treeSet.iterator();
		
		while( ir.hasNext()){
			Member member = ir.next();
			int tempId = member.getMemberId();
			if( tempId == memberId){
				treeSet.remove(member);
				return true;
			}
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");
		return false;
	}
	
	public void showAllMember(){
		for(Member member : treeSet){
			System.out.println(member);
		}
		System.out.println();
	}
}
--------------------
package ch13;

public class MemberTreeSetTest {

	public static void main(String[] args) {
		
		
		MemberTreeSet memberTreeSet = new MemberTreeSet();
		
		
		Member memberKim = new Member(1003, "김유신");
		Member memberLee = new Member(1001, "이순신");
		Member memberKang = new Member(1002, "강감찬");
		
		
		memberTreeSet.addMember(memberKim); //add할때마다 비교할수없기때문에 에러가난다. Comparable, compareTo둘중에 하나를 구현해야한다
		memberTreeSet.addMember(memberLee);
		memberTreeSet.addMember(memberKang);
		memberTreeSet.showAllMember();
		
	}
}
=================================================================
//Comparator은 임 Comparable에서 구현되어있는걸 다시 정의하고싶을 떄 쓴다.
//이미 Comparable에서 String이 오름차순으로 구현되어있는데 나는 String을 내림차순으로 구현하고 싶으면 Comparator를 통해 가능
package ch13;

import java.util.Comparator;
import java.util.Set;
import java.util.TreeSet;

class MyCompare implements Comparator<String>{

	@Override
	public int compare(String s1, String s2) {
		return (s1.compareTo(s2)) *-1 ; //내림차순, 원래 앞이 크면 양수이다.
	}
}

public class ComparatorTest {
	
	public static void main(String[] args) {
		
		Set<String> set = new TreeSet<String>(new MyCompare()); //비교하는 방식을 새로만듬
		set.add("aaa");
		set.add("ccc");
		set.add("bbb");
				
		System.out.println(set); //ccc bbb aaa
	}
}
================================================================
//comapartor로 memberName으로 정렬
package ch13;

import java.util.Comparator;

public class Member implements Comparator<Member>{

	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member() {}
	
	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}

	@Override
	public int hashCode() {
		return memberId;
	}

	@Override
	public boolean equals(Object obj) {
		if( obj instanceof Member){
			Member member = (Member)obj;
			if( this.memberId == member.memberId )
				return true;
			else 
				return false;
		}
		return false;
	}

//	@Override
//	public int compareTo(Member member) {
//		
//		//return (this.memberId - member.memberId);   //오름차순
//		return (this.memberId - member.memberId) *  (-1);   //내림 차순
//	}

	@Override
	public int compare(Member arg0, Member arg1) {
		return (arg0.memberName.compareTo(arg1.memberName)) *-1 ; //내림차순, 원래 앞이 크면 양수이다.
	}
}
--------------
package ch13;

import java.util.Iterator;
import java.util.TreeSet;



public class MemberTreeSet {

	private TreeSet<Member> treeSet;

	public MemberTreeSet(){
		treeSet = new TreeSet<Member>(new Member());
	}
	
	public void addMember(Member member){
		treeSet.add(member);
	}
	
	public boolean removeMember(int memberId){
		
		Iterator<Member> ir = treeSet.iterator();
		
		while( ir.hasNext()){
			Member member = ir.next();
			int tempId = member.getMemberId();
			if( tempId == memberId){
				treeSet.remove(member);
				return true;
			}
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");
		return false;
	}
	
	public void showAllMember(){
		for(Member member : treeSet){
			System.out.println(member);
		}
		System.out.println();
	}
}
-----------------
package ch13;

public class MemberTreeSetTest {

	public static void main(String[] args) {

		MemberTreeSet memberTreeSet = new MemberTreeSet(); //맵트리셋
		
		
		Member memberKim = new Member(1003, "김유신");
		Member memberLee = new Member(1001, "이순신");
		Member memberKang = new Member(1002, "강감찬");
		
		
		memberTreeSet.addMember(memberKim);
		memberTreeSet.addMember(memberLee);
		memberTreeSet.addMember(memberKang);
		memberTreeSet.showAllMember();
		
	}
}
====================================================================
//쌍으로 자료를 관리하는 Map인터페이스를 구현한 클래스와 그 활용
HashMap 클래스
package ch14;

public class Member {
	
	private int memberId;        //회원 아이디
	private String memberName;   //회원 이름

	public Member(int memberId, String memberName){ //생성자
		this.memberId = memberId;
		this.memberName = memberName;
	}
	
	public int getMemberId() {  //
		return memberId;
	}
	public void setMemberId(int memberId) {
		this.memberId = memberId;
	}
	public String getMemberName() {
		return memberName;
	}
	public void setMemberName(String memberName) {
		this.memberName = memberName;
	}

	@Override
	public int hashCode() {
		return memberId;
	}

	@Override
	public boolean equals(Object obj) {
		if( obj instanceof Member){
			Member member = (Member)obj;
			if( this.memberId == member.memberId )
				return true;
			else 
				return false;
		}
		return false;
	}
	
	@Override
	public String toString(){   //toString 메소드 오버로딩
		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
	}
}
---------------------
package ch14;

import java.util.HashMap;
import java.util.Iterator;


public class MemberHashMap {

	private HashMap<Integer, Member> hashMap;
	
	public MemberHashMap()
	{
		hashMap = new HashMap<Integer, Member>();
	}
	
	public void addMember(Member member){
		
		hashMap.put(member.getMemberId(), member); //key, value로 넣기
		
	}
	
	public boolean removeMember(int memberId){
		
		if(hashMap.containsKey(memberId)){ //containsKey, containsValue는 반환값이 boolean이다.
			hashMap.remove(memberId);
			return true;
		}
		
		System.out.println(memberId + "가 존재하지 않습니다");
		return false;
	}
	
	public void showAllMember(){
		Iterator<Integer> ir = hashMap.keySet().iterator(); //map자체에는 Iterator가 없으므로 key 또는 value에서 가져와야함
		while (ir.hasNext()){
			int key = ir.next();
			Member member = hashMap.get(key); //value가 반환된다.
			System.out.println(member);
		}	
		System.out.println();
	}
}
--------------------
package ch14;

import java.util.HashMap;

public class MemberHashMapTest {

	public static void main(String[] args) {

		MemberHashMap memberHashMap = new MemberHashMap();
		
		
		Member memberLee = new Member(1001, "이순신");
		Member memberKim = new Member(1002, "김유신");
		Member memberKang = new Member(1003, "강감찬");
		Member memberHong = new Member(1004, "홍길동");
		
		memberHashMap.addMember(memberLee);
		memberHashMap.addMember(memberKim);
		memberHashMap.addMember(memberKang);
		memberHashMap.addMember(memberHong);
		
		memberHashMap.showAllMember();
		
		memberHashMap.removeMember(1004);
		memberHashMap.showAllMember();
		
		HashMap<Integer,String> hashMap = new HashMap<Integer, String>();
		hashMap.put(1001,"kim");
		System.out.println(hashMap); // {1001=kim} 이렇게 keyvalue형식으로 나온다.
	}
}
//여기서 key로 정렬하는게 TreeMap이다.
=================================================================
//내부클래스(중첩클래스)
//클래스안의 클래스 선언
//내부클래스 종류
1. 인스턴스 내부 클래스
- 내부에서 쓰니까 private, private가 아니면 외부에서 사용가능

package ch01;

class OutClass {

	private int num = 10;
	private static int sNum = 20;
	private InClass inClass;
	
	public OutClass(){ 
		inClass = new InClass(); // 아웃클래스 생성될때 내부 클래스 생성
	}
	
	private class InClass{ //중첩클래스
		
		int inNum = 100;
		//static int sInNum = 200;  //에러 난디. 아우터클래스가 먼저생성난 다음에 이너클래스가 생성되니까 
		
		void inTest(){
			System.out.println("OutClass num = " +num + "(외부 클래스의 인스턴스 변수)");
			System.out.println("OutClass sNum = " + sNum + "(외부 클래스의 스태틱 변수)");
			System.out.println("InClass inNum = " + inNum + "(내부 클래스의 인스턴스 변수)");
		}
		
	    //static void sTest(){  //에러 남
	    	
	    //}
		
	}
	
	public void usingClass(){
		inClass.inTest(); //내부 클래스 변수를 사용하여 메서드 호출하기(InClass 접근)
	}
	
	2. 정적내부클래스
	static class InStaticClass{
		
		int inNum = 100;
		static int sInNum = 200; //얘는 선언가능 정적클래스라서
		
		void inTest(){   //정적 클래스의 일반 메서드
			//num += 10;    // 외부 클래스의 인스턴스 변수는 사용할 수 없음.
			System.out.println("InStaticClass inNum = " + inNum + "(내부 클래스의 인스턴스 변수 사용)"); 
			System.out.println("InStaticClass sInNum = " + sInNum + "(내부 클래스의 스태틱 변수 사용)");
			System.out.println("OutClass sNum = " + sNum + "(외부 클래스의 스태틱 변수 사용)");
		}
		
		static void sTest(){  // 정적 클래스의 static 메서드
			//num += 10;   // 외부 클래스의 인스턴스 변수는 사용할 수 없음.
			//inNum += 10; // 내부 클래스의 인스턴스 변수는 사용할 수 없음
			
			System.out.println("OutClass sNum = " + sNum + "(외부 클래스의 스태틱 변수 사용)");
			System.out.println("InStaticClass sInNum = " + sInNum + "(내부 클래스의 스태틱 변수 사용)");
			
		}
	}	
}

public class InnerTest {

	public static void main(String[] args) {
		//정석방법 1
	/*	OutClass outClass = new OutClass();
		System.out.println("외부 클래스 이용하여 내부 클래스 기능 호출");
		outClass.usingClass();    // 내부 클래스 기능 호출
	    System.out.println();
	    
		//다른방법 1 (단, Inclass가 private이 아닌경우)
		OutClass.InClass inClass = outClass.new InClass();   // 외부 클래스를 이용하여 내부 클래스 생성
		System.out.println("외부 클래스 변수를 이용하여 내부 클래스 생성");
		inClass.inTest();
		
		System.out.println();
		*/
		//외부 클래스 생성하지 않고 바로 정적 내부 클래스 생성
		OutClass.InStaticClass sInClass = new OutClass.InStaticClass();  
		System.out.println("정적 내부 클래스 일반 메서드 호출");
		sInClass.inTest(); //일반메서드는 객체를 생성 후 호출
		System.out.println();
		
		System.out.println("정적 내부 클래스의 스태틱 메소드 호출");
		OutClass.InStaticClass.sTest(); //정적 메서드는 바로 호출가능
	}

}

====================================================================
3. 지역내부클래스(메서드 내부에 클래스 -> 이걸 이름을 없앤게 익명내부클래스)
package ch01;

class Outer{
	
	int outNum = 100;
	static int sNum = 200;
	
		
	Runnable getRunnable(final int i){ //Runnable한 타입을 반환해라.(메서드)
		//매개변수(i) , num도 스택메모리에 올라간다.
		int num = 100; //그냥 이렇게 선언해도 알아서 final이 붙음.(그래서 run메서드에서 출력가능하다. 스택에서 없어져도 상수영역에서 남기떄문에 run에서 출력가능한것이다)
		
		class MyRunnable implements Runnable{

			int localNum = 10;
				
			@Override
			public void run() {
				//num = 200;   //에러 남. 지역변수는 상수로 바뀜, 메서드(getRunnable)는 호출하고 끝나면 스택에서 사라진다. 근데 run이라는 메서드는 다시호출될수있는데 num,i가 없을수도있으니 final붙임 (상수화시킴 -> 스택에서 사라지지만 상수영역에서남음)
				//i = 100;     //에러 남. 매개 변수 역시 지역변수처럼 상수로 바뀜
				System.out.println("i =" + i); //그래서 가져오는건 문제가안됌
				System.out.println("num = " +num);  
				System.out.println("localNum = " +localNum);
					
				System.out.println("outNum = " + outNum + "(외부 클래스 인스턴스 변수)"); //Outer가 생성되고 Runnable 메서드가 실행되니 가능
				System.out.println("Outter.sNum = " + Outer.sNum + "(외부 클래스 정적 변수)");
				}
			}
		 return new MyRunnable();
	}
}

public class LocalInnerTest {

	public static void main(String[] args) {

		Outer out = new Outer();
		Runnable runner = out.getRunnable(10); //이렇게 runner를 주고 메서드는 끝나면 스택에 있는 것들은 사라진다.(호출이끝났으니까)
		runner.run(); //근데 여기서 호출이 되니까 값을 상수화시켜버린다, 예전에는 final을 강제적으로 븉여야됬지만 요즘은 알아서 컴파일러가 해준다.
	}
}
//근데 MyRunnable이라는 클래스이름을 굳이 줄필요가있을까? 쓰지도 않는데 -> 익명내부클래스 
===================================================================
4. 익명내부클래스
- 클래스의 이름을 생략하고 주로 하나의 인터페이스나 하나의 추상 클래스를 구현하여 반환
package ch01;

class Outter2{
		
		//방법 1
	Runnable getRunnable(int i){

		int num = 100;
		
		return new Runnable() { //클래스이름을 없앴다.
				
		@Override
		public void run() {
			//num = 200;   //에러 남
			//i = 10;      //에러 남
			System.out.println(i);
			System.out.println(num);
			}
		}; //implements의 끝이 여기다
	}
	
	//또 다른 방법(outter2의 인스턴스변수)
	Runnable runner = new Runnable() {  //runner를 통해접근가능
		
		@Override
		public void run() {
			System.out.println("Runnable 이 구현된 익명 클래스 변수");
			
		}
	};
}

public class AnonymousInnerTest {

	public static void main(String[] args) {
		Outter2 out = new Outter2();
	
		Runnable runnerble = out.getRunnable(10);
		runnerble.run();
		
		out.runner.run();
	}
}
=============================================================================
//람다식(자바8부터지원)
//일반 함수
int add(int x, int y) {
	return x+y;
}
//람다식으로 표현
(int x, int y) -> {return x+y;}

===============================================================================
package ch03;

//@FunctionalInterface 컴파일러한테 정보를 주는역할이다, 메서드를 두개이상 선언하면안된다.
public interface Add {

	public int add(int x, int y);
}
-----------
package ch03;

public class TestAdd {

	public static void main(String[] args) {

		Add addF = (x, y) -> x + y; //원래는 인터페이스를 받으면 클래스를 만들고 함수를 정의해야하는데. 람다식은 인터페이스만 선언하고 구현바로가능
		
		System.out.println(addF.add(3,5));
	}

}
===================================================================================
//함수형인터페이스
- 람다식을 선언하기위한 인터페이스
- 익명함수와 매개변수만으로 구현되므로 인터페이스는 단하나의 메서드만을 선언해야한다.
- @FunctionalInterface 는 함수형 인터페이스라는 의미. 내부에 여러개의 메서드를 선언하면 에러난다.

package ch03;

@FunctionalInterface
public interface MyNumber {
	
	int getMax(int num1, int num2);

}
-----------------
package ch03;

public class TestMyNumber {

	public static void main(String[] args) {
		MyNumber max = (x, y)->(x>= y)? x:y; // 람다식을 인터페이스 자료형 max 변수에 대입

		System.out.println(max.getMax(10, 20));// 인터페이스 자료형 변수로 함수 호출
			
	}
}
=================================================================================
//객체지향과 람다식 비교
//기존 객체지향 방식
package ch04;

public interface StringConcat {
	
	public void makeString(String s1, String s2);

}
-----------
package ch04;

public class StringConCatImpl implements StringConcat{

	@Override
	public void makeString(String s1, String s2) {
		System.out.println( s1 + "," + s2 );
	}
}
------------
package ch04;

public class TestStringConcat {

	public static void main(String[] args) {

		String s1 = "Hello";
		String s2 = "World";
		StringConCatImpl concat1 = new StringConCatImpl();
		concat1.makeString(s1, s2);
		int i = 100;
		
		//인터페이스로(람다식)
		//클래스를 만들지않아도 되지만 실제적으로는 익명클래스가 만들어진다.(아래)
		StringConcat concat2 = (s, v)->System.out.println(s + "," + v ); //System.out.println(i);
		concat2.makeString(s1, s2);
		i = 300;
		
		//아래처럼 이렇게 익명클래스가 만들어진다.
		StringConcat concat3 = new StringConcat() {
			
			@Override
			public void makeString(String s1, String s2) {
				
				System.out.println( s1 + "," + s2 );
			}
		};
		
		concat3.makeString(s1, s2);
		
	}

}
===========================위에부분은 객체지향 방식이다.
//여기는 람다식 방법
//TestLamda.java
package ch04;

interface PrintString{
	
	void showString(String str);
}

public class TestLambda {

	public static void main(String[] args) {

		PrintString lambdaStr = s->System.out.println(s);  //람다식을 변수에 대입
		lambdaStr.showString("hello lambda_1");
		
		showMyString(lambdaStr);                          //메서드 매개변수로 전달(static함수)
		
		PrintString reStr = returnString();  
		reStr.showString("hello ");
		
	}
	
	public static void showMyString(PrintString p) { //인터페이스 자료형을 매개변수로 받는다.
		p.showString("hello lambda_2");
	}
	
	public static PrintString returnString() {         //반환 값으로 사용(반환값은 인터페이스)
		return s->System.out.println(s + "world");
	}
}
========================================================================
//스트림
- 컬렉션이나 배열 등의 자료들이 모여있는데 이런 자료들의 연산(더하기, 뺴기, 평군 등)의 처리를 일관성있게 해준다. 즉, 배열이건 상관없이 동일한 방식으로 연산할 수 있도록해주는 것이 스트림이다.
- 자료의 대상과 관계없이 동일한 연산을 수행
- 배열, 컬렉션을 대상으로 연산을 수행한다.
- 한번생성하고 사용한 스트림은 재사용 할 수 없다.
- 스트림 연산은 기존 자료를 변경하지않는다.(정렬 등)

package ch05;

import java.util.Arrays;

public class IntArrayTest {

	public static void main(String[] args) {

		int[] arr = {1,2,3,4,5};
		
		int sumVal = Arrays.stream(arr).sum();
		long count = Arrays.stream(arr).count();
		
		System.out.println(sumVal);
		System.out.println(count);
	}

}
======================================================================
package ch05;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream

public class IntArrayStreamTest {

	public static void main(String[] args) {
		int[] arr = {1,2,3,4,5};
		Arrays.stream(arr).forEach(n->System.out.print(n + "\t"));
		System.out.println();
					
		int sum  = Arrays.stream(arr).sum();
		System.out.println("sum: " + sum);
		
		//스트림생성
		IntStream is = Arrays.stream(arr); //IntStream으로 반환한다.
		is.forEach(n->System.out.println(n));
		//여기서 또 is. 으로 못쓴다. 스트림은 한번만 연산가능(소모)
		
		//그래서 다시 스트림을 생성해야한다.
		//int sum = Arrays.stream(arr).sum();
		
		
		List<Integer> list = new ArrayList<Integer>();
		list.add(1);
		list.add(2);
		list.add(3);
		list.add(4);
		list.add(5);
		int sum2 = list.stream().mapToInt(n->n.intValue()).sum(); 
		System.out.println(sum2);
	}

}
=======================================================================
//스트림은 중간연산 최종연산으로 나뉜다.
// 중간연산의 예) filter(), map(), sorted() 등
// 최종연산의 예) forEach(), count(), sum() 등
// 최종연산이 호출될 때 중간 연산이 수행되고 결과가 생성된다.
// filter()는 중간연산이고, forEach()는 최종연산이다.
package ch05;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class ArrayListStreamTest {

	public static void main(String[] args) {
		List<String> sList = new ArrayList<String>();
		sList.add("Tomas");
		sList.add("Edward");
		sList.add("Jack");
		
		Stream<String> stream = sList.stream(); //스트림 생성
		stream.forEach(s->System.out.print(s + " "));
		System.out.println();
		
		//람다식은 익명클래스가 숨어있다.
		sList.stream().sorted().forEach(s->System.out.print(s+ " ")); //기존의 자료는 바뀌지않는다.
		sList.stream().map(s->s.length()).forEach(n->System.out.println(n)); //s가 가지고 있는 메서드를 호출할려면 map
		sList.stream().filter(s->s.length() >= 5).forEach(s->System.out.println(s));
		
	}

}
=============================================================================
#)reduce()  -> 최종연산으로 스트림의 요소를 소모하여 연산을 수행. 람다식을 직접구현하거나 람다식이 긴 경우 BinaryOperator를 구현한 클래스를 사용한다.
예시) 배열의 모든 요소의 합을 구하는 reduce()연산 구현
Arrays.stream(arr).reduce(0,(a,b)->a+b)); //arr은 배열이라고 가정


package ch06;

import java.util.Arrays;
import java.util.function.BinaryOperator;

public class ReduceTest {

	public static void main(String[] args) {

		String[] greetings = {"안녕하세요~~~", "hello", "Good morning", "반갑습니다^^"}; 
		
		System.out.println(Arrays.stream(greetings).reduce("", (s1, s2)->              //자료가 소모될때까지 진행
		                          {if (s1.getBytes().length >= s2.getBytes().length)  //getBytes를 하면 array가 반환이 되기떄문에 .length 가능하다.
				                                  return s1;  
		                          else return s2;}));   //출력하면 안녕하세요~~~ 가 출력된다. 한글은 2byte이고 영문은 1byte이니까
		                          
	}
}
//이 방법이 지저분하다면 아래처럼 이용

====================================================================================

package ch06;

import java.util.Arrays;
import java.util.function.BinaryOperator;

class CompareString implements BinaryOperator<String>{ //인터페이스니까 함수구현

	@Override
	public String apply(String s1, String s2) {  //두인자를 계속받는다.
		if (s1.getBytes().length >= s2.getBytes().length) return s1;
		else return s2;
	}
}

public class ReduceTest {

	public static void main(String[] args) {

		String[] greetings = {"안녕하세요~~~", "hello", "Good morning", "반갑습니다^^"}; 
		
		
		String str = Arrays.stream(greetings).reduce(new CompareString()).get(); //BinaryOperator를 구현한 클래스 이용, apply가 자동으로 작동된다.
		System.out.println(str); // 안녕하세요~~~ 출력된다.
		                          
	}
}
=================================================================================
//스트림을 이용한 패키지 여행비용계산하기
여행비용은 15세이상은 100만원 , 그 미만은 50만원
package ch07;

public class TravelCustomer {

	private String name;   //이름
	private int age;       //나이
	private int price;     //가격
	
	public TravelCustomer(String name, int age, int price) {
		this.name = name;
		this.age = age;
		this.price = price;
	}

	public String getName() {
		return name;
	}

	public int getAge() {
		return age;
	}

	public int getPrice() {
		return price;
	}
	
	public void setName(String name) {
		this.name = name;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public void setPrice(int price) {
		this.price = price;
	}

	public String toString() {
		return "name: " + name + "age: " + age + "price: " + price; 
	}

}
--------------------
package ch07;

import java.util.ArrayList;
import java.util.List;

public class TravelTest {

	public static void main(String[] args) {
		TravelCustomer customerLee = new TravelCustomer("이순신", 40, 100);
		TravelCustomer customerKim = new TravelCustomer("김유신", 20, 100);
		TravelCustomer customerHong = new TravelCustomer("홍길동", 13, 50);
		
		List<TravelCustomer> customerList = new ArrayList<>(); //<>안에 생략해도됌.
		customerList.add(customerLee);
		customerList.add(customerKim);
		customerList.add(customerHong);
		
		System.out.println("== 고객 명단 추가된 순서대로 출력 ==");
		customerList.stream().forEach(s->System.out.println(s)); // toString이 출력된다.(s)객체를 출력해라. 
		customerList.stream().map(c->c.getName()).forEach(s->System.out.println(s)); // 이름만 출력된다. map이 중간연산, forEach가 최종연산이된다.
		
		int total = customerList.stream().mapToInt(c->c.getPrice()).sum();
		System.out.println("총 여행 비용은 :" + total + "입니다");
		
		System.out.println("== 20세 이상 고객 명단 정렬하여 출력 =="); //20명이상은 mapping해서 다시 sorted(기본 오름차순)해서 출력
		customerList.stream().filter(c->c.getAge() >= 20).map(c->c.getName()).sorted().forEach(s->System.out.println(s)); //최종연산은 한번만 사용된다.
		//출력 
		//김유신
		//이순신
	}

}
=============================================================================================
#)예외처리하는 이유 -> 서비스가 죽지않기하기 위해서 (비정상종료 방지, 로그남겨서 그 상황이 무엇인지 버그를 알기위해)

  throwable   (ERROR , Exception은 throwable에서 상속받았다)
   |    |
ERROR Exception(하위에 있는 Exception들이 엄청많다)

#)이렇게 try를 해야 서비스 중지를 막을 수 있다.
try {
	예외가 발생할수있는 부분
}catch(처리할 예외 타입 e) {
	try 블록안에서 예외가 발생했을 떄 예외를 처리하는 부분(대부분 로그를 남긴다)
}
================================================================
package ch08;

public class ArrayExceptionHandling {

	public static void main(String[] args) {
		int[] arr = {1,2,3,4,5};
		try{
			for(int i=0; i<=5; i++){      //배열범위 예외
				System.out.println(arr[i]);
			}
		}catch(ArrayIndexOutOfBoundsException e){   //콘솔에 빨갛게 글자가 뜨는게 아니라 검은색으로 글자가 나온다.
			System.out.println(e);  //Index 5 out of bounds for length 5
			System.out.println(e.getMessage());   //java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length
		}
		System.out.println("비정상 종료되지 않았습니다.");
	}
}
================================================================
//try-catch-finally 문 (소켓같은 close해줘야될때) finally는 catch에 return이 있어도 호출이된다.


//잘못된 예시 (finally를 안쓸때)
try {
	fis = new FileInputStream("a.txt");
	System.out.println("read");
	
	try {
		fis.close();
	}catch(IOException e) {
		e.printStackTrace();
	}
}catch (FileNotFoundException e) {
	System.out.println(e);
	try {
		fis.close();
	}catch(IOException e1) {
		e1.printStackTrace();
	}
	System.out.println("end");
}
=========================================================================

package ch09;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileExceptionHandling {

	public static void main(String[] args) {
		FileInputStream fis = null;
		try {
			fis = new FileInputStream("a.txt"); //파일을 읽어들인다(가장먼저 찾는 path는 프로젝트 폴더 바로 밑이다)
		} catch (FileNotFoundException e) {
			System.out.println(e);
			//return; //return을 해도 finally는 불린다.
		}finally{ //finally를 안쓰면 catch구간마다 close를 해줘야하니까 
			if(fis != null){ //열려있을 떄 close해야함
				try {
					fis.close();
				} catch (IOException e) { //IOException은 close할떄 나는 예외이다.
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			System.out.println("항상 수행 됩니다.");
		}
		System.out.println("여기도 수행됩니다.");
	}
}
//근데 이거는 코드가 더럽다 -> 자바 7부터 try-with-resources가 있는데 자동으로 자원을 해제시켜준다.
============================================================
//이 처럼쓰면 알아서 close가 된다. (try안에 쓰면)
//FileInputStream이 autoCloseable을 implements를 하고있는데 이거는 예외가 났던간에 끝나면 close메소드가 자동으로 호출되도록 하는 인터페이스이다.
public class FileExceptionHandling {
	public static void main(String[] args) {
	try(FileInputStream fis = new FileInputStream("a.txt")) {
		System.out.println("read") //에러나면 여기는 실행안한다.
	} catch(FileNotFoundException e) {
		e.printStackTrace();
	} catch(IOException e) {
		e.printStackTrace();
	}
	System.out.println("end"); //예외가 나도 실행
	}
}

===================================================================
//AutoCloseable 실습

package ch09;

public class AutoCloseObj implements AutoCloseable{

	@Override //AutoCloseable에 있는 close를 오버라이딩
	public void close() throws Exception {
		System.out.println("리소스가 close() 되었습니다");   //예외든 아니든(try가 실행되면 close가 호출된다 -> autoCloseable을 implements한 obj를 썼으니)
	}
}
-------------------
package ch09;

public class AutoCloseTest {
	
	public static void main(String[] args) {
		
		AutoCloseObj obj = new AutoCloseObj();
    	try (obj){
			throw new Exception(); //강제로 예외만들기
		}catch(Exception e) { //모든 예외처리
			System.out.println("예외 부분 입니다");
		}
	}
}
===================================================================
package ch09;

import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class ThrowsException {

	public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException{ //여기서는 catch를 안쓰고 throws를 써보자(예외처리를 미루겠다) -> 어디로미루냐? -> loadClass라는 메소드를 호출하는 쪽에서 처리해라
		FileInputStream fis = new FileInputStream(fileName); //FileNotFoundException 발생(fileName를 연다) -> throws로 던지고
		Class c = Class.forName(className);  //ClassNotFoundException 발생
		return c;
	}

	public static void main(String[] args) {

		ThrowsException test = new ThrowsException();
		
		try {
			test.loadClass("a.txt", "java.lang.String"); //loadClass메서드를 호출 -> 예외처리 , java.lang.Sttring이라는 클래스를 로드해라
		
		}catch (FileNotFoundException e) {
			e.printStackTrace(); //로그남기기
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}catch (Exception e) {  //애를 맨위에 쓰면안된다.(업캐스팅되니까 여기오면)
			e.printStackTrace();
		}
	}
}
================================================================
//multi-exception(한번에 처리 '|' 기호를 통해서)
package ch09;

import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class ThrowsException2 {

	public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException{ //예외를 던지겠다
		FileInputStream fis = new FileInputStream(fileName); //FileNotFoundException 발생
		Class c = Class.forName(className);  //ClassNotFoundException 발생
		return c;
	}

	public static void main(String[] args) {

		ThrowsException2 test = new ThrowsException2();

		try {
			test.loadClass("a.txt", "java.lang.String");
		} catch (FileNotFoundException | ClassNotFoundException e) { //둘중에 하나의 예외가 발생하면
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
=====================================================================
제네릭 타입
<? extends Object> == <?> 같은의미이다. 어떤 자료형의 객체도 매개변수로 받겠다는 의미이다.

public class WildTest {

    public static void main(String[] args) {
        // List는 인터페이스이기 때문에 ArrayList 생성 후 Upcasting 이용
        List<String> list = new ArrayList();
        list.add("test1");
        list.add("test2");
        list.add("test3");

        // Integer 자료형 list2 객체 생성
        List<Integer> list2 = new ArrayList();
        list2.add(1);
        list2.add(2);
        list2.add(new Integer(3));

        // Double형 list3 생성
        List<Double> list3 = new ArrayList();
        list3.add(10.1);
        list3.add(11.2);
        list3.add(12.3);

        // static 메소드 호출
        printData(list);
        printData(list2);
        printData(list3);

        /*
        test1    test2    test3
        1        2        3
        10.1    11.2    12.3
        */

    }

    // 리스트 출력 메소드
    public static void printData(List<?> list) {
        for (Object v : list) { //Object로 받았음을 볼수가있다.
            System.out.println(v);
        }
    }
====================================================================
위에는 extends Object였다면 이번에는 extends 클래스이다.

class Test {
	String name;
}

class Person {
	String name;
}

//Person상속 Man 클래스
class Man extends Person {
	//생성자
	Man(String name) {
		this.name = name;
	}
	
	//name 반환 메소드
	public String toString() {
		return name.toString();
	}
}

// Person 상속 Woman 클래스
class Woman extends Person {
    Woman(String name) {
        this.name = name;
    }

    public String toString() {
        return name.toString();
    }
}

public class WildExtends {

    public static void main(String[] args) {

        // Person
        List<Person> listP = new ArrayList<Person>();
        listP.add(new Person());
        printData(listP);        // j200210.Person@15db9742

        // Man
        List<Man> listM = new ArrayList<Man>();
        listM.add(new Man("이순신"));
        listM.add(new Man("하현우"));
        listM.add(new Man("박효신"));
        printData(listM);    // 이순신    하현우    박효신

        // Woman
        List<Woman> listW = new ArrayList<Woman>();
        listW.add(new Woman("유관순"));
        listW.add(new Woman("백예린"));
        listW.add(new Woman("박정현"));
        printData(listW);    // 유관순    백예린    박정현

        // Test
        List<Test> listT = new ArrayList<Test>();
        listT.add(new Test());
//      printData(listT); → Person 클래스를 상속받지 않았기 때문에 메소드 호출 불가

    }

    // Person 클래스와 그 하위 클래스로 생성된 인스턴스만 매개변수로 전달 가능
    public static void printData(List<? extends Person> list) {
        for (Person obj : list) {
            System.out.println(obj);
        }
    }

}
=====================================================================
<? super 클래스>
매개변수의 자료형을 특정 클래스와 그 클래스의 상위 클래스로만 제한함

// Person 클래스
class Person {
    String name;

    // 기본 생성자
    Person() {
    }
	
    // 생성자 오버로딩
    Person(String name) {
        this.name = name;
    }

    public String toString() {
        return name;
    }
}

//Person상속 Man 클래스
class Man extends Person {
	//생성자
	Man(String name) {
		this.name = name;
	}
	
	//name 반환 메소드
	public String toString() {
		return name.toString();
	}
}

// Person 상속 Woman 클래스
class Woman extends Person {
    Woman(String name) {
        this.name = name;
    }

    public String toString() {
        return name.toString();
    }
}

public class WildSuper {

    public static void main(String[] args) {

        // Person
        List<Person> listP = new ArrayList<Person>();
        listP.add(new Person("사람"));
        listP.add(new Person("인간"));
        printData(listP); // 사람 인간

        // Man
        List<Man> listM = new ArrayList<Man>();
        listM.add(new Man("하현우"));
        listM.add(new Man("박효신"));
        printData(listM); // 하현우 박효신

        // Woman
        List<Woman> listW = new ArrayList<Woman>();
        listW.add(new Woman("백예린"));
        listW.add(new Woman("박정현"));
//      printData(listW); → Man 클래스의 상위 클래스가 아니기 때문에 메소드 호출 불가

    }

    // Man 클래스와 그 상위 클래스로 생성된 인스턴스만 매개변수로 전달 가능
    public static void printData(List<? super Man> list) {
        for (Object obj : list) {
            System.out.println(obj);
        }
    }
}

=====================================================================
//연결리스트
ArrayList(배열)에 비해서 추가나 삭제 용이하지만 인덱스가 없어서 특정요소에 접근하기 위해서는 순차적으로 접근이 필요 -> 탐색속도가 떨어진다.
그래서 탐색또는 정렬을 자주하는 경우엔 배열을 사용, 데이터의 추가,삭제가 많은 경우 연결리스트 사용한다.

ArrayList는 내부 배열에 객체를 저장해서 인덱스로 관리하는데 비해서 LinkedList는 위와 같이 인접 참조를 링크해서 체인처럼 관리합니다. 

예시) LinkedList<Studnet> members = new LinkedList<Student>();
     LinkedList<Integer> num = new LinkedList<Integer>();

<>안에 선언할수 있는게 제네릭스 타입인데 제네릭스는 선언할 수 있는 타입이 객체타입이다.
int는 기본자료형이기때문에 들어갈수없으므로 int를 객체화시킨 wrapper클래스를 사용해야한다. 그래서 Integer를 썻다

LinkedList<Integer> list = new LinkedList<Integer>();
list.addFirst(1); //가장 앞에 데이터추가
list.addLast(2); //가장 뒤에 데이터추가
list.add(3); //데이터 추가(인덱스 생략시 마지막에 추가)
list.add(1,10); // index 1에 데이터 10 추가

----------------------
//LinkedList 값 출력
LinkedList<Integer> list = new LinkedList<Integer>(Arrays.asList(1,2,3));

System.out.println(list.get(0));//0번째 index 출력
				
for(Integer i : list) { //for문을 통한 전체출력
    System.out.println(i);
}

Iterator<Integer> iter = list.iterator(); //Iterator 선언 
while(iter.hasNext()){//다음값이 있는지 체크
    System.out.println(iter.next()); //값 출력
}

======================================================================
		-------------
Head -> |data | link|
        -------------

public class LinkedList {
	//첫번째 노드를 가리키는 필드 
	private Node head;
	//마지막 노드를 가리키는 필드 
	private Node tail;
	private int size = 0;
	
	private class Node { //하나의 노드에는 data,next가 있다.(next는 node를 가리켜야하니 타입이 Node이다) 
		private Object data; //데이터가 저장될 필드
		private Node next;	//다음 노드를 가리키는 필드
		
		public Node(Object input) {
			this.data = input;
			this.next = null;
		}
	}
	//노드 내용 확인
	public String toString() {
		String.valueOf(this.data);
	}
}

또는

public class SLinkedList<E> implements List<E> {
	private Node<E> head; //노드의 첫부분(리스트의 가장 첫 노드를 가리키는 변수다)
	private Node<E> tail; //노드의 마지막부분
	private int size; //(연결된 노드 개수)
	
	//생성자(null,0 초기화)
	public SLinkedList() {
		this.head = null;
		this.tail = null;
		this.size = 0;
	}
}

//search 메소드 구현(특정위치의 노드를 반환하는 메서드)
private Node<E> search(int index) {
	
	//범위 밖(잘못된 위치)일 경우 예외던지기
	if(index < 0 || index >= size) {
		throw new IndexOutOfBoundsException();
	}
	
	Node<E> x = head; //head가 가리키는 노드부터 시작(순차적으로) x에는 data,next가 있다, 즉 headNode부터 시작
	
	for(int i = 0; i<index; i++) {
		x = x.next;  //x.next는 다음 노드자체를 가리킨다.
	}
	 return x;
}

//addFirst(E value) 맨 앞에 추가 메소드
1. new Node(data,null)를 생성해서 head앞에 놓아야하는데 그럴려면
2. 링크작업이필요하다. new Node의 링크는 헤드를 가리켜야한다.
3. 링크작업이끝나면 head를 new Node로 바꾼다.

public void addFirst(E value) {
	
	Node<E> newNode = new Node<E>(value); //새 노드생성
	newNode.next = head; //링크작업
	head = newNode; //헤드를 newNode로 바꾸기
	size++;
	
	if(head.next == null) {
		tail = head;
	}
}


//add(E value) 또는 addLast(E value)
1. new Node(data,null)를 생성해서 tail 뒤에 놓아야하는데 그럴려면
2. 링크작업이 필요하다. 기존에 tail(data,null)인데  기존 tail의 link를 newNode자체를 가리켜야한다.
3. 그 후 tail을 newNode로 바꾼다.

public boolean add(E value) {
	addLast(value);
	return true;
}

public void addLast(E value) {
	Node<E> newNode = new Node<E>(value); //새 노드생성
	
	if(size == 0) { //처음 넣는 노드일 경우 addFirst로 추가
		addFirst(value);
		return;
	}

	tail.next = newNode; //기존의 tailNode는 newNode를 가리키고
	tail = newNode;
	size++;
}


//add(중간삽입)
public void add(int index, E value) {
	
	//잘못된 인덱스를 참조할 경우 예외 발생
	if(index < size || index < 0) {
		throw new IndexOutOfBoundsException();
	}
	
	//추가하려는 index가 가장 앞이면 addFirst호출
	if(index == 0) {
		addFirst(value);
		return;
	}
	
	//추가하려는 index가 마지막 위치일 경우 addLast호출
	if(index == size) {
		addLast(value);
		return;
	}
	
	//추가하려는 위치의 이전노드
	Node<E> prev_Node = search(index - 1); //추가하려는 위치의 이전노드를 받는다.
	
	//추가하려는 위치의 노드 -> 이전 노드가 가리키고있던 노드를 받는다. (추가하는 노드에 부여하기위해)
	Node<E> next_Node = prev_Node.next; 

	//추가하려는 노드
	Node<E> newNode = new Node<E>(value);
	
	//이전노드가 가리키는 노드를 끊은 뒤 만든 새노드를 연결
	prev_Node.next = null;
	prev_Node.next = newNode;
	
	//새노드는 이전노드가 가리켰던 노드를 가리켜야한다.
	newNode.next = next_Node;
	size++;
}


//삭제할때
1. 가장 앞의 요소 제거 remove()
2. 특정 index의 요소를 제거 remove(int index)
3. 특정 요소를 제거 remove(Object value)

1. 가장 앞의 요소 제거 remove()
//가장 앞의 요소 제거는 쉽게 head가 가리키는 노드의링크, 데이터를 null로 지워준 뒤 head를 다음 노드로 업데이트만 해주면된다.
//그리고 삭제하려는 노드가 리스트에서의 유일한 노드였을 경우 해당 노드를 삭제하면 tail이 가리키는 노드 또한 없어지게된다.(요소가 한개일경우 head와 tail이 가리키는 노드가 같기때문)
public E remove() {
	Node<E> headNode = head;
	
	if(headNode == null) {
		throw new NoSuchElementException();
	}
	
	//삭제된 노드를 반환하기 위한 변수
	E element = headNode.data;
	
	//head의 다음 노드
	Node<E> nextNode = head.next;
	
	//head 노드의 값들 모두 삭제
	head.data = null;
	head.next = null;
	
	//head를 nextNode로 변경
	head = nextNode;
	size--;
	
	//삭제된 요소가 리스트의 유일한 요소일 경우 그 요소는 head이자 tail이다.
	if(size == 0) {
		tail = null;
	}
	return element;
}

2. 특정 index의 요소를 제거 remove(int index)

public E remove(int index) {
	
	//삭제하려는 노드가 첫 번째 원소일 경우
	if(index == 0) {
		return remove();
	}
	
	//잘못된 범위에 대한 예외
	if(index >= size || index < 0) {
		throw new IndexOutOfBoundsException();
	}
	
	Node<E> prevNode = search(index - 1); //삭제할 노드의 이전 노드
	Node<E> removedNode = prevNode.next; //삭제할 노드
	Node<E> nextNode = removedNode.next; //삭제할 노드의 다음 노드
	
	E element = removedNode.data; //삭제되는 노드의 데이터 반환
	
	//삭제하려는 노드가 가리키는 노드를 이전노드가 받아야한다.
	preNode.next = nextNode;
	
	//만약 삭제했던 노드가 마지막 노드라면 tail을 prevNode로 바꾼다.
	if(prevNode.next = null) {
		tail = prevNode;
	}
	
	//데이터 삭제
	removedNode.next = null;
	removedNode.data = null;
	size--;
	
	return element;
}

3. 사용자가 원하는 특정 요소(value)를 리스트에서 찾아서 삭제
- 여기서 핵심은 삭제하려는 요소가 존재하는지를 먼저 봐야한다. -> false, true

public boolean remove(Object value) {
	
	Node<E> prevNode = head;
	boolean hasValue = false;
	Node<E> x = head; //삭제할 value를 찾기위해 head부터 순차적으로 돌아야하니
	
	// value와 일치하는 노드를 찾는다.
	for(; x != null; x=x.next) {
		if(value.equals(x.data)) {
			hasValue = true;
			break;
		}
		prevNode = x;  //삭제할 노드의 이전노드를 prevNode에 대입
	}
	
	//일치하는 요소가 없을 경우 false 반환
	if(x == null) {
		return false;
	}
	
	//만약 삭제하려는 노드가 head라면 기존 remove()를 사용
	if(x.equals(head)) {
		remove();
		return true;
	}
	
	else {
		//삭제하려는 노드의 링크를 이어받아서 이전노드의 링크에 대입
		prevNode.next = x.next;
		
		//만약 삭제했던 노드가 마지막 노드라면 tail을 prevNode로 바꾼다.
		if(prevNode.next == null) {
			tail=prevNode;
		}
		x.data = null;
		x.next = null;
		size--;
		return true;
	}
}

//이렇게 추가,삭제 메소드는 끝이 났고 추가적인 메소드를 알아보자
1. get(int index)메소드
우리가 구현했던 search()와 무슨차이일까?
search()는 노드를 반환하고, get()메소드는 노드의데이터를 반환하는 것이다.

public E get(int index) {
	return search(index).data;
}


2. set(int index, E value)메소드
해당 메소드는 index에 위치한 데이터를 새로운 데이터로 교체하는것이다. 노드의 데이터만 바꿔주면 된다
search()메소드에서 잘못된 인덱스를 참조하고 있지 않은지 검사하기 때문에 따로 구현안해도된다.

public void set(int index, E value) {
	Node<E> replaceNode = search(index);
	replaceNode.data = null;
	replaceNode.data = value;
}


3. indexOf(Objec value) 메소드
사용자가 찾고자하는 요소(value)의 위치(index)를 반환하는 메소드다.
만약, 찾고자하는 요소가 중복되면 가장먼저 나오는 요소의 인덱스를반환하게 구현한다(기존에 indexOf메소드로 그렇게되어있다)

중요한점은 객체끼리 비교할 때는 동등연산자(==)가 아니라 .equals로 해야한다. 동등연산자를 쓰면 주소를 비교하기 때문이다. 우리는 값을 비교해야한다.

public int indexOf(Object value) {
	int index = 0;
	
	for(Node<E> x = head; x != null; x=x.next) {
		if(value.equals(x.data)) {
			return index;
		}
		index++;
	}
	//찾고자 하는 요소를 찾지 못했을 경우 -1 반환
	return -1;
}

4. contains(Object value)메소드
- 사용자가 찾고자 하는 요소(value)가 존재하는지, 안하는지만 확인하면된다. indexOf는 해당위치를 반환하지만 이거는 그냥 여부만 반환하면된다.

public boolean contains(Object item) {
	return indexOf(item) >= 0;
}

5. isEmpty() 메소드
- 리스트가 비어있을경우 true, 아니면 false를 반환

public boolean isEmpty() {
	return size == 0;
}


6. clear() 메소드
- 객체 자체를 null해주기 보다는 모든 노드를 하나하나 null해주는 것이 자바의 가비지 컬렉터가 명시적으로 해당 메모리를 안쓴다고 인지하기 때문에 메모리 관리효율에서 더 좋다.

public void clear() {
	for(Node<E> x = head; x != null;) {
		Node<E> nextNode = x.next;
		x.data = null;
		x.next = null;
		x = nextNode;
	}
	head = tail = null;
	size = 0;
}


7. clone()메소드
- 사용자가 사용하고 있던 LinkedList를 하나 복제하고 싶을 때 쓰는 메소드이다.
- 단순히 '=' 연산으로 객체를 복사하게되면 주소를 복사하기때문에 복사한 객체에서 데이터를 수정하면 원본객체까지 영향을 미치게된다.
- 즉, 얕은 복사가 되는것이다.

SLinkedList<Integer> original = new SLinkedList<>();
original.add(10);

SLinkedList<Integer> copy = original;
copy.add(20);

//original 리스트 조회
for(int i = 0; i<original.size(); i++) {
	System.out.println("index " + i + "data = " + original.get(i));
}

//copy 리스트 조회
for(int i = 0; i<copy.size(); i++) {
	System.out.println("index " + i + "data = " + copy.get(i));
}

//결과 둘다 값이 같아져버린다.
//즉, 객체가 하나로 같은걸 바라보고있는것이다.

따라서 이러한 얕은 복사를 방지하기 위해 깊은 복사를 하는데, 이때 clone()을 쓴다.
Object에 있는 메소드이지만 접근제어자가 protected로 되어있어 우리가 만든 것 처럼 사용자 클래스의 경우 Cloneable 인터페이스를 implement 해야한다.

즉, public class LinkedList<E> implements List<E> 에 Cloneable도 추가해주어야 한다. 만약 안하고서 구현하면 CloneNotSupportedException 에러가 난다.

그리고나서 clone()을 구현하면 되는데, 다음과 같이 재정의를 하면 된다.

public Object clone() throws CloneNotSupportedException {
 
	@SuppressWarnings("unchecked")
	SLinkedList<? super E> clone = (SLinkedList<? super E>) super.clone();
 
	clone.head = null;
	clone.tail = null;
	clone.size = 0;
 
	for (Node<E> x = head; x != null; x = x.next) {
		clone.addLast(x.data);
	}
 
	return clone;
}
 

super.clone() 을 해주면, 객체 자체는 생성되나 내부까지 데이터 복제가 이루어지는 것이 아닌 얕은복사가 되어버린다. 그렇기 때문에 새로 만들어진 객체의 내부에 데이터를 새로 설정해주어야 한다.

즉, 각 노드를 일단 끊고, 처음부터 끝까지 현재 리스트의 데이터를 clone 리스트에 넣어주어야 한다.
=====================================================================
//Student클래스가 Comparable을 구현하지 않았을 경우
//1. 명시적으로 Arrays.sort()에 정렬방법을 알려주던가
//2. Student 클래스에 정렬방법을 구현하던가
public class test {
	public static void main(String[] args) {
		SLinkedList<Student> list = new SLinkedList<>();
 
		list.add(new Student("김자바", 92));
		list.add(new Student("이시플", 72));
		list.add(new Student("조시샵", 98));
		list.add(new Student("파이손", 51));
		
		list.sort(); //여기서 에러가난다.
		
		for(int i = 0; i < list.size(); i++) {
			System.out.println(list.get(i));
		}
	}
}
 
class Student {
	String name;
	int score;
	
	Student(String name, int score){
		this.name = name;
		this.score = score;
	}
	
	public String toString() {
		return "이름 : " + name + "\t성적 : " + score;
	}
}
==================================================================
1. Comparator의 구현을 통해 명시적으로 Arrays.sort()에 파라미터로 넘기는 방법
public class test {
	public static void main(String[] args) {
		SLinkedList<Student> list = new SLinkedList<>();
 
		list.add(new Student("김자바", 92));
		list.add(new Student("이시플", 72));
		list.add(new Student("조시샵", 98));
		list.add(new Student("파이손", 51));
 
		list.sort(customComp);	// Comparator을 파라미터로 넘겨준다.
        
		for(int i = 0; i < list.size(); i++) {
			System.out.println(list.get(i));
		}
		
	}
	// 사용자 설정 comparator(비교기)
	static Comparator<Student> customComp = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			return o2.score - o1.score; //내림차순
		}
	};
 
}
 
class Student {
	String name;
	int score;
	
	Student(String name, int score){
		this.name = name;
		this.score = score;
	}
	
	public String toString() {
		return "이름 : " + name + "\t성적 : " + score;
	}
}
========================================================================
2. Comparable의 구현을 통해 객체의 정렬방법을 설정하는 방법

public class test {
	public static void main(String[] args) {
		SLinkedList<Student> list = new SLinkedList<>();
 
		list.add(new Student("김자바", 92));
		list.add(new Student("이시플", 72));
		list.add(new Student("조시샵", 98));
		list.add(new Student("파이손", 51));
 
		list.sort();
		for(int i = 0; i < list.size(); i++) {
			System.out.println(list.get(i));
		}
		
	}
}
 
class Student implements Comparable<Student> {
	String name;
	int score;
	
	Student(String name, int score){
		this.name = name;
		this.score = score;
	}
	
	public String toString() {
		return "이름 : " + name + "\t성적 : " + score;
	}
 
	@Override
	public int compareTo(Student o) {
		return o.score - this.score;
	}
}
==========================================================================
//제네릭 클래스 사용
class ClassName<E> {
	
	private E element;	// 제네릭 타입 변수
	
	void set(E element) {	// 제네릭 파라미터 메소드
		this.element = element;
	}
	
	E get() {	// 제네릭 타입 반환 메소드
		return element;
	}
	
}
 
class Main {
	public static void main(String[] args) {
		
		ClassName<String> a = new ClassName<String>();
		ClassName<Integer> b = new ClassName<Integer>();
		
		a.set("10");
		b.set(10);
	
		System.out.println("a data : " + a.get());
		// 반환된 변수의 타입 출력 
		System.out.println("a E Type : " + a.get().getClass().getName());
		
		System.out.println();
		System.out.println("b data : " + b.get());
		// 반환된 변수의 타입 출력 
		System.out.println("b E Type : " + b.get().getClass().getName());
		
	}
}

//결과
a data : 10
a E Type : java.lang.String

b data : 10
b E Type : java.lang.Integer
=============================================================================
//제네릭을 두개쓰고싶을때
class ClassName<K, V> {	
	private K first;	// K 타입(제네릭)
	private V second;	// V 타입(제네릭) 
	
	void set(K first, V second) {
		this.first = first;
		this.second = second;
	}
	
	K getFirst() {
		return first;
	}
	
	V getSecond() {
		return second;
	}
}
 
// 메인 클래스 
class Main {
	public static void main(String[] args) {
		
		ClassName<String, Integer> a = new ClassName<String, Integer>();
		
		a.set("10", 10);
 
 
		System.out.println("  fisrt data : " + a.getFirst());
		// 반환된 변수의 타입 출력 
		System.out.println("  K Type : " + a.getFirst().getClass().getName());
		
		System.out.println("  second data : " + a.getSecond());
		// 반환된 변수의 타입 출력 
		System.out.println("  V Type : " + a.getSecond().getClass().getName());
	}
}

//출력
first data : 10
K TYPE : java.lang.String
second data : 10
V Type : java.lang.Integer
=================================================================================
//제네릭 메서드
위의 클래스와 다르게 반환타입 이전에 <> 제네릭타입을 선언한다.
// 제네릭 클래스
class ClassName<E> {
	
	private E element;	// 제네릭 타입 변수
	
	void set(E element) {	// 제네릭 파라미터 메소드
		this.element = element;
	}
	
	E get() {	// 제네릭 타입 반환 메소드 
		return element;
	}
	
	// 제네릭 메소드, o라는 매개변수에는 Integer, String, Class를 던져줬다(아래 함수호출에서)
	// 이렇게 클래스에서 지정한 제네릭유형과 별도로 메소드에서 독립적으로 제네릭 유형을 선언하여 쓸 수 있다.
	<T> T genericMethod(T o) {	
		return o;
	}
 
	
}
 
public class Main {
	public static void main(String[] args) {
		
		ClassName<String> a = new ClassName<String>();
		ClassName<Integer> b = new ClassName<Integer>();
		
		a.set("10");
		b.set(10);
	
		System.out.println("a data : " + a.get());
		// 반환된 변수의 타입 출력 
		System.out.println("a E Type : " + a.get().getClass().getName());
		
		System.out.println();
		System.out.println("b data : " + b.get());
		// 반환된 변수의 타입 출력 
		System.out.println("b E Type : " + b.get().getClass().getName());
		System.out.println();
		
		// 제네릭 메소드 Integer
		// 제네릭 타입으로 받기 때문에 타입에맞게 결과가 나온다.
		System.out.println("<T> returnType : " + a.genericMethod(3).getClass().getName()); 
		
		// 제네릭 메소드 String
		System.out.println("<T> returnType : " + a.genericMethod("ABCD").getClass().getName());
		
		// 제네릭 메소드 ClassName
		System.out.println("<T> returnType : " + a.genericMethod(b).getClass().getName());
	}
}

//결과
a data : 10
a E Type : java.lang.String

b data : 10
b E Type : java.lang.Integer

<T> returnType : java.lang.Integer
<T> returnType : java.lang.String
<T> returnType : ClassName

=====================================================================
그러면 위와같은 방식이 왜 필요한가?? -> 정적메소드로 선언할 때 필요
위에서 제네릭은 유형을 외부에서 지정해주는걸 볼 수 있다.(외부에서 파라미터로 넘기면 그거를 타입으로 지정한다, 클래스도 마찬가지)

하지만, static은 프로그램 실행시 메모리에 이미 올라가있는것이다.
이말은 객체생성을 통해 접근 필요없이(위에서 a.set(10)이럴 필요없다는뜻이다 ) 클래스 이름을 통해 바로 쓸 수 있다.

근데... 어떻게 객체가 생성되기전에 타입을 가져오는거지?

일단 아래에 예시를 보자(에러나는 경우)
 class ClassName<E> {
 
	/*
	 * 클래스와 같은 E 타입이더라도
	 * static 메소드는 객체가 생성되기 이전 시점에
	 * 메모리에 먼저 올라가기 때문에
	 * E 유형을 클래스로부터 얻어올 방법이 없다.
	 */
	static E genericMethod(E o) {	// error!
		return o;
	}
	
}
 
class Main {
 
	public static void main(String[] args) {
 
		// ClassName 객체가 생성되기 전에 접근할 수 있으나 유형을 지정할 방법이 없어 에러남
		ClassName.getnerMethod(3);
 
	}
}
==========================================================================
이렇기 때문에 제네릭이 사용되는 메소드를 정적메소드로 두고 싶은 경우 제네릭 클래스와 별도로 독립적인 제네릭이 사용되어야 한다는 것이다.
// 제네릭 클래스
class ClassName<E> {
 
	private E element; // 제네릭 타입 변수
 
	void set(E element) { // 제네릭 파라미터 메소드
		this.element = element;
	}
 
	E get() { // 제네릭 타입 반환 메소드
		return element;
	}
 
	// 아래 메소드의 E타입은 제네릭 클래스의 E타입과 다른 독립적인 타입이다.
	static <E> E genericMethod1(E o) { // 제네릭 메소드
		return o;
	}
 
	static <T> T genericMethod2(T o) { // 제네릭 메소드
		return o;
	}
 
}
 
public class Main {
	public static void main(String[] args) {
 
		ClassName<String> a = new ClassName<String>();
		ClassName<Integer> b = new ClassName<Integer>();
 
		a.set("10");
		b.set(10);
 
		System.out.println("a data : " + a.get());
		// 반환된 변수의 타입 출력
		System.out.println("a E Type : " + a.get().getClass().getName());
 
		System.out.println();
		System.out.println("b data : " + b.get());
		// 반환된 변수의 타입 출력
		System.out.println("b E Type : " + b.get().getClass().getName());
		System.out.println();
 
		// 제네릭 메소드1 Integer
		System.out.println("<E> returnType : " + ClassName.genericMethod1(3).getClass().getName());
 
		// 제네릭 메소드1 String
		System.out.println("<E> returnType : " + ClassName.genericMethod1("ABCD").getClass().getName());
 
		// 제네릭 메소드2 ClassName a
		System.out.println("<T> returnType : " + ClassName.genericMethod1(a).getClass().getName());
 
		// 제네릭 메소드2 Double
		System.out.println("<T> returnType : " + ClassName.genericMethod1(3.0).getClass().getName());
	}
}

//결과
a data : 10
a E Type : java.lang.String

b data : 10
b E Type : java.lang.Integer

<E> returnType : java.lang.Integer
<E> returnType : java.lang.String
<T> returnType : ClassName
<T> returnType : java.lang.Double
============================================================
//제한된 제네릭
지금까지는 제네릭의 가장 일반적인 예시들을 보여주었다. 
예로들어 타입을 T라고 하고 외부클래스에서 Integer을 파라미터로 보내면 T 는 Integer가 되고, String을 보내면 T는 String이 된다. 
만약 당신이 Student 라는 클래스를 만들었을 때 T 파라미터를 Student로 보내면 T는 Student가 된다. 
즉, 제네릭은 참조 타입 모두 될 수 있다.

근데, 만약 특정 범위 내로 좁혀서 제한하고 싶다면 어떻게 해야할까? 

이 때 필요한 것이 바로 extends 와 super, 그리고 ?(물음표)다. ? 는 와일드 카드라고 해서 쉽게 말해 '알 수 없는 타입'이라는 의미다.

1. <K extends T>, <? extends T>
상한 한계. 즉 extends 뒤에 오는 타입이 최상위 타입으로 한계가 정해지는 것이다.
T타입을 포함한 자식만 가능

대표적인 예로는 제네릭 클래스에서 수를 표현하는 클래스만 받고 싶은 경우가 있다. 
대표적인 Integer, Long, Byte, Double, Float, Short 같은 래퍼 클래스들은 Number 클래스를 상속 받는다.

즉,  Integer, Long, Byte, Double, Float, Short 같은 수를 표현하는 래퍼 클래스만으로 제한하고 싶은 경우 다음과 같이 쓸 수 있다.

public class ClassName<K extends Number> {}

--------------------------------------------------
이렇게 특정 타입 및 그 하위 타입만 제한 하고 싶을 경우 쓰면 된다. 
좀 더 구체적으로 예로 들자면, 다음과 같다. Integer는 Number 클래스를 상속받는 클래스라 가능하지만, 
String은 Number클래스와는 완전 별개의 클래스이기 때문에 에러(Bound mismatch)를 띄운다.

public class ClassName <K extends Number> { 
	... 
}
 
public class Main {
	public static void main(String[] args) {
 
		ClassName<Double> a1 = new ClassName<Double>();	// OK!
 
		ClassName<String> a2 = new ClassName<String>();	// error!
	}
}
==========================================================================
2. <K super T>,<? super T>
T타입의 부모(조상)타입만 가능하다.
하한 한계. 즉 super 뒤에 오는 타입이 최하위 타입으로 한계가 정해지는 것이다.

대표적으로는 해당 객체가 업캐스팅(Up Casting)이 될 필요가 있을 때 사용한다.
예로들어 '과일'이라는 클래스가 있고 이 클래스를 각각 상속받는 '사과'클래스와 '딸기'클래스가 있다고 가정해보자.

이 때 각각의 사과와 딸기는 종류가 다르지만, 둘 다 '과일'로 보고 자료를 조작해야 할 수도 있다. 
(예로들면 과일 목록을 뽑는다거나 등등..) 그럴 때 '사과'를 '과일'로 캐스팅 해야 하는데, 과일이 상위 타입이므로 업캐스팅을 해야한다. 이럴 때 쓸 수 있는 것이 바로 super라는 것이다.

조금 더 현실성 있는 예제라면 제네릭 타입에 대한 객체비교가 있다.



public class ClassName <E extends Comparable<? super E>> { ... }

E extends Comparable 부터 한 번 분석해보자. 

extends는 앞서 말했듯 extends 뒤에오는 타입이 최상위 타입이 되고, 해당 타입과 그에 대한 하위 타입이라고 했다. 그럼 역으로 생각해보면 이렇다. E 객체는 반드시 Comparable을 구현해야한다는 의미 아니겠는가?

예제로 보면 이렇다는 것이다.

public class SaltClass <E extends Comparable<E>> { ... }
 
public class Student implements Comparable<Student> {
	@Override
	public int compareTo(Person o) { ... };
}
 
public class Main {
	public static void main(String[] args) {
		SaltClass<Student> a = new SaltClass<Student>();
	}
}
 
이렇게만 쓴다면 E extends Comparable<E> 까지만 써도 무방하다.
즉, SaltClass의 E 는 Student 이 되어야 하는데, Comparable<Student> 의 하위 타입이어야 하므로 거꾸로 말해 Comparable을 구현해야한다는 의미인 것이다.
======================================================================
그러면 왜 Comparable<E> 가 아닌 <? super E> 일까?

잠깐 설명했지만, super E는 E를 포함한 상위 타입 객체들이 올 수 있다고 했다.

 

만약에 위의 예제에서 학생보다 더 큰 범주의 클래스인 사람(Person)클래스를 둔다면 어떻게 될까? 한마디로 아래와 같다면?

public class SaltClass <E extends Comparable<E>> { ... }	// Error가능성 있음
public class SaltClass <E extends Comparable<? super E>> { ... }	// 안전성이 높음
 
public class Person {...}
 
public class Student extends Person implements Comparable<Person> {
	@Override
	public int compareTo(Person o) { ... };
}
 
public class Main {
	public static void main(String[] args) {
		SaltClass<Student> a = new SaltClass<Student>();
	}
}
 

쉽게 말하면 Person을 상속받고 Comparable 구현부인 comparTo에서 Person 타입으로 업캐스팅(Up-Casting) 한다면 어떻게 될까?

 

만약 <E extends Comparable<E>>라면 SaltClass<Student> a 객체가 타입 파라미터로 Student를 주지만, 
Comparable에서는 그보다 상위 타입인 Person으로 비교하기 때문에 
Comparable<E>의 E인 Student보다 상위 타입 객체이기 때문에 제대로 정렬이 안되거나 에러가 날 수 있다.

그렇기 때문에 E 객체의 상위 타입, 즉 <? super E> 을 해줌으로써 위와같은 불상사를 방지할 수가 있는 것이다.

즉, <E extends Comparable<? super E>> 는 쉽게 말하자면 E 타입 또는 E 타입의 슈퍼클래스가
Comparable을 의무적으로 구현해야한다는 뜻으로 슈퍼클래스타입으로 Up Casting이 발생하더라도 안정성을 보장받을 수 있다.
======================================================================================
- Comparable 인터페이스 사용할려면
compareTo(T o) 메소드를 재정의해야한다.

- Comparator 인터페이스는 
compare(T o1, T o2) 메소드를 정의해야한다.

그럼 왜 파라미터 개수가 다를까?

일단, 두 인터페이스를 구체적으로 알아보기에 앞서 먼저 정답부터 말하자면, Comparable은 "자기 자신과 매개변수 객체를 비교"하는 것이고, 
Comparator는 "두 매개변수 객체를 비교"한다는 것이다.

쉽게 말하자면, Comparable은 자기 자신과 파라미터로 들어오는 객체를 비교하는 것이고, Comparator는 자기 자신의 상태가 어떻던 상관없이 파라미터로 들어오는 두 객체를 비교하는 것이다. 
즉, 본질적으로 비교한다는 것 자체는 같지만, 비교 대상이 다르다는 것이다.

또 다른 차이점이라면 Comparable은 lang패키지에 있기 때문에 import 를 해줄 필요가 없지만, Comparator는 util패키지에 있다.

이 것만 기억해도 일단 기초는 이해한 것이라고 보면 된다.
 
===========================================================================================
1. Comparable
보면은 public interface Comparable<T> {}로 되있다. -> implements

public class ClassName implements Comparable<Type> { 
 
/*
  ...
  code
  ...
 */
 
	// 필수 구현 부분
	@Override
	public int compareTo(Type o) { //Type이 객체일수도있고 뭐든될수있다. 반환은 계산 후 int형
		/*
		 비교 구현
		 */
	}
}


이 때, 필수 구현 부분인 compareTo() 메소드가 바로 우리가 객체를 비교할 기준을 정의해주는 부분이 된다.
쉽게 생각하면 이렇다. 여러분이 클래스를 만들 때, ClassName을 비교하고 싶을 것이다.

아까 Comparable은 자기 자신과 매개변수 객체를 비교한다고 했다. 즉, 자기자신은 ClassName으로 생성한 객체 자신이 되고,
매개변수 객체는 ClassName.compareTo(o); 를 통해 들어온 파라미터 o가 비교 할 객체가 되는 것이다.

예 들어보자. 아까 Student클래스를 비교하고자 했으니 이를 위 방법에 맞게 적용하려면 어떻게 해야할까?

일단, Student 클래스에 Comparable 을 implements 해야한다. 그리고 <> 사이에 들어갈 타입은 무엇일까? 
Student 객체와 또 다른 Student 객체를 비교하고 싶다면, <> 사이에 들어갈 타입 또한 Student가 되어야하지 않겠는가?

즉, Type 은 Student로 바뀌게 된다.

위를 다음과 같이 작성할 수 있겠다.

class Student implements Comparable<Student> {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
	@Override
	public int compareTo(Student o) {
		/*
		 * 비교 구현
		 */
	}
}

-------------------------------------
이제 compareTo 메소드를 구현해야 할 것이다. 만약 나이를 기준으로 비교(대소 관계)를 하고자 한다면 어떻게 하면 될까?
자기 자신의 age(나이)와 매개변수로 들어온 o의 age(나이)의 값을 비교하면 된다.

일단, 말로 설명하기 전에 코드로 먼저 보자면 이렇다.

class Student implements Comparable<Student> {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
	@Override
	public int compareTo(Student o) {
    
		// 자기자신의 age가 o의 age보다 크다면 양수
		if(this.age > o.age) {
			return 1;
		}
		// 자기 자신의 age와 o의 age가 같다면 0
		else if(this.age == o.age) {
			return 0;
		}
		// 자기 자신의 age가 o의 age보다 작다면 음수
		else {
			return -1;
		}
	}
}

--------------------------------------
아마 많은 분들도 1, 0, -1 을 반환값으로 썼거나 그렇게 배웠을 것이다. 
하지만, 꼭 1, 0, -1 이 아니라 양수, 0, 음수로 표현해도 된다는 것이다.

//아래처럼해도 큰 문제가 되지 않는다.
//하지만 당연히 이런 방법은 특수한 경우가 아니라면 추천하진 않는다
class Student implements Comparable<Student> {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
	@Override
	public int compareTo(Student o) {
    
		// 자기자신의 age가 o의 age보다 크다면 양수
		if(this.age > o.age) {
			return 142352;
		}
		// 자기 자신의 age와 o의 age가 같다면 0
		else if(this.age == o.age) {
			return 0;
		}
		// 자기 자신의 age가 o의 age보다 작다면 음수
		else {
			return -1324;
		}
	}
}
------------------------------------
자. 다시 한 번 복기해보자. Comparable의 compareTo는 자기 자신과 매개변수를 비교한다고 했고, compareTo는 정수를 반환하며, 자기 자신을 기준으로 상대방과의 차이 값을 비교하여 반환한다고 했다.
이를 좀 더 생각해보면 -1, 0, 1로 반환할 수도 있으나, 그냥 두 비교대상의 값 차이를 통해 양수인지 음수인지 같은지를 반환해도 되지 않겠는가?

class Student implements Comparable<Student> {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
	@Override
	public int compareTo(Student o) {
 
		/*
		 * 만약 자신의 age가 o의 age보다 크다면 양수가 반환 될 것이고,
		 * 같다면 0을, 작다면 음수를 반환할 것이다.
		 */
		return this.age - o.age;
	}
}
------------------------------------------
public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);	// 17살 2반
		Student b = new Student(18, 1);	// 18살 1반
		
		
		int isBig = a.compareTo(b);	// a자기자신과 b객체를 비교한다.
		
		if(isBig > 0) {
			System.out.println("a객체가 b객체보다 큽니다.");
		}
		else if(isBig == 0) {
			System.out.println("두 객체의 크기가 같습니다.");
		}
		else {
			System.out.println("a객체가 b객체보다 작습니다.");
		}
		
	}
 
}
 
class Student implements Comparable<Student> {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
	@Override
	public int compareTo(Student o) {
		return this.age - o.age; //return this.classNumber - o.classNumber; 도 가능
	}
}
==========================================================
//단, 여기서 주의해야할것이 있다.
연산과정에서 자료형의 범위를 넘어버리는 경우
int는 -2,147,483,648 ~ 2,147,483,647 이다.

만약 해당 범위 밖을 넘게되면 반대편의 값으로 넘어가게 된다.
즉, -2,147,483,648 -1 = -2,147,483,649 일것같지만 실제로는 2,147,483,647 로 int형의 최댓값으로 반환하게된다. -> underflow
반대로 2,147,483,647 + 1 = 2,147,483,648 일 것이다. 
하지만 마찬가지로 int 자료형에서 표현할 수 없는 수로 -2,147,483,648 이 되어 int 형의 최솟값으로 반환된다. 
이렇게 주어진 범위의 상한선을 넘어버리는 것을 'Overflow' 라고 한다

예로들어 다음과 같은 두 값이 있다고 해보자.

o1 = 1,   o2 = -2,147,483,648
그리고 두 수를 위 처럼 return o1 - o2; 형식으로 하면 어떻게 될까?

우리는 '음수'가 나올 때 선행(자기 자신) 원소가 후행 원소보다 작다고 판단했다. 하지만 위 연산을 자세히 보자. 

1 - (-2,147,483,648) = 2,147,483,649 이 되어야 하지만 -2,147,483,648 이 되어 음수값이 나와버린다. 그러면 1인 o1이 -2,147,483,648인 o2보다 작다는 상황이 와버린다.

그렇기 때문에 여러분이 compareTo를 구현하거나, 이후 설명 할 compare을 구현 할 때 대소비교에 있어 이러한 Overflow 혹은, Underflow가 발생할 여지가 있는지를 반드시 확인하고 사용해야 한다.

=====================================================================
//Comparator
- 자기자신이 아니라 매개변수로 들어오는 두 객체를 비교하는것이다.
public interface Comparator<T> {} 
이 부분은 Comparable에서 설명했던 것과 같이 <T>는 하나의 객체 타입이 지정 될 자리라고 생각하면 된다. 

import java.util.Comparator;	// import 필요
public class ClassName implements Comparator<Type> { 
 
/*
  ...
  code
  ...
 */
 
	// 필수 구현 부분
	@Override
	public int compare(Type o1, Type o2) {
		/*
		 비교 구현
		 */
	}
}

--------------------------------------------------
import java.util.Comparator;	// import 필요
public class ClassName implements Comparator<Student> { 
 
/*
  ...
  code
  ...
 */
 
	// 필수 구현 부분
	@Override
	public int compare(Student o1, Student o2) {
		/*
		 비교 구현
		 */
	}
}
-----------------------------------------------
import java.util.Comparator;	// import 필요
class Student implements Comparator<Student> {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
	@Override
	public int compare(Student o1, Student o2) {
    
		// o1의 학급이 o2의 학급보다 크다면 양수
		if(o1.classNumber > o2.classNumber) {
			return 1;
		}
		// o1의 학급이 o2의 학급과 같다면 0
		else if(o1.classNumber == o2.classNumber) {
			return 0;
		}
		// o1의 학급이 o2의 학급보다 작다면 음수
		else {
			return -1;
		}
	}
}
-----------------------------------------------
좀 더 구체적으로 말하자면 Comparable의 compareTo는 선행 원소가 자기 자신이 되고, 
후행 원소가 매개 변수로 들어오는 o 가 되는 반면에, Comparator의 compare는 선행 원소가 o1이 되고, 후행 원소가 o2가 된다.

//좀 더 간단하게 표현
import java.util.Comparator;	// import 필요
class Student implements Comparator<Student> {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
	@Override
	public int compare(Student o1, Student o2) {
 
		/*
		 * 만약 o1의 classNumber가 o2의 classNumber보다 크다면 양수가 반환 될 것이고,
		 * 같다면 0을, 작다면 음수를 반환할 것이다.
		 */
		return o1.classNumber - o2.classNumber;
	}
}
==============================================================
보다시피 a객체의 compare 메소드를 통해 비교하지만, 그 내부에선 두 매개변수인 b(o1)과 c(o2) 가 비교되는 것이기 때문에 a객체와는 관련 없이 두 객체의 비교 값을 반환하게 되는 것이다.

만약에 a.compare 메소드에서 a와 비교하고 싶다면 다음과 같이 해주면 되는 것이다.
a.compare(a, b); 

즉, 객체 자체와는 상관 없이 독립적으로 매개변수로 넘겨진 두 객체를 비교하는 것이 포인트다.
 
그리고 여기서도 마찬가지로 위 예시처럼 수의 범위를 넘어가지 않을 때는 return o1.classNumber - o2.classNumber으로 해주어도 올바른 결과를 얻겠지만, 만약 오버플로우 혹은 언더플로우가 발생할 경우 잘못 된 결과를 얻게 된다.
import java.util.Comparator;
 
public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);	// 17살 2반
		Student b = new Student(18, 1);	// 18살 1반
		Student c = new Student(15, 3);	// 15살 3반
			
		// a객체와는 상관 없이 b와 c객체를 비교한다.
		int isBig = a.compare(b, c);
		
		if(isBig > 0) {
			System.out.println("b객체가 c객체보다 큽니다.");
		}
		else if(isBig == 0) {
			System.out.println("두 객체의 크기가 같습니다.");
		}
		else {
			System.out.println("b객체가 c객체보다 작습니다.");
		}
		
	}
}
 
class Student implements Comparator<Student> {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
	@Override
	public int compare(Student o1, Student o2) {
		return o1.classNumber - o2.classNumber;
	}
}
===========================================================
하지만 위에 처럼 하면은 a.compare()이렇게 compare메소드를 활용하기위한 객체가(a) 필요하게된다.
다음과 같은 상황이 오게 된다.
public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);	// 17살 2반
		Student b = new Student(18, 1);	// 18살 1반
		Student c = new Student(15, 3);	// 15살 3반
        
		int isBig = a.compare(a, b); //b.compare, c.compare() 상관없다
        
		int isBig2 = a.compare(b, c);
    
		int isBig3 = b.compare(a, c);
		
	}
}
 
===================================================================
물론, 비교만을 위해 Student 객체를 하나 더 생성해줘도 되지만, 굳이 쓸모없는 매개변수까지 넣으며 변수를 만들필요가없다.
public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);		// 17살 2반
		Student b = new Student(18, 1);		// 18살 1반
		Student c = new Student(15, 3);		// 15살 3반
		Student comp = new Student(0, 0);	// 비교만을 위해 사용할 객체

		int isBig = comp.compare(a, b);

		int isBig2 = comp.compare(b, c);

		int isBig3 = comp.compare(a, c);
		
	}
}
===============================================================
그래서 우리는 Comparator 기능만 따로 두고싶은데 -> 익명객체(클래스)활용
public class Anonymous {
	public static void main(String[] args) {
	
		Rectangle a = new Rectangle();
		
		//익명객체는 블록이 중심이다!!!!!!!!!!
		// 익명 객체 1  
		Rectangle anonymous1 = new Rectangle() {
		
			@Override
			int get() {
				return width;
			}
		};
		
		System.out.println(a.get());
		System.out.println(anonymous1.get());
		System.out.println(anonymous2.get());
	}
	
	// 익명 객체 2
	static Rectangle anonymous2 = new Rectangle() {
		
		int depth = 30;
		@Override
		int get() {
			return width * height * depth;
		}
	};
}
 
class Rectangle {
	
	int width = 10;
	int height = 20;
	
	int get() {	
		return height;
	}
	
우리가 객체를 구현한다는 것은 무엇일까? 바로 변수를 선언하고, 메소드를 정의하며 하나의 클래스(객체)로 만든다는 것을 의미한다.
말 자체는 어렵지만 쉽게 생각해보면 위 Rectangle 클래스처럼 일반적인 클래스 구현 방식과, 
interface 클래스를 implements 하여 interface의 메소드를 재정의하거나, 
class 를 상속(extends)하여 부모의 메소드, 필드를 사용 또는 재정의 하는 것들 모두 객체를 구현하는 것이다.

이 때, 구현을 하는 클래스들은 모두 '이름'이 존재한다.

그러나 한 번 Rectangle anonymous2 = new Rectangle() {...} 이 부분을 한 번 봐보자. 
구현부에서 분명히 변수를 선언하기도 하고, Rectangle 클래스의 메소드 get()을 '재정의(Override)'를 했다.

즉, 쉽게 생각하여 'Rectangle을 상속받은 하나의 새로운 class라는 것이다.' 

분명 새로운 class인데 이름이 정의되지 않고 있다.
===========================================================
음? 이름은 Rectangle이 아닌가요? 라고 생각할 수 있지만 아니다. 한 번 두 코드를 비교해보자.

//익명객체 클래스를 사용하지 않은 예시
public class Anonymous {
	public static void main(String[] args) {
 
		Rectangle a = new Rectangle();
		ChildRectangle child = new ChildRectangle();
 
		System.out.println(a.get());		// 20
		System.out.println(child.get());	// 10 * 20 * 40
	}
}
 
class ChildRectangle extends Rectangle {
	
	int depth = 40;
	
	@Override
	int get() {
		return width * height * depth;
	}
}
 
class Rectangle {
 
	int width = 10;
	int height = 20;
 
	int get() {
		return height;
	}
}
 
위 코드는 Rectangle 이라는 클래스를 상속받아 ChildeRectangle 이라는 이름으로 정의 된 자식 클래스가 있다. 
그리고 그 자식 클래스에서는 depth란 필드(변수)도 새로 생성했고, get() 메소드를 가로 세로 높이의 곱을 반환하도록 재정의되었다.
====================================================================
그 다음 익명 객체를 사용한 코드를 한 번 보자.

public class Anonymous {
	public static void main(String[] args) {
 
		Rectangle a = new Rectangle();
 
		//원래는 new Rectangle로 하면 override가 안생기는데 생기는 걸로보아, 
		//또 변수 생성했다는 점으로 보아 상속받은것인데 anonymous라는 이름으로 객체만 생성되어있다.
		//이렇게 클래스 이름으로 정의되지 않는 객체를 바로 익명객체이다.
		//이름이 정의되지 않기 때문에 특정 타입이 존재하는 것이 아니기 때문에 반드시 익명객체의 경우는 상속할 대상이 있어야한다.
		//상속이라함은 extedns, implements 포함이다.
		Rectangle anonymous = new Rectangle() {
			int depth = 40;
			@Override
			int get() {
				return width * height * depth;
			}
		};
 
		System.out.println(a.get());			// 20 
		System.out.println(anonymous.get());	// 10 * 20 * 40
	}
}
class Rectangle {
 
	int width = 10;
	int height = 20;
 
	int get() {
		return height;
	}
}
=============================================================
public class Anonymous {
	public static void main(String[] args) {
 
		Rectangle a = new Rectangle();
		
		Shape anonymous = new Shape() {
			int depth = 40;
			
			@Override
			public int get() {
				return width * height * depth;
			}
		};
 
		System.out.println(a.get());			// Shape 인터페이스를 구현한 Rectangle
		System.out.println(anonymous.get());	// Shape 인터페이스를 구현한 익명 객체
	}
 
}
 
class Rectangle implements Shape {
	int depth = 40;
	
	@Override
	public int get() {
		return width * height * depth;
	}
}
 
interface Shape {
 
	int width = 10;
	int height = 20;
 
	int get();
}
=================================================================
우리가 원하는 것은 무엇이었을까? 바로 Comparator 의 기능만 사용하고 싶은 것이다. 
즉, Comparator의 구현을 통해 compare 만 사용하고 싶은 것이라는 뜻이다.

앞서 익명객체에서 설명한 것을 적용해보자.

분명히 Comparator라는 interface는 존재한다. 이는 구현(상속)할 대상이 존재한다는 것이다. 이는 익명객체로 만들 수 있다는 것이다.

즉, 이름은 정의 되지 않지만, Comparator을 구현하는 익명객체를 생성하면 되는 것이다.

import java.util.Comparator;
 
public class Test {
	public static void main(String[] args) {
    
		// 익명 객체 구현방법 1
		Comparator<Student> comp1 = new Comparator<Student>() {
			@Override
			public int compare(Student o1, Student o2) {
				return o1.classNumber - o2.classNumber;
			}
		};
	}
 
	// 익명 객체 구현 2
	public static Comparator<Student> comp2 = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			return o1.classNumber - o2.classNumber;
		}
	};
}
 
 
// 외부에서 익명 객체로 Comparator가 생성되기 때문에 클래스에서 Comparator을 구현 할 필요가 없어진다.
class Student {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
 
}
 

익명 객체의 경우 필요에 따라 main함수 밖에 정적(static) 타입으로 선언해도 되고, 
main안에 지역변수처럼 non-static으로 생성해도 된다.

(일단 필자는 가독성 측면에서 두 번째 방식이 좀 더 잘 보이기 때문에 두 번째 생성 방식(static 방식)으로 설명하도록 하겠다.)

자. 이렇게 외부에서 Comparator을 구현하는 익명객체가 생성되었기 때문에, 
Student 클래스 내부에서 우린 Comparator을 구현해줄 필요가 없어졌다.

즉, 이 전에 a.compare(b, c) 이런식이 아니라, 
위에서 생성한 익명객체를 가리키는 comp 를 통해 comp.compare(b, c) 이런 식으로 해주면 된다는 것이다.

===========================================================================
import java.util.Comparator;
 
public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);	// 17살 2반
		Student b = new Student(18, 1);	// 18살 1반
		Student c = new Student(15, 3);	// 15살 3반
			
		// comp 익명객체를 통해 b와 c객체를 비교한다.
		int isBig = comp.compare(b, c);
		
		if(isBig > 0) {
			System.out.println("b객체가 c객체보다 큽니다.");
		}
		else if(isBig == 0) {
			System.out.println("두 객체의 크기가 같습니다.");
		}
		else {
			System.out.println("b객체가 c객체보다 작습니다.");
		}
		
	}
	
	public static Comparator<Student> comp = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			return o1.classNumber - o2.classNumber;
		}
	};
}
 
class Student {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
}
익명 객체를 사용하면 좋은 점이 하나 더 있다. 다시 한 번 복기해보자. 익명 객체는 이름이 정의되지 않은 하나의 새로운 클래스와 같다고 보면 된다.

클래스를 상속(구현)할 때, 이름만 다르게 하면 몇 개던 여러개를 생성할 수 있듯이, 익명 객체 또한 마찬가지다. 다만, 이름이 없을 뿐이라는 것이다.

즉, 익명 객체를 가리키는 변수명만 달리하면 몇 개든 자유롭게 생성할 수 있다. 위 예제에서는 학급을 기준으로 대소 비교를 했지만, 
만약 나이를 기준으로도 대소 비교를 하고 싶다면 다음과 같이 하나의 또다른 익명 객체를 생성 할 수 있다는 것이다.
===========================================================================
import java.util.Comparator;
 
public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);	// 17살 2반
		Student b = new Student(18, 1);	// 18살 1반
		Student c = new Student(15, 3);	// 15살 3반
			
		// 학급 기준 익명객체를 통해 b와 c객체를 비교한다.
		int classBig = comp.compare(b, c);
		
		if(classBig > 0) {
			System.out.println("b객체가 c객체보다 큽니다.");
		}
		else if(classBig == 0) {
			System.out.println("두 객체의 크기가 같습니다.");
		}
		else {
			System.out.println("b객체가 c객체보다 작습니다.");
		}
		
		// 나이 기준 익명객체를 통해 b와 c객체를 비교한다.
		int ageBig = comp2.compare(b, c);
		
		if(ageBig > 0) {
			System.out.println("b객체가 c객체보다 큽니다.");
		}
		else if(ageBig == 0) {
			System.out.println("두 객체의 크기가 같습니다.");
		}
		else {
			System.out.println("b객체가 c객체보다 작습니다.");
		}
		
	}
	
	// 학급 대소 비교 익명 객체
	public static Comparator<Student> comp = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			return o1.classNumber - o2.classNumber;
		}
	};
	
	// 나이 대소 비교 익명 객체
	public static Comparator<Student> comp2 = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			return o1.age - o2.age;
		}
	};
}
 
class Student {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
}
===========================================================================
//우리는 이때까지 Comparator를 익명객체로 만들어서 구현했다.
//그러면 Comparable은 익명객체로 생성해서 쓰면안돼??
//생성은가능하지만 복잡해진다.
만약 Comparable을 익명객체로 다음과 같이 생성했다고 해보자
public static Comparable<Student> comp = new Comparable<Student>() {
	@Override
	public int compareTo(Student o1) {
		// 구현부
	}
};

그러면 Comparable에서 자기 자신은 무엇인가? 익명 객체가 될 것이다. 
Student객체가 아니라는 것이다. 즉, 익명의 객체와 Student가 비교하는 것이지, Student와 Student가 비교되는 것이 아니라는 것이다.

public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);	// 17살 2반
		Student b = new Student(18, 1);	// 18살 1반
        
		/*
		 * Stduent b 객체는 comp의 30이랑 비교되는 것이다.
		 * 즉, a.compareTo(b) 처럼 서로 다른 객체에 대한 비교가 불가능하다.
		 */
		int classBig = comp.compareTo(b);
        
		
	}
	
	// 학급 대소 비교 익명 객체
	public static Comparable<Student> comp = new Comparable<Student>() {
		int a = 30;
		@Override
		public int compareTo(Student o) {
			return a - o.classNumber;
		}
	};
}
// Student 클래스 생략
한 마디로 여러분이 자기 동일한 타입의 자신의 객체와 어떤 객체를 비교하고자 하면 
Comparable을 익명객체로 선언한다고 한들, 동일한 타입 비교는 불가능하다는 것이다.

======================================================================
//자바에서는 오름차순을 디폴트 기준으로 삼고있다. 즉, 선행원소가 후행원소보다 작다는 뜻이다.
//compare 혹은 compareTo를 사용하여 객체를 비교 할 경우 음수가 나오면 두 원소의 위치를 바꾸지 않는다는 것이다.
그 다음 정렬 알고리즘에 의해 index 1 원소와 index 2 원소를 비교한다고 해보자.
선행 원소인 3이 2보다 크다. -> 양수가 나오면 두 원소의 위치를 바꾼다.

일반화를 하면
[두 수의 비교 결과에 따른 작동 방식]
음수일 경우 : 두 원소의 위치를 교환 안함
양수일 경우 : 두 원소의 위치를 교환 함

public class Test {
	
	public static void main(String[] args) {
		
		MyInteger[] arr = new MyInteger[10];
		
		// 객체 배열 초기화 (랜덤 값으로) 
		for(int i = 0; i < 10; i++) {
			arr[i] = new MyInteger((int)(Math.random() * 100));
		}
	}
	
}
 
class MyInteger {
	int value;
	
	public MyInteger(int value) {
		this.value = value;
	}
}
----------------------------------------------------
위 객체인 MyInteger 클래스는 사용자가 만든 객체라 아직 비교 기준이 없다. 그러면 어떻게 해주어야 하겠는가?

앞서 배웠던 비교 기준을 생성하면 되는 것이다. 우리는 비교 기준을 설정하는 방법 두 가지를 배웠다. Comparable과 Comparator다.
Comparable을 사용한다면 MyInteger 클래스에 구현(implements)을 해야 할 것이다.

class MyInteger implements Comparable<MyInteger> {
	int value;
	
	public MyInteger(int value) {
		this.value = value;
	}
 
	// 자기 자신의 value을 기준으로 파라미터 값과의 차이를 반환한다.
	@Override
	public int compareTo(MyInteger o) {
		return this.value - o.value;
	}
	
}
=============================================================================
그리고 나서 정렬 메소드로 가장 자주 쓰이는 Arrays.sort()메소드에 한 번 돌려서 테스트를 해보자. 다음과 같이 말이다.

import java.util.Arrays;
 
public class Test {
	
	public static void main(String[] args) {
		
		MyInteger[] arr = new MyInteger[10];
		
		// 객체 배열 초기화 (랜덤 값으로) 
		for(int i = 0; i < 10; i++) {
			arr[i] = new MyInteger((int)(Math.random() * 100));
		}
 
		// 정렬 이전
		System.out.print("정렬 전 : ");
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
		
		Arrays.sort(arr);
        
		// 정렬 이후
		System.out.print("정렬 후 : ");
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
	}
	
}
 
class MyInteger implements Comparable<MyInteger> {
	int value;
	
	public MyInteger(int value) {
		this.value = value;
	}
	
	@Override
	public int compareTo(MyInteger o) {
		return this.value - o.value;
	}
	
}

결과는 다음과 같이 나온다.
//정렬전 : 51 24 10 ...
//정렬후 : 10 12 20 ...

만역에 위에서 compareTo를 정의하지않으면 에러가난다. 
MyInteger 클래스를 Arrays.sort 안에서 정렬을 하면서 원소를 비교하려 하는데, 
해당 클래스가 비교할 수 있는 기준이 정의되어있지 않아서 정렬 자체가 불가능한 것이다.

=========================================================================
//만약에 Comparable 대신 Comparator을 쓴다면 ??
//익명객체를 생성하여 MyInteger에 대한 Comparator를 구현해주는것이다.
import java.util.Arrays;
import java.util.Comparator;
 
public class Test {
	
	public static void main(String[] args) {
		
		MyInteger[] arr = new MyInteger[10];
		
		// 객체 배열 초기화 (랜덤 값으로) 
		for(int i = 0; i < 10; i++) {
			arr[i] = new MyInteger((int)(Math.random() * 100));
		}
	}
 
	
	static Comparator<MyInteger> comp = new Comparator<MyInteger>() {
		
		@Override
		public int compare(MyInteger o1, MyInteger o2) {
			return o1.value - o2.value;
		}
	};
}
 
 
class MyInteger {
	int value;
	
	public MyInteger(int value) {
		this.value = value;
	}
	
}
==============================================================
//위에서 쓰였던 Arrays.sort() 내부를 보면 배열만 파라미터로 받는게아니라 Comparator 또한 파라미터로 받는다.
public static <T> void sort(T[] a, Comparator<? super T> c) 
즉, Comparator 파라미터로 넘어온 c의 비교기준을 갖고 파라미터로 넘어온 객체배열 a을 정렬하겠다는 의미다.

우리가 그동안 Arrays.sort()를 쓸 때 Arrays.sort(array); 이런식으로 배열만 넘겨주었지만
사실은 Comparator로 구현된 객체를 파라미터로 같이 넘겨주어 Arrays.sort(array, comp); 로도 쓸 수 있다는 것이다.

import java.util.Arrays;
import java.util.Comparator;
 
public class Test {
	
	public static void main(String[] args) {
		
		MyInteger[] arr = new MyInteger[10];
		
		// 객체 배열 초기화 (랜덤 값으로) 
		for(int i = 0; i < 10; i++) {
			arr[i] = new MyInteger((int)(Math.random() * 100));
		}
 
		// 정렬 이전
		System.out.print("정렬 전 : ");
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
		
		Arrays.sort(arr, comp);		// MyInteger에 대한 Comparator을 구현한 익명객체를 넘겨줌
        
		// 정렬 이후
		System.out.print("정렬 후 : ");
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
	}
 
	
	static Comparator<MyInteger> comp = new Comparator<MyInteger>() {
		
		@Override
		public int compare(MyInteger o1, MyInteger o2) {
			return o1.value - o2.value;
		}
	};
}
 
 
class MyInteger {
	int value;
	
	public MyInteger(int value) {
		this.value = value;
	}
	
	
}
======================================================================
import java.util.Arrays;
import java.util.Comparator;
 
public class Test {
	
	public static void main(String[] args) {
		
		Student[] arr = new Student[9];
		
		arr[0] = new Student(3, 70);	// 3반 70점
		arr[1] = new Student(1, 70);	// 1반 70점
		arr[2] = new Student(1, 50);	// 1반 50점
		arr[3] = new Student(2, 60);	// 2반 60점
		arr[4] = new Student(2, 80);	// 2반 80점
		arr[5] = new Student(1, 30);	// 1반 30점
		arr[6] = new Student(2, 70);	// 2반 70점
		arr[7] = new Student(3, 90);	// 3반 90점
		arr[8] = new Student(3, 60);	// 3반 60점
		
		Student[] arr2 = arr.clone();	// 정렬 테스트를 위한 arr 객체 복사
		Student[] arr3 = arr.clone();	// 정렬 테스트를 위한 arr 객체 복사
		
		System.out.println("(c, s) -> (classNum, score)");
		// 정렬 이전
		System.out.print("정렬 전 : ");
		for(Student v : arr) {
			System.out.print(v);
		}
		System.out.println();
 
		Arrays.sort(arr);	// Comparable 사용
		
 
		System.out.print("\n학급 오름차순 정렬(같을 경우 성적 내림차순) : ");
		for(Student v : arr) {
			System.out.print(v);
		}
		System.out.println();
		
		
		
		Arrays.sort(arr2, comp1);	// Comparator 사용 
		
		System.out.print("\n학급 오름차순 정렬(같을 경우 성적 오름차순) : ");
		for(Student v : arr2) {
			System.out.print(v);
		}
		System.out.println();
	
		
		
		Arrays.sort(arr3, comp2);	// Comparator 사용
		
		System.out.print("\n성적 내림차순 정렬(같을 경우 학급 오름차순) : ");
		for(Student v : arr3) {
			System.out.print(v);
		}
		System.out.println();
		
	}
 
	
	static Comparator<Student> comp1 = new Comparator<Student>() {
		
		@Override
		public int compare(Student o1, Student o2) {
			
			// 만약 학급이 같다면 성적을 기준으로 "오름차순"으로 정렬한다.
			if(o1.classNum == o2.classNum) {
				return o1.score - o2.score;
			}
			return o1.classNum - o2.classNum;	// 학급 기준 오름차순으로 정렬한다.
		}
	};
	
	static Comparator<Student> comp2 = new Comparator<Student>() {
		
		@Override
		public int compare(Student o1, Student o2) {
			
			// 만약 성적이 같다면 학급을 "오름차순"으로 정렬한다.
			if(o1.score == o2.score) {
				return o1.classNum - o2.classNum;
			}
			return o2.score - o1.score;	// 성적을 내림차순으로 정렬한다.
		}
	};
}
 
 
class Student implements Comparable<Student> {
 
	int classNum;
	int score;
	
	public Student(int classNum, int score) {
		this.classNum = classNum;
		this.score = score;
	}
	
	@Override
	public int compareTo(Student o) {
		
		// 만약 학급이 같다면 성적을 기준으로 "내림차순"으로 정렬한다.
		if(this.classNum == o.classNum) {
			return o.score - this.score;
		}
		return this.classNum - o.classNum;	// 학급 기준 오름차순으로 정렬한다.
	}
	
	
	@Override
	public String toString() {
		return "("+classNum + ", " + score + ")  ";
	}
	
}
================================================================
ArrayList를 구현하기 전에 잠깐 알아두고 가야할 점이 있다.
ArrayList는 다른 자료구조와 달리 Object[] 배열(객체 배열)을 두고 사용한다는 점이다. 일단은 다른 자료구조는 살펴보지 않았으니 이렇다는 정도만 알고계시면 될 것 같다.

또한 모든 자료구조는 '동적 할당'을 전제로 한다. 가끔 ArrayList를 구현 할 때, 
리스트가 꽉 차면 리스트의 크기를 늘리지 않고 그냥 꽉 찼다고 더이상 원소를 안받도록 구현한 경우가 많은데 이는 자료구조를 구현하는 의미가 없다.

동적 할당을 안하고 사이즈를 정해놓고 구현한다면 메인함수에서 정적배열을 선언하는 것과 차이가 없다.

데이터의 개수를 알 수 없는데 배열을 쓰고 싶을 때 여러분은 어떤 방법을 선택하는가?
ArrayList, LinkedList 등의 자료구조를 선택할 것이다. 왜냐면 사이즈를 정하지 않고 동적으로 활용할 수 있기 때문이다.
 
마지막으로 리스트 계열 자료구조는 데이터 사이에 빈 공간을 허락하지 않는다.
아래 예를 들어보자.
Object[] a = {"a", "b", "c", "d"}; 
이러한 배열이 있고, 만약 "c"라는 데이터를 삭제하려고 한다. (a[2] = null)

그러면 a배열은 다음과 같은 상황일 것이다.
Object[] a = {"a", "b", null, "d"};

이렇게 데이터 사이에 빈 공간이 생길 경우 빈공간을 없애야 한다. 즉, null 뒤에 있는 모든 데이터를 한 칸씩 끌어와야한다는 것이다. 아래와 같이 말이다.
Object[] a = {"a", "b", "d", null};

이렇게 항상 리스트 계열 자료구조는 데이터들이 '연속되어'있어야 한다는 점을 기억하자.

===================================================================
public interface List<E> {
 
	/**
	 * 리스트에 요소를 추가합니다.
	 * 
	 * @param value 리스트에 추가할 요소
	 * @return 리스트에서 중복을 허용하지 않을 경우에 리스트에 이미 중복되는 
	 *         요소가 있을 경우 {@code false}를 반환하고, 중복되는 원소가
	 *         없을경우 {@code true}를 반환
	 */
	boolean add(E value);
 
	/**
	 * 리스트에 요소를 특정 위치에 추가합니다. 
	 * 특정 위치 및 이후의 요소들은 한 칸씩 뒤로 밀립니다.
	 * 
	 * @param index 리스트에 요소를 추가할 특정 위치 변수
	 * @param value 리스트에 추가할 요소
	 */
	void add(int index, E value);
 
	/**
	 * 리스트의 index 위치에 있는 요소를 삭제합니다.
	 * 
	 * @param index 리스트에서 삭제 할 위치 변수
	 * @return 삭제된 요소를 반환
	 */
	E remove(int index);
 
	/**
	 * 리스트에서 특정 요소를 삭제합니다. 동일한 요소가 
	 * 여러 개일 경우 가장 처음 발견한 요소만 삭제됩니다.
	 * 
	 * @param value 리스트에서 삭제할 요소
	 * @return 리스트에 삭제할 요소가 없거나 삭제에 실패할 
	 *         경우 {@code false}를 반환하고 삭제에 성공할 경우 {@code true}를 반환 
	 */
	boolean remove(Object value);
 
	/**
	 * 리스트에 있는 특정 위치의 요소를 반환합니다.
	 * 
	 * @param index 리스트에 접근할 위치 변수 
	 * @return 리스트의 index 위치에 있는 요소 반환 
	 */
	E get(int index);
 
	/**
	 * 리스트에서 특정 위치에 있는 요소를 새 요소로 대체합니다.
	 * 
	 * @param index 리스트에 접근할 위치 변수 
	 * @param value 새로 대체할 요소 변수 
	 */
	void set(int index, E value);
 
	/**
	 * 리스트에 특정 요소가 리스트에 있는지 여부를 확인합니다.
	 * 
	 * @param value 리스트에서 찾을 특정 요소 변수 
	 * @return 리스트에 특정 요소가 존재할 경우 {@code true}, 존재하지 않을 경우 {@code false}를 반환  
	 */
	boolean contains(Object value);
 
	/**
	 * 리스트에 특정 요소가 몇 번째 위치에 있는지를 반환합니다.
	 * 
	 * @param value 리스트에서 위치를 찾을 요소 변수  
	 * @return 리스트에서 처음으로 요소와 일치하는 위치를 반환.
	 *         만약 일치하는 요소가 없을경우 -1 을 반환 
	 */
	int indexOf(Object value);
 
	/**
	 * 리스트에 있는 요소의 개수를 반환합니다.
	 * 
	 * @return 리스트에 있는 요소 개수를 반환  
	 */
	int size();
 
	/**
	 * 리스트에 요소가 비어있는지를 반환합니다.
	 * @return 리스트에 요소가 없을경우 {@code true}, 요소가 있을경우 {@code false}를 반환 
	 */
	boolean isEmpty();
 
	/**
	 * 리스트에 있는 요소를 모두 삭제합니다.
	 */
	public void clear();
 
}


ArrayList 이름으로 생성해준 뒤 앞서 작성했던 List 인터페이스를 implements 해준다. 
implements 를 하면 class 옆에 경고표시가 뜰 텐데 List 인터페이스에 있는 메소드들을 구현하라는 것이다. 
어차피 모두 구현해나갈 것이기 때문에 일단은 무시한다.

public class ArrayList<E> implements List<E> {
	
	private static final int DEFAULT_CAPACITY = 10; //최소 기본사이즈
	private static final Object[] EMPTY_ARRAY = {}; //빈 배열
	
	private int size;
	
	Object[] array; //요소를 담을 배열
	
	//생성자1 (초기공간할당x)
	public ArrayList() {
		this.array = EMPTY_ARRAY;
		this.size = 0;
	}
	
	//생성자2 (초기공간할당o)
	public ArrayList(int capacity) {
		this.array = new Object[capacity];
		this.size = 0;
	}
}

===================================================================
#)동적할당을위한 resize 메소드 구현
배열의 크기는 외부에서 마음대로 접근하면 데이터의 손상을 야기할수있어서 private로 설정

private void resize() {
	int array_capacity = array.length;
	
	//배열의 크기가 0이면
	if(Arrays.equals(array, EMPTY_ARRAY)) {
		array = new Object[DEFAULT_CAPACITY];
		return;
	}
	
	//용량이 꽉 찬 경우
	if(size == array_capacity) {
		int new_capacity = array_capacity * 2;
		
		//copy
		array = Arrays.copyOf(array, new_capacity);
		return;
	}
	
	//용량이 절반 미만으로 요소가 차지하고 있을경우
	if(size < (array_capacity / 2)) {
		int new_capacity = array_capacity / 2;
		
		//copy
		array = Arrays.copyOf(array, Math.max(new_capacity, DEFAULT_CAPACITY));
		return;
	}
}

조건문 1 :  if (Arrays.equals(array, EMPTY_ARRAY)) 
앞서 생성자에서 사용자가 용적을 별도로 설정하지 않은 경우 EMPTY_ARRAY로 초기화 되어있어 용적이 0인 상태다. 
이 경우를 고려하여 이제 새로 array의 용적을 할당하기 위해 최소 용적으로 설정해두었던 DEFAULT_CAPACITY의 크기만큼 배열을 생성해주고 메소드를 종료한다.
또한 주소가 아닌 값을 비교해야 하기 때문에 Arrays.equals() 메소드를 사용하도록 하자.

조건문 2 :  if (size == array_capacity) 
데이터가 꽉 찰 경우에는 데이터(요소)를 더 받아오기 위해서 용적을 늘려야 한다. 
즉, 데이터의 개수가 용적과 같을 경우는 꽉 차있는 경우를 말한다. 이 때는 새롭게 용적을 늘릴 필요가 있으므로 새로운 용적을 현재 용적의 2배로 설정하도록 한다. 

또한 기존에 담겨있던 요소들을 새롭게 복사해와야한다. 이 때 편리하게 쓸 수 있는 것이 Arrays.copyOf() 메소드다. 
Arrays.copyOf() 는 첫 번째 파라미터로 '복사할 배열'을 넣어주고, 두 번째 파라미터는 용적의 크기를 넣어주면 된다.
만약 복사할 배열보다 용적의 크기가 클 경우 먼저 배열을 복사한 뒤, 나머지 빈 공간은 null로 채워지기 때문에 편리하다.


조건문 3 :  if (size < (array_capacity / 2 )) 

데이터가 용적에 절반 미만으로 차지 않을 경우다. 이 경우 데이터는 적은데 빈 공간이 메모리를 차지하고 있어 불필요한 공간을 낭비할 뿐이다. 이럴 때에는 사이즈를 적적하게 줄여주는 것이 좋지 않겠는가?

데이터의 개수가 용적의 절반 미만이라면 용적도 절반으로 줄여주도록 하기 위해 새로운 용적(new_capacity)을 현재 용적의 절반으로 둔 뒤, Arrays.coptyOf() 메소드를 통해 새로운 용적의 배열을 생성해주도록 하자.


만약 복사할 배열보다 용적의 크기가 작을경우 새로운 용적까지만 복사하고 반환하기 때문에 예외발생에 대해 안전하다.

-------------------------------------
#)add메소드 구현
1. 기본삽입 add(E value),addLast(E value)
@Override
public boolean add(E value) {
	addLast(value);
	return true;
}
 
public void addLast(E value) {
 
	// 꽉차있는 상태라면 용적 재할당
	if (size == array.length) {
		resize();
	}
	array[size] = value;	// 마지막 위치에 요소 추가
	size++;	// 사이즈 1 증가
}


2. 중간삽입: add(int index, E value)
삽입하는 위치 뒤부터 한칸씩 밀린다.

@Override
public void add(int index, E value) {
	if(index > size || index < 0) { //입력을 벗어날 경우 예외
		throw new IndexOutOfBoundsException();
	}
	if(index == size) { //index가 마지막 위치라면 addLast 메소드로 요소추가
		addLast(value);
	}
	else {
		if(size == array.length) { //꽉차있다면 크기 재할당
			resize();
		}
		
		//index 기준 후자에 있는 모든 요소들 한 칸씩 뒤로밀기 (여기서 size는 요소개수이다) 그래서 size가 4이면 총 4개의 데이터가있고 array길이랑은 다르다.
		//데이터가 몇개 들어있냐, array.length는 그냥 배열자체길이이다.(넣을수있는공간)
		for(int i = size; i>index; i--) {
			array[i] = array[i-1];  // int i=size니까 size가 4이면 인덱스는 0부터시작 그래서 끝에 데이터가있는곳의 뒤에(공백)부터 넣는다는 소리
		}
		
		//위에서 한칸씩 뒤로 밀었으면 이제 원하는위치에 요소 대입
		array[index] = value; 
		size++;
	}
}

3. addFirst(E value)
public void addFirst(E value) {
	add(0, value);
}

==================================================================================
1. get(int index)메소드
@SuppressWarnings("unchecked")
@Override
public E get(int index) {
	if(index >= size || index < 0) {	// 범위 벗어나면 예외 발생
		throw new IndexOutOfBoundsException();
	}
	// Object 타입에서 E타입으로 캐스팅 후 반환
	return (E) array[index];
}
 
여기서 @SuppressWarnings("unchecked") 에 대해 잠깐 언급하고 가겠다.

@SuppressWarnings("unchecked")을 붙이지 않으면 type safe(타입 안정성)에 대해 경고를 보낸다. 
반환되는 것을 보면 E 타입으로 캐스팅을 하고 있고 그 대상이 되는 것은 Object[] 배열의 Object 데이터다. 
즉, Object -> E 타입으로 변환을 하는 것인데 이 과정에서 변환할 수 없는 타입을 가능성이 있다는 경고로 메소드 옆에 경고표시가 뜨는데,
우리가 add하여 받아들이는 데이터 타입은 유일하게 E 타입만 존재한다. 

그렇기 때문에 형 안정성이 보장된다. 한마디로 ClassCastException이 뜨지 않으니 이 경고들을 무시하겠다는 것이 @SuppressWarnings("unchecked") 이다. 
물론 절대 남발하면 안되고, 형 변환시 예외 가능성이 없을 확실한 경우에 최소한의 범위에서 써주는 것이 좋다. 그렇지 않으면 중요한 경고 메세지를 놓칠 수도 있기 때문이다.



2. set(int index, E value) 메소드

set 메소드는 기존에 index에 위치한 데이터를 새로운 데이터(value)으로 '교체'하는 것이다. 
add메소드는 데이터 '추가'인 반면에 set은 '교체'라는 점을 기억해두도록 하자.

결과적으로 index에 위치한 데이터를 교체하는 것이기 때문에 get이랑 메소드가 유사하다. 
다만 get은 해당 인덱스의 값을 반환하는 것이였다면 set은 데이터만 교체해주면 된다.

 

@Override
public void set(int index, E value) {
	if (index >= size || index < 0) {	// 범위를 벗어날 경우 예외 발생
		throw new IndexOutOfBoundsException();
	} 
	else {
		// 해당 위치의 요소를 교체
		array[index] = value;
	}
}

마찬가지로 잘못된 인덱스를 참조하고 있진 않은지 반드시 검사가 필요하다. 그냥 
index로 참조하는 모든 메소드들은 반드시 검사해야한다고 생각하면 편하다.


3. indexOf(Object value) 메소드
indexOf 메소드는 사용자가 찾고자 하는 요소(value)의 '위치(index)'를 반환하는 메소드다.

그러면 이러한 질문이 들어올 수 있다. "찾고자 하는 요소가 중복된다면 어떻게 반환해야 하나요?" 
이에 대한 답은 가장 먼저 마주치는 요소의 인덱스를 반환한다는 것이다. (실제로 자바에서 제공하는 indexOf 또한 동일하게 구현된다.)

"그럼 찾고자 하는 요소가 없다면요?" 이러한 경우 -1 을 반환한다.

그리고 중요한 점은 객체끼리 비교할 때는 동등연산자(==)가 아니라 반드시 .equals() 로 비교해야 한다. 
객체끼리 비교할 때 동등연산자를 쓰면 값을 비교하는 것이 아닌 주소를 비교하는 것이기 때문에 잘못된 결과를 초래한다..

@Override
public int indexOf(Object value) {
	int i = 0;
    
	// value와 같은 객체(요소 값)일 경우 i(위치) 반환
	for (i = 0; i < size; i++) {
		if (array[i].equals(value)) {
			return i;
		}
	}
	// 일치하는 것이 없을경우 -1을 반환
	return -1;
}


3 - 1. LastindexOf(Object value) 메소드
indexOf 메소드는 index가 0부터 시작했다면 반대로 거꾸로 탐색하는 과정도 있는 것이 좀 더 좋다. 
예로들어 사용자가 찾고자 하는 인덱스가 뒤 쪽이라고 예상 가능할 때 굳이 앞에서부터 찾아 줄 필요가 없기 때문이다. 
또한 이후에 구현 할 Stack에서도 이용 가능하므로 만들어 두는 것이 좀 더 좋다.

public int lastIndexOf(Object value) {
	for(int i = size - 1; i >= 0; i--) {
		if(array[i].equals(value)) {
			return i;
		}
	}
	return -1;
}
 

4. contains(Object value) 메소드

indexOf 메소드는 사용자가 찾고자 하는 요소(value)의 '위치(index)'를 반환하는 메소드였다면, 
contains는 사용자가 찾고자 하는 요소(value)가 존재 하는지 안하는지를 반환하는 메소드다.

찾고자 하는 요소가 존재한다면 true를, 존재하지 않는다면 false를 반환한다.

음? 그러면 indexOf와 기능이 비슷하니깐 이를 쓸 수 있을 것 같은데? 라는 생각이 들었다면 매우 정답이다.

어차피 해당 요소가 존재하는지를 '검사'한다는 기능은 같기 때문에 indexOf 메소드를 이용하여 만약 음수가 아닌 수가 반환되었다면 요소가 존재한다는 뜻이고, 
음수(-1)이 나왔다면 요소가 존재하지 않는다는 뜻이다. 즉, 아래와 같이 contains 메소드를 만들 수 있다.

@Override
public boolean contains(Object value) {
 
	// 0 이상이면 요소가 존재한다는 뜻
	if(indexOf(value) >= 0) {
		return true;
	}
	else {
		return false;
	}
}


==========================================================================================
#)remove 메소드 구현
1. remove(int index) 
특정위치에 있는 요소를 제거


@SuppressWarnings("unchecked")
@Override
public E remove(int index) {
 
	if (index >= size || index < 0) {
		throw new IndexOutOfBoundsException();
	}
 
	E element = (E) array[index];	// 삭제될 요소를 반환하기 위해 임시로 담아둠
	array[index] = null;
    
	// 삭제한 요소의 뒤에 있는 모든 요소들을 한 칸씩 당겨옴
	for (int i = index; i < size - 1; i++) {
		array[i] = array[i + 1];
		array[i + 1] = null;
	}
	size--;
	resize();
	return element;
}

또한 명시적으로 요소를 null로 처리해주어야 가비지컬렉터에 의해 더이상 쓰지 않는 데이터의 메모리를 수거(반환)해주기 때문에 최대한 null 처리를 하는 것이 좋다.

(물론 명시적으로 안해도 크게 문제는 없지만 그럴경우 가비지컬렉터가 쓰지 않는 데이터더라도 나중에 참조될 가능성이 있는 데이터로 볼 가능성이 높아진다. 
이는 결국 메모리를 많이 잡아먹을 수 있는 가능성이 있다는 것이고 결과적으로 프로그램 성능에도 영향을 미친다는 것이다.)


2. remove(Object value) 메소드
@Override
public boolean remove(Object value) {
 
	// 삭제하고자 하는 요소의 인덱스 찾기
	int index = indexOf(value);
 
	// -1이라면 array에 요소가 없다는 의미이므로 false 반환
	if (index == -1) {
		return false;
	}
 
	// index 위치에 있는 요소를 삭제
	remove(index);
	return true;
}



3. clear메소드
clear()는 단어에서 짐작 할 수 있듯 모든 요소들을 비워버리는 작업이다. 
예로들어 리스트에 요소를 담아두었다가 초기화가 필요할 때 쓸 수 있는 유용한 존재다. 
또한 모든 요소를 비워버린다는 것은 요소가 0개라는 말로 size 또한 0으로 초기화해주고, 
배열의 용적 또한 현재 용적의 절반으로 줄일 수 있도록 해준다.

왜 초기 값이 아니라 절반이죠? 라고 질문할 수도 있다. 
물론 초기값으로 초기화 해주어도 되나 생각해보면 현재 배열의 용적은 결국 데이터를 해당 용적에 만족하는 조건만큼 썼다는 의미가 된다.

예로들어 데이터가 1500개였다고 가정해보자. 그럼 용적량은 10부터 2씩 곱해지므로 2560이었을 것이다.
요소들을 모두 초기화 했더라도 앞으로 들어올 데이터들 또한 데이터가 1500개일 가능성이 높다. 
즉, 현재 용적량의 기대치에 근접할 가능성이 높기 때문에 일단은 용적량을 일단 절반으로만 줄이는 것이다.
즉, 쓰던 만큼 쓸 가능성이 높다는 애기

(또한 그만큼 데이터를 쓰지 않더라도 삭제 과정에서 용적량을 줄이기 때문에 크게 문제되진 않는다.)

@Override
public void clear() {
	// 모든 공간을 null 처리 해준다. 
	for (int i = 0; i < size; i++) {
		array[i] = null;
	}
	size = 0;
	resize();
}
==================================================================================
1. clone() 메소드

만약 사용자가 사용하고 있던 ArrayList를 새로 하나 복제하고 싶을 때 쓰는 메소드다.

단순히 = 연산자로 객체를 복사하게 되면 '주소'를 복사하는 것이기 때문에 복사한 객체에서 데이터를 조작할 경우 원본 객체까지 영향을 미친다. 즉 얕은 복사(shallow copy)가 된다는 것이다.

ArrayList<Integer> original = new ArrayList<>();
original.add(10);	// original에 10추가 
 
//이렇게 주소를 복사하면 얕은복사가된다.
ArrayList<Integer> copy = original; 
copy.add(20);	// copy에 20추가 -> 원본에도 똑같이 들어간다.
 
System.out.println("original list");
for(int i = 0; i < original.size(); i++) {
	System.out.println("index " + i + " data = " + original.get(i));
}
 
System.out.println("copy list");
for(int i = 0; i < copy.size(); i++) {
	System.out.println("index " + i + " data = " + copy.get(i));
}
 
//서로 같다
System.out.println("original list reference : " + original);
System.out.println("copy list reference : " + copy);
====================================================================================
그래서 깊은복사가 필요하다
이러한 것을 방지하기 위해서 깊은 복사를 하는데, 이 때 필요한 것이 바로 clone()이다. Object에 있는 메소드이지만 접근제어자가 protected로 되어있어 우리가 만든 것 처럼 사용자 클래스의 경우 Cloneable 인터페이스를 implement 해야한다.

즉, public class ArrayList<E> implements List<E> 에 Cloneable도 추가해주어야 한다.

그리고나서 clone()을 구현하면 되는데, 다음과 같이 재정의를 하면 된다.

@Override
public Object clone() throws CloneNotSupportedException {
 
	// 새로운 객체 생성
	ArrayList<?> cloneList = (ArrayList<?>)super.clone();
 
	// 새로운 객체의 배열도 생성해주어야 함 (객체는 얕은복사가 되기 때문)
	cloneList.array = new Object[size];
 
	// 배열의 값을 복사함
	System.arraycopy(array, 0, cloneList.array, 0, size);
 
	return cloneList;
}

조금 어려워 보일 수 있는데, 이해하지 못해도 된다. ArrayList에서 중요한 부분은 아니니...

그래도 설명을 덧붙이자면, super.clone() 자체가 생성자 비슷한 역할이고 shallow copy를 통해 사실상 new ArrayList() 를 호출하는 격이라 제대로 완벽하게 복제하려면 clone한 리스트의 array 또한 새로 생성해서 해당 배열에 copy를 해주어야 한다.


위와같이 만들고 나서 clone()한 것 까지 포함해서 테스트를 해보자.

ArrayList<Integer> original = new ArrayList<>();
original.add(10);	// original에 10추가 
 
ArrayList<Integer> copy = original;
ArrayList<Integer> clone = (ArrayList<Integer>) original.clone();
 
copy.add(20);	// copy에 20추가
clone.add(30);	// clone에 30추가
 
System.out.println("original list");
for(int i = 0; i < original.size(); i++) {
	System.out.println("index " + i + " data = " + original.get(i));
}
 
System.out.println("\ncopy list");
for(int i = 0; i < copy.size(); i++) {
	System.out.println("index " + i + " data = " + copy.get(i));
}
 
System.out.println("\nclone list");
for(int i = 0; i < clone.size(); i++) {
	System.out.println("index " + i + " data = " + clone.get(i));
}
 
System.out.println("\noriginal list reference : " + original);
System.out.println("copy list reference : " + copy);
System.out.println("clone list reference : " + clone); //애 혼자 다르다
 

//결과
original list
index 0 data = 10
index 1 data = 20

copy list
index 0 data = 10
index 1 data = 20

clone list
index 0 data = 10
index 1 data = 30
=================================================================================
#)toArray
상황에 따라서 List를 Array(배열)로 형변환 시켜야 할때가 있다.

List<String> list = new ArrayList<String>();
String[] arr = new String[5];
arr = list.toArray(arr); //list를 배열로변환( [] )

또 다른 방법으로는
list의 최상위객체 Object를 활용하여 모든 객체를 배열로([]) 담을수있다는 장점이있다.
단점은 사용할때 형변환을 시켜줘야한다.
Object[] arr = list.toArray(); 

====================================================================================
#)Null
인스턴스가 생성되지 않은 상태이다.
List 변수가 메모리에 아무런 주소값도 참조하지 않은 상태이다.

#)isEmpty
size() = 0
Java SE 1.6 이상부터 사용이 가능하다.
배열이 생성되었으나, 배열안에 아무것도 없는 상태를 말한다.
객체는 존재하지만, 공백이다.

=====================================================================================
자바에서 배열을 정렬할 때
java.util.Arrays 클래스의 sort()메소드를 이용하면된다.

int[] arr = {1,2,5,1,5}; //오름차순으로 정렬 -> Arrays.sort(arr);

내림차순
Integer[] arr = {1,2,4,5,2,1}
Arrays.sort(arr,Collections.reverseOrder()); //내림차순을 이용하면 java.util.Collection을 추가해야된다.

========================================================================================
제네릭을 사용하면 Object를 사용할 때와 달리 객체의 타입을 컴파일 타임에 체크할 수 있어서 타입 안정성(type safety)를 높이고 형변환의 번거로움이 줄어든다는 장점이 있다.

public class Box<M, I> {

    private M material;
    private I item;

    public M getMaterial() {
        return material;
    }

    public void setMaterial(M material) {
        this.material = material;
    }

    public I getItem() {
        return item;
    }

    public void setItem(I item) {
        this.item = item;
    }
}

Box<Paper, String> box = new Box<Paper, String>();
Box<Paper, String> box = new Box<>();   // JDK1.7부터 생략 가능

Box box = new Box();    // Object로 간주 
제네릭은 JDK1.5부터 도입되었는데 하위 호환을 위해 타입을 지정하지 않고도 객체를 생성할 수 있으며 이런 경우 타입은 Object로 간주된다.
주의해야 할 점은 참조변수에서 지정한 타입과 생성자에서 지정한 타입은 반드시 일치해야 한다.

두 타입이 서로 상속관계에 있다 해도 타입이 다르면 컴파일 에러가 발생한다.

예를 들어 Cardboard 클래스가 Paper의 자식 클래스라고 해서 Box<Paper> box = new Box<Cardboard>();는 불가능하다.
==========================================================================================
//제네릭메서드
제네릭은 클래스뿐만아니라 메소드에서도 사용할수있다.
제네릭 타입을 선언한 메소드를 제네릭 메소드라한다.

public class CoffeeMachine {
	public <T> Coffee makeCoffee(T capsule) {
		return new Coffee(capsule);
	}
}

CoffeeMachine coffeeMachine = new CoffeeMachine();
Colombian capsule = new Colombian();
coffeeMachine.<Colombian>makeCoffee(capsule);
coffeeMachine.makeCoffee(capsule); //타입추정가능하므로 생략가능

제네릭 메소드를 호출할때는 바로 위에처럼 메소드 명 앞에 <>로 타입을 지정해줘야 하지만
컴파일러가 타입을 추정할 수 있는 경우엔 생략가능 대두분 컴파일러가 타입을 추정할 수 있다.

=================================================================================================
//제네릭 제한
extends, super키워드를 통해 제한

//제한하지 않았을 때 예시
class BoxMaterial {}
class Paper {}
class Plastic {}

public class Box<M> { //여기에 어떤 타입이든 괜춘
	private M material;
	
	public static void main(String[] args) {
		Box<Water> box = new Box<>(); //타입 M에 제한이 없으므로 어떤 타입이든 지정 가능
	}
}



-----------------------------------------
class BoxMaterial {}
class Paper extends BoxMaterial {}
class Plastic extends BoxMaterial {}

public class Box<M extends BoxMaterial> { //BoxMaterial과 자식타입만 가능
	private M material;
	
	public static void main(String[] args) {
		Box<Water> waterBox = new Box<>(); //불가(상속받은 애만가능)
		Box<Paper> paperBox = new Box<>();
		Box<Plastic> plastic = new Box<>();
		
	}
}

=============================================================================
//와일드카드
<? extends T>  : T와 그 자손 타입만 가능
<? super T>  : T와 그 조상타입만 가능
<?> : 제한없이 모든 타입이 가능 <? extends Object> 와 동일

class Fruit {
	String name;
	
	@Override
	public String toString() {
		return name;
	}
}

class Apple extends Fruit {
	public Apple() {
		this.name = "사과";
	}
}

class Banana extends Fruit {
	public Banana() {
		this.name = "바나나";
	}
}

class FruitCup<T extends Fruit> { // T에는 Fruit을 상속받은 무엇이든 가능
	List<T> fruits;
	
	public FruitCup() {
		fruits = new ArrayList<>();
	}
	public void addFruit(T fruit) {
		fruits.add(fruit);
	}
	public List<T> getFruits() {
		return fruits;
	}
}

public class Juicer {
	public static Juice makeJuice(FruitCup<? extends Fruit> fruitCup) { // ?에 오는 것들은 fruit를 상속받은것 또는 fruit 자신이고 fruit에 있는 toString을 쓸수있다.
		return new Juice(fruitCup.getFruits());
	}
	
	public static void main(String[] args) {
		FruitCup<Fruit> fruitCup = new FruitCup<>(); //부모로 받는다.<fruit>
		fruitCup.addFruit(new Apple()); //업캐스팅으로 들어간다
		fruitCup.addFruit(new Banana()); 
		System.out.println(Juicer.makeJuice(fruitCup).toString());
		
		FruitCup<Apple> appleCup = new FruitCup<>(); //자식으로 받지만 부모의 toString은 쓸수있다.
		appleCup.addFruit(new Apple());
		appleCup.addFruit(new Apple());
		appleCup.addFruit(new Apple());
		System.out.println(Juicer.makeJuice(appleCup).toString());
	}
}

//결과
Juice{fruits=[사과,바나나]}
Juice{fruits=[사과,사과,사과]}

======================================================================================
//두개는 동일한 함수이다.
public static Juice makeJuice(FruitCup<? extends Fruit> fruitCup) {
		return new Juice(fruitCup.getFruits());
	}


------------
public static <T extends Fruit> Juice makeJuice(FruitCup<T> fruitCup) { //T로 받고 T라는 아이는 Fruit를  상속받은아이
	return new Juice(fruitCup.getFruits());
}
=========================================================================================
//제네릭 메소드 대표적인 예시
1. Collections.sort(List, Comparator) 의 선언부

static <T> void sort(List<T> list, Comparator<? super T> c)
List<T>와 Comparator<? super T>타입의 두개의 매개변수를 받는 sort()메소드이다.
첫번째 매개변수는 정렬할 대상이고, 두번째 매개변수는 정렬할 방법이 정의된 Comaprator이다.



2. Collection.sort(List)의 선언부
public static <T extends Comparable<? super T>> void sort(List<T> list)

List<T> 한개를 매개변수로 받는 sort()메소드이다.
타입T를 요소로하는 List를 매개변수로 넘기면되는데, T 또는 그 조상클래스가 Comparable을 구현해야한다. <T extends Comparable<? super T>>

=============================================================================================
직렬화: 객체에 저장된 데이터를 I/O 스트림에 쓰기(출력)위해 연속적인(serial) 데이터로 변환하는 것
역직렬화: I/O스트림에서 데이터를 읽어서(입력) 객체를 만드는 것

(1) Object to JSON(직렬화)
#)pom.xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.11.1</version>
</dependency>

#)java
List<Member> memberList = new ArrayList<>();
memberList.add(new Member("Kate", 30, "1234"));
memberList.add(new Member("Jason", 23, "5678"));
memberList.add(new Member("Aaron", 35, "9012"));

ObjectMapper mapper = new ObjectMapper();

// object to json
mapper.configure(MapperFeature.PROPAGATE_TRANSIENT_MARKER, true);
mapper.writeValue(new File("test.json"), memberList);

#)test.json
[
  {
    "id": 1001,
    "name": "Kate",
    "age": 30
  },
  {
    "id": 1002,
    "name": "Jason",
    "age": 23
  },
  {
    "id": 1003,
    "name": "Aaron",
    "age": 35
  }
]

--------------------------
(2)JSON to Object(역직렬화)
#)java
ObjectMapper mapper = new ObjectMapper();

// json to object
mapper.configure(MapperFeature.PROPAGATE_TRANSIENT_MARKER, true);
mapper.writeValue(new File("test.json"), memberList);
System.out.println(mapper.readValue(new File("test.json"), new ArrayList<Member>().getClass()));

//결과
[{id=1001, name=Kate, age=30}, {id=1002, name=Jason, age=23}, {id=1003, name=Aaron, age=35}]

=========================================================================================
//sql튜닝 전
0.329sec
select * from 사원 where substring(사원번호,1,4) = 1100 and length(사원번호)=5

//sql튜닝 후
0.000sec
select * from 사원 where 사원번호 between 11000 and 11009

===========================================================================================
#)try~catch를 하기에 앞서 컴파일에러, 런타임에러 차이를 알아야한다.
1. 컴파일에러
- 문법을 잘못 작성해 프로그램을 컴파일할 수 없는 에러이다.
ex) ; 누락, interface사용 시 함수의 구체적인 내용을 적지 않은 등

2. 런타임에러
- 프로그래머의 설계 미숙으로 프로그램 실행 중 발생하는 에러이다.
ex) NullPointer, 무한루프, ArithmeticException(0으로 나눴을때)

---------------------------------
try는 에러가 발생할 여지가 있는 코드를 작성하면 된다.

try {
	//이 영역의 문장을 실행하다가
	//에러발생하면, catch로 이동
} catch(ErrorA e) {
	//try영역에서 ErrorA라는 에러가 발생하면 여기로 이동
} catch(Exception e) {
	//나머지에러는 여기서 다 처리
	//이게 되는이유는 모든 에러들은 Exception클래스를 상속받았기때문에(업캐스팅으로 받는것이다)
} finally {
	//여기는 무조건지나감
}

-----------------------------------
public class TryCatchMain {
	public static void main(String[] args) {
		try {
			String str = null; //오류발생하기위해
			System.out.println(str.length()); //여기서 오류발생(nullpointer)
		}
	} catch(NullPointerException e) {
		System.out.println(e.toString() + "에러발생"); //java.lang.NullPointerException 에러발생
		System.out.println("에러처리 루틴 실행");
	}
	System.out.println("여기까지 실행된다");
}
==========================================================================================
#)throw(직접오류를 발생), throws(에러를 미룬다 -> 에러를 호출하는 쪽으로 넘긴다)
public class UseThrowMain {
	public static void main(String args[]) {
		try {
			throw new Exception("일부러 에러 발생");
		}catch(Exception e) {
			System.out.println(e.getMessage()); //"일부러 에러 발생"
			System.out.println(e.toString()); //java.lang.Exception: 일부러 에러 발생
			e.printStackTrace(); //at UseThrowMain.main(UseThrowMain.java:7)
			return;
		} finally {
			System.out.println("여기는 무조건 통과");
		}
	}
}
==============================================================================================
#)throws 예시
makeURL함수에서 에러가 발생했지만, makeURL함수 안에서 try,catch문으로 처리하지 않고 호출하는 상위 쪽으로 넘긴다.
그래서, 만약에 makeURL내에서 에러가 발생하면 makeURL을 호출하고 있는 main함수 내에서 에러를 처리해줘야한다.

public class ShiftCatch {
	//이 함수의 기능은 받은 문자 그대로 보내줌
	public URL makeURL(String urlstr) throws MalformedURLException { //이 함수를 호출하는 쪽에서 에러를 처리해라 
		return new URL(urlstr);
	}
	public static void main(String args[]) {
		ShiftCatch p = new ShiftCatch();
		try {
			//정확한 URL을 입력하지 않아서 에러발생
			URL url = p.makeURL("httttttp://www.ya.co.kr"); //여기서 호출하니까 에러처리해야함(여기서)
		} catch(MalformedURLException e) {
			e.printStackTrace();
		}finally {
			
		}
	}
}
======================================================================
request.getSession(true) : 세션이 있으면 기존 세션 반환, 세션이 없으면 새로운 세션을 생성해서 반환
request.getSession(false) : 세션이 있으면 기존세션반환, 세션이 없으면 null 반환

//로그아웃 시
@PostMapping("/logout")
    public String logoutV3(HttpServletRequest request) {
        HttpSession session = request.getSession(false);
        if (session != null) {
            session.invalidate();
        }
        return "redirect:/";
    }
====================================================================
//로그인 유무에 따라 메인화면처리
@Slf4j
@Controller
@RequiredArgsConstructor
public class HomeController {

    private final MemberRepository memberRepository;
    private final SessionManager sessionManager;

    @GetMapping("/")
    public String homeLoginV3(HttpServletRequest request, Model model) {

        HttpSession session = request.getSession(false); //메모리 낭비를 줄이기 위해 false로 -> null을 반환하니까
        if (session == null) {
            return "home";
        }

        Member loginMember = (Member)session.getAttribute(SessionConst.LOGIN_MEMBER);

        //세션에 회원 데이터가 없으면 home
        if (loginMember == null) {
            return "home";
        }

        //세션이 유지되면 로그인으로 이동
        model.addAttribute("member", loginMember);
        return "loginHome";
    }

}

----위에서처럼하면 request를 계속 가져와야하고 세션도 get으로 가져와야한다.
그래서 @SessionAttribute를 이용한다. 단, @SessionAttribute는 세션을 생성하지 않는다.
따라서 세션이 존재하지 않을경우 loginMember = null이 된다.

public String homeLoginV3Spring(
        @SessionAttribute(name = SessionConst.LOGIN_MEMBER, required = false) Member loginMember, Model model) {

    //세션에 회원 데이터가 없으면 home
    if (loginMember == null) {
        return "home";
    }

    //세션이 유지되면 로그인으로 이동
    model.addAttribute("member", loginMember);
    return "loginHome";
}

========================================================================================
클라이언트 -> 웹컨테이너(필터1 - 필터2 - 필터3 - 자원(서블릿,jsp))
spring mvc에서 요청을 가장 먼저 받는 것이 DispatcherServlet이라고 했는데 서블릿이 요청받기 전에 다양한 필터들이 있을 수 있다.

client - filter - dispatcherServlet - interceptor - controller
(실제로 인터셉터가 컨트롤러로 요청을 위임하는 것은 아님, 인터셉터를 거쳐서 가는 것일뿐)

========================================================================================
@EqualsAndHashCode 어노테이션
-> equals, hashCode 를 자동으로 생성해주는 어노테이션이다.
equals는 두 객체의 내용이 같은지(동등성)
hashCode는 두 객체가 같은 객체인지(동일성)
equals는 String 비교연산자로 유명하고, HashCode는 객체 주소값을 변환한 값이다.


Cat cat = new Cat(1,2);
Cat cat2 = new Cat(1,2);
Cat cat3 = cat2;
System.out.println(cat.hashCode()); //2083562754
System.out.println(cat2.hashCode()); //1239731077
System.out.println(cat3.hashCode()); //1239731077

------------------------
동등성: 객체가 주소값이 다르더라도 내용(필드값)이 같다면 같다고 보는 것 equals
동일성: 객체가 주소값이 다르면 아무리 같은 내용이라도 같지 않다고 본다.  (ex: ==)

원래 equals의 기능은 동일성비교까지 한다.
근데, 우리는 내용만 비교하면 된다. 그래서 재정의를 해줘야한다.

그러면 hashCode는 왜 오버라이딩을 같이 할까??
 
public class Student {
	private String name;
	private int age;
	
	public Student(String name, int age) {
		this.name=name;
		this.age=age;
	}
}

public void equalsTest() {
	Student s1 = new Student("dsg", 30);
	Student s2 = new Student("dsg", 30);
	
	//기존의 equals는 내용, 주소값까지 같아야 true이다. ( == 와 동일한 셈이다)
	System.out.println("result: " + s1.equals(s2));  //false
}

// Object의 기본 원래 equals 메서드 
public boolean equals(Object obj) {
	return (this==obj);
}

------------------------------------------
우리가 자주쓰는 equals() 메서드는(string)에서 재정의 된것이다. -> 객체 내부의 value를 비교하는 것이다.
String class는 equals()메소드를 재정의해서 주소값 비교가 아닌 문자열 값만을 비교한다.

근데 VO는 String과 다르게 내부 변수들까지 비교해야하기때문에 equals를 재정의 해야한다.

public class Student {
	private String name;
	private int age;
	
	public Student(String name, int age) {
		this.name=name;
		this.age=age;
	}
}

@Override
    public boolean equals(Object obj) {
//        return super.equals(obj); 기존 Object클래스 구현 내용
        if (this == obj) return true; //같은 객체를 참조하여 참조값이 같은경우 true를 바로 리턴해준다. -> 똑같은걸 바라보니까
        if (obj == null || getClass() != obj.getClass()) return false; //비교하는 객체가 null인지 클래스가 같은지 체크한다.
        Student student = (Student) obj;
        return age == student.age &&    //age는 정수형이라서 == 로 비교, name은 string이니까 equals로 비교
                Objects.equals(name, student.name); //객체 내부의 값들을 비교하여 리턴한다.
    }
}
------------------------------------------
//하지만, 다른 문제가 남아있다. hashCode가 다르다는 점이다.
//hashCode란 객체를 식별하는 하나의 고유 정수값이다.
public class MainTest {
	public static void main(String[] args) {
		Student s1 = new Student("dsg", 24);
		Student s2 = new Student("dsg", 24);
	
		System.out.println(s1.equals(s2)) //true
		System.out.println(s1.hashCode()) //1975012498
		System.out.println(s2.hashCode()) //1808253012
	}
}
그래서 객체의 값 동등성 비교시 hashCode()를 오버라이딩할 필요가 있다.

@Override
public int hashCode() {
	return Objects.hash(name,age);  //같은 hashCode가 나오게된다.
}

===================================================================================
public class Student {

    private String name;
    private int stuNum;

    public Student(String name, int stuNum) {
        this.name = name;
        this.stuNum = stuNum;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Student)) return false;
        Student student = (Student) o;
        return stuNum == student.stuNum && Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, stuNum);
    }
================================================================================




