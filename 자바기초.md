> 자바특징
1. 객제지향언어
2. 자동 메모리관리(GC)
3. 멀티 쓰레드를 지원(하나의 프로그램에서 동시에 여러작업)
4. 풍부한 라이브러리 지원
5. 운영체제에 독립적
특정운영체제에서만 실행가능한게 아니라 JVM(자바가상머산)때문에 가능하다.<br>
JVM = 자바 프로그램이 실행되는 가상컴퓨터
```
		     Java 애플리케이션 
        /         |        \
       /          |         \
	  /           |          \
-----------    ---------     ------------
jvm(window)    jvm(OSX용)     jvm(리눅스용)
-----------    ---------     ------------
os(window)     os(매킨토시)     os(리눅스)
-----------    ---------     ------------
하드웨어          하드웨어         하드웨어
-----------    ---------     ------------
따라서 jvm만 설치되있으면 된다.
```

```
자바설치 및 제거
cmd -> java -version -> appwiz.cpl(프로그램제거) -> java 2개 제거(update, kit)

자바 설치
구글 -> jdk8 -> win64 다운 -> 설치 -> C위치에 다운 ->  jdk 먼저 다운 받고 -> jre를 다운받는다(자바코드실행하기위한)
->cmd -> java -version

환경변수 세팅
cmd -> sysdm.cpl -> 위에 고급 -> 환경변수 -> 시스템변수(전체계정이 설정되는)에서
1. JAVA_HOME
-> C->programfiles -> java -> jdk 폴더 들어가기 -> 파일탐색기 주소 복사
편집 -> %JAVA_HOME%bin 삭제 -> 새로 만들기 -> 변수이름 : JAVA_HOME , 변수값 : C:\Program Files\Java\jdk1.8.0_291
-> 확인
2. Path
또 시스템변수에 가서 -> Path 편집 -> %JAVA_HOME%\bin

cmd -> javac -version으로 확인

파일탐색기 주소창에 -> %JAVA_HOME%하면 설치경로로 이동된다.
------------------------------------------------------------
이클립스 설치
구글 -> eclipse -> downloadpackages -> MORE DOWNLOADS 9월부터 자바8버전이 인식xx 그래서 3월로 다운받는다
-> EE설치 

톰캣설치 -> 8버전(core.zip) -> 압축풀기 -> bin은 톰캣에 관련된 명령어 들어가있다. -> 
start.bat 더블클릭 실행 -> 서버가 돌아간다 -> localhost:8080치면 톰캣이 돌아가고 있기때문에 가능하다. 윈도우는 startup.bat이고
리눅스는 start.sh라서 실제로 systemctl start tomcat과 같다고 생각하면 된다.

시스템변수
1.Path하나더 추가 -> CATALIA_HOME ->  E:\평일7월JSP_조성동\apache-tomcat-8.5.68 (bin에는 들어가지말고)
2.Path 편집 -> 추가 %CATALINA_HOME%\bin

cmd새로 열어서 -> %CATALINA_HOME% 입력 -> 톰캣홈디렉토리 나온다. -> startup치면 서버구동된다. -> localhost:8080 검색
```
javac.exe는 자바 컴파일러로 javac hello.java 를 하면 hello.class 로 변환해준다<br>
java.exe(클래스파일실행) hello.class 파일을 실행할 수있다.<br>

---

```
build란 소스파일(.java)로 부터 프로그램을 만들어 내는 과정
멀티컬럼모드 -> alt + shift + a + 화살표

//자료형 (=Data Type) : 코드 내에서 데이터를 식별하는 기준
		// 1. 기본 자료형
		// boolean	1bit     참/거짓
		// byte     1byte	 정수
		// char     2byte	 문자
		// short	2byte    정수
		// int 	    4byte	 정수
		// long     8byte    정수
		// float    4byte    실수
		// double   8byte    실수
		
		// 2. 참조 자료형
		// 기본 자료형을 제외한 모두
		// 클래스로 만들어진 자료형을 의미한다.
		// 참조 자료형은 데이터를 직접 저장하지 않고, 다른 위치에 생성된 공간을 가리키는 자료형

//배열도 참조 자료형에 해당한다.
		int[] arr = new int[] {10,20,30,40,50};  //arr이 저기 있는 요소들을 가리킨다. (new가 힙에서 만들어진다)
        System.out.println("arr = "+arr); //참조변수는 출력시, 해시코드라는 이상한 값이 출력된다.
		System.out.println("arr[0]= "+arr[0]);
```
```
1은 참은 맞지만 자바는 아니다. 자바는 true, false만
boolean bo1 = true;
boolean bo3 = 10 > 5;  // true
boolean bo2 = false;

//형변환은 반올림 생각하지 않는다.  .2f이런거는 가능
//그래서, 3.141592에서
//double result = Math.round(pi); // 3.0으로 출력(소수점위치에서 반올림)
//double result = Math.round(pi*100) / 100.0; //3.14로 출력
```

```
public class ex02 {
	public static void main(String args[]) {
		//Scanner라는 데이터를 읽는 도구를 사용해서 입력을 좀 더 수월하게 처리가능(통로에서 쓱 스캔)
		//그래서 scanner는 system.in과 같이쓴다.
		
		//System : 표준 입출력 클래스
		//System안에는 in이 있고  -> 표준 입력 스트림(한글자씩 통로를 통해 전달) 그래서 한번에 주는 scanner이용
		//System안에는 out이 있고 -> 표준 출력 스트림
		//System안에는 err가 있다. -> 표준 에러출력 스트림
		//Scanner도 자료형인데 참조자료형이다(기본자료형을 제외한 모든 자료형은 참조자료형이다)
		//즉, Scanner는 직접 공간을 가지고 있지 않다. 그래서 new로 공간을 만든다.
		//import해줘야된다.
		Scanner sc;  //Scanner앞에 커서두고 ctrl+space하면 import구문 알아서 들어간다.
		sc = new Scanner(System.in);  //Scanner가 스트림을 스캔을 뜬다.(sc라는 변수가 전달)
		                              //그 후 이 스트림(통로)를 닫아줘야한다.(보안상)
		int n;
		System.out.print("정수입력: ");
		n = sc.nextInt();  //sc.next자료형();
		System.out.println("n= "+n);
		
		sc.close();  //요즘에는 안닫아도 된다.(습관들이기 닫도록)
	}
}
```
```
public class ex03 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int it;
		String str;
		double db;
		
		//위의 세변수에 입력을 받도록
		System.out.print("1.정수입력: ");
		it = sc.nextInt();
		System.out.println("it = "+it+"\n");
		
		System.out.print("2.실수입력: ");
		db = sc.nextDouble();
		System.out.println("db = "+db+"\n");
		
		System.out.print("3.문자열 입력: ");
		str = sc.next();  //문자열은 그냥 next
		System.out.println("str = "+str+"\n");
		
		sc.close(); //Scanner는 중간에 닫으면 다시 열수 없기 때문에 마지막에 닫자!!
		

	}
}
```

```
public class ex04 {
    public static void main(String[] args) {
        //boolean,정수,실수는 next자료형() 형식으로 받을 수 있다
        //또한 문자열과, 문자는 조금다르다
        String test = "apple" //인텍스가 01234 이렇다.
        System.out.println("test.charAt(1)) //p

        Scanner sc = new Scanner(System.in);
		String str;
		char ch;
		
		System.out.print("문자열 입력: ");
		str = sc.next();
		System.out.println("str = "+str);
		
		//문자입력 시
		System.out.print("문자 입력: ");
		ch = sc.next().charAt(0);  //문자는 0만쓰면된다.
		System.out.println("ch = "+ch);
		
		sc.close();
    }
}
```
```
public class ex06 {

	public static void main(String[] args) {
		//nextLine() : 한 줄 전체를 입력 받는 구문, 버퍼를 비우는 용도로 사용되기도 한다.
		Scanner sc = new Scanner(System.in);
		
		String lang;
		int number;
		String program;
		System.out.print("공부중인 언어: ");
		lang = sc.next(); //공백 이후 부터는 출력안된다. 
		System.out.println("lang = "+lang); //자바 입니다~ 라고 입력하면 자바만 들어간다.
		                                    //즉, 버퍼에 입니다~ 가 남아있다.
		// 그래서 lang = sc.nextLine(); 이렇게 쓴다.
		
		//nextInt(); 는 \n을 안가져온다. 
		
		System.out.print("수업회차?");
		number = sc.nextInt();
		System.out.println(number + "일차~\n");
		
		sc.nextLine();  // nextInt()에서 \n을 가져오면 안되기 때문에 버퍼지우기
		
		System.out.print("사용중인 개발 도구는?");
		program = sc.nextLine();
		
		System.out.println(program + "을 사용중");
		
		sc.close();
	}
}
```
```
public class Ex02 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		String lang;
		int number;
		String program;
		String base;
		System.out.print("공부중인 언어: ");
		//입력: c 언어
		//출력: lang = c
		       program = 언어(\n) ->다음 base에 \n을 넘겨주지않는다.
		//띄어쓰기를 기준->next
		lang = sc.next();
		program = sc.next(); 
		//base = sc.next();
		System.out.println("lang = " + lang); 
		System.out.println("program = " + program);
		//System.out.println("base = " + base);
	}
}
```
```
public class quiz02 {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		String name;
		String address;
		double height;
		String phone;
		int age;
		
		System.out.print("이름을 입력: ");
		name = sc.next();  //\n을 던지지만 next자료형은 읽지않음. nextLine은 읽기때문에 버퍼로 지워야함
		System.out.print("나이 입력: ");
		age = sc.nextInt();
		System.out.print("신장 입력: ");
		height = sc.nextDouble();
		sc.nextLine(); // \n 을 버린다
		System.out.print("주소 입력: ");
		address = sc.nextLine();
		System.out.print("연락처: ");
		phone=sc.next();
		
		System.out.printf("이름: %s(%d)세\n", name,age);
		System.out.printf("신장: %.1fcm\n", height);
		System.out.println("주소: "+address);
		System.out.printf("연락처: %s", phone);
	}

}

```
```
public class ex03 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n1, n2;
        n1 = sc.nextInt();
        n2 = sc.nextInt();

        String result = n1 > n2 ? "n1이 큰값" : "n2가 큰값";
    }
}
```
```
문) 입력 받은 수가 3의 배수인지 판별
package operator;

import java.util.Scanner;

public class quiz01 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int input;
		
		System.out.print("자연수 입력: ");
		input = sc.nextInt();
		
		System.out.println(input % 3 == 0 ? "3의 배수입니다" : "3의 배수가 아닙니다");
		//또는 result = (input % 3 == 0) ? n + "은 3의 배수입니다" : ~
	}
}
```
```
문) 두수를 입력받아 큰수를 출력
public class quiz02 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int input1, input2;
        System.out.println("두 수를 입력하세여: ");
        input1 = sc.nextInt();
        input2 = sc.nextInt();

        int result = input1 > input2 ? input1 : input2;
    }
}
```
```
//12345678900 같은 범위는 뒤에 L이나 l 붙여야한다.
//byte는 127부터 -128까지 근데 byte bnum = 128; 이렇게 하면 에러난다.

//long lnum = 1234;  -> 4byte가 8byte에 들어간다.

//float fnum = 3.14; 이렇게 쓰면 에러가난다.(실수형에 접미사가 없으면 3.14d 라고생각 d가 생략, 그래서 아래처럼 f를 붙여야한다.)
//float fnum = 3.14f; 실수는 기본적으로 double(8byte)에 저장이된다. 그래서 float에 저장할려니 에러 그래서 f붙임
//long = 100000000000L; int형의 범위를 벗어나면 L붙여야됨
//10f -> 10.0f
//1e3 -> e는 10의n제곱을의미 -> 1000.0(e는 실수형 접미사)
```
```
public class ex02 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int age;
		
		System.out.print("나이 입력: ");
		age = sc.nextInt();
		
		if (age>=20) {  //if문은 피라미드구조로 해야된다. 범위가 젤 많은게 밑으로
			System.out.print("성인");
		}
		else if(age >= 17) {
			System.out.print("고등학생");
		}
		else if (age >= 14) {
			System.out.print("중학생");
		}
		else {
			System.out.print("초등학생 이하");
		}
		System.out.println("입니다~");
		sc.close();    
	}

}
```
```
문)세 정수 최대값
public class quiz05 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int num1,num2,num3;
		int max;
		System.out.print("세 정수를 입력: ");
		num1 = sc.nextInt();
		num2 = sc.nextInt();
		num3 = sc.nextInt();
		
		max = num1;
		if(max < num2) {
			max = num2;
		}
		if(max <num3) {
			max = num3;
		}
		System.out.println("최대값: "+max);
	}
}

```
```
문) 자바는 강제 형변환없이 double -> int 대입불가능
    복합대입연산자는 알아서 처리해준다는 특징이 있다.

public class quiz06 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int usb;
		int gab;
		int total;
		System.out.print("usb 구매 갯수: ");
		usb = sc.nextInt();
		gab = usb * 5000;
		
		if (usb >= 100) {
			total = gab *= 0.88;  // gab * 0.88(더블) 은 안된다.자료형때문에 그래서 복합대입쓴다.
			System.out.printf("가격: %.0f원",total);
		}
		else if (usb >= 10) {
			total = (int)(gab*0.9);
			System.out.printf("가격: %.0f원",total);
		}
		else if (usb > 0) {
			System.out.println("가격: "+gab+"원");
		}
		else {
			System.out.println("잘못입력하셨습니다");
		}

	}
```
```
public class quiz07 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int station;
		int total;
		
		System.out.print("정거장 수?");
		station=sc.nextInt();
		
		if(station < 10) {
			total = station * 2; //2분씩
			System.out.println("총 소요시간: "+total+"분");
		}
		else {
			total = station * 4; //4분씩
			if (total >=60) {
				int hour=total/60;
				int min=total % 60;
				System.out.println("총 소요시간: " +hour + "시간"+min+"분");
			}
			else {
				System.out.println("총 소요시간: "+total+"분");
			}
		}
		sc.close();
	}

```
```
package _switch;   //switch(값) 값에 가능한 데이터는 정수와 문자열만 가능

import java.util.Scanner;

public class ex01 {
	public static void main(String[] args) {
		
		//switch 로 만들어진 것은 if로 만들수있지만 반대는 제약이있다.
		Scanner sc = new Scanner(System.in);
		int menu;
		System.out.print("메뉴 입력(1~3): ");
		menu = sc.nextInt();
		
		switch(menu) {  //break를 넣어야한다. 안넣고 1치면 1,2,3 메뉴 다 출력된다.
		case 1:
			System.out.println("1번 메뉴 선택~");
			break;
		case 2:
			System.out.println("2번 메뉴 선택");
			break;
		case 3:
			System.out.println("3번 메뉴 선택");
			break;
		}
		
	}
}
============================================================================
switch(menu) {
		case 1:
			System.out.println("1번 메뉴 선택~");  //이렇게 break가 없으면 1입력후 -> 1,2 출력 후 break만나서 그만 
		case 2:
			System.out.println("2번 메뉴 선택");
			break;
		case 3:
			System.out.println("3번 메뉴 선택");
			break;
		default:  //default는 가장 밑에 쓸꺼면 break 필요없다.
			System.out.println("없는 메뉴");
		}

```
```
public class ex02 {

	public static void main(String[] args) {
		//switch 문은 특정 값 하나에 대해서 처리하는데 특화
		//즉, 범위 조건 처리가 힘들다.(1~5까지는 여기타고 이런게)
		
		Scanner sc = new Scanner(System.in);
		int num;
		
		System.out.print("정수 입력(1~10): ");
		num = sc.nextInt();
		
		switch(num) {   // 5를 입력하면 5로 점프 후 break까지 
		case 1: case 3: case 5: case 7: case 9:
			System.out.println("홀수");
			break;
		case 2:
		case 4:
		case 6:
		case 8:
		case 10:
			System.out.println("짝수");
			break;
		}
	sc.close();
}
```
```
public class ex03 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String menu;
		
		System.out.println("\t1. 짜장면");
		System.out.println("\t2. 짬뽕");
		System.out.println("\t3. 볶음밥");
		System.out.println("\t4. 탕수육");
		
		System.out.print("\n>>> ");
		menu = sc.next();
		
		switch(menu) {
		case "짜장면" : case "1": 
			System.out.println("짜장면 주문");
			break;
		case "짬뽕" :
			System.out.println("짬뽕 주문");
			break;
		case "볶음밥" :
			System.out.println("볶음밥 주문");
			break;
		case "탕수육" :
			System.out.println("탕수육 주문");
			break;
		default :
			System.out.println("없는 메뉴입니다");
		}
		sc.close();
	}
}
```
```
public class ex01 {
	public static void main(String[] args) {
		// 1. while(조건식) 조건식이 참이면 실행
		
		int i = 1;
		while (i<=5) { // i가 5이하 일때까지 반복
			System.out.println(i+": Hello World!!!");
			i++;
		}  //반복종료 후 i는 6이다!!!!
	}
}
```
```
#) 0입력시 종료
package loof;

import java.util.Scanner;

public class ex02 {

	public static void main(String[] args) {
		//while의  주목적 불특정 반복
		
		Scanner sc = new Scanner(System.in);
		int n=1;
		
		while(n != 0) {
			System.out.print("정수 입력(0:종료): ");
			n = sc.nextInt();
			
			System.out.println("n = " +n+"\n");
		}
		sc.close();
	}
}
```
```
public class ex04 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n2;
		
		do {  //파이썬은 do~while문이 없다.
			System.out.print("정수 입력(0입력시 종료): ");
			n2 = sc.nextInt();
			System.out.println("n2 = "+n2+"\n");
		}while(n2 != 0);
		sc.close();
	}
}
```
```
문) 거꾸로 수 출력
int n;
while(n!=0){ // 몫이 0이면 종료
	System.out.print(n%10);
	n /= 10;
}
```
```
public class ex06 {
	public static void main(String[] args) {
		//for문 : 특정횟수, 배열의 반복에 특화
		for (int i =1; i<=5; i++) {
			System.out.print(i+" ");
		} //i는 for문에서 만들어진 지역변수다. 그래서 밖에서 i출력하면 안나온다. 
	}
}
```
```
public class quiz01 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n, fac =1;
		System.out.print("팩토리얼: ");
		n = sc.nextInt();
		for(int i =1; i<=n; i++) {
			fac *= i;
		}
		System.out.println(n+"!="+fac);
		sc.close();
	}
}
```
```
****
 ***
  **
   *
package basic;

import java.util.Scanner;

public class Ex02 {

	public static void main(String[] args) {
		for(int i = 0; i < 4; i++) {
			for(int k = 0; k < i; k++) {
				System.out.print(" ");
			}
			for(int j = 4-i; j > 0; j--) {
				System.out.print("*");
			}
		System.out.println();
		}	
	}
}
```
```
*   * (i=0, j=0 j=4)일때
 * *  (i=1, j=1 j=3)일때
  *   (i=2, j=3)
 * *  (i=3, j=1  j=3)일때
*   * (i=4, j=0  j=4)일때
for(int i = 0; i<5; i++) {
			for(int j=0; j<5; j++) {
				if(i==j || i+j == 4)
					System.out.print("*");
				else
					System.out.print(" ");
			}	
			System.out.println();
		}
```
```
***** (i=0, j=0,1,2,3,4)
   *  (i=1, j=3)
  *   (i=2, j=2)
 *    (i=3, j=1)
***** (i=4, j=0,1,2,3,4)
for(int i = 0; i<5; i++) {
			for(int j=0; j<5; j++) {
				if(i==0 || i+j == 4 || i==4)
					System.out.print("*");
				else
					System.out.print(" ");
			}	
			System.out.println();
}
```
```
	*	  (i=0, j=4)
   * *    (i=1, j=3 j=5)
  *****   (i=2, j=2,3,4,5,6)
 *     *  (i=3, j=1 j=7)
*       * (i=4, j=0 j=8)
for(int i = 0; i<5; i++) {
			for(int j=0; j<4-i; j++) {
					System.out.print(" "); //0,1,2,3까지 공백찍고 (앞에는공백 미리 다찍고)
			}
			for(int j=0; j<=i*2; j++) { //4에 별찍고(여기서는 0)
				if (j==0 || j==i*2 || i ==2){ //i가 2이면 다찍고 즉, 중앙에는 다 찍고
					System.out.print("*");
				}
				else
					System.out.print(" ");
				}
			System.out.println();
	}
```
```
public class 개 {
	void 먹기() {
		System.out.println("개 같이 먹는다");
	}
	void 소리내기() {
		System.out.println("개 소리 낸다");
	}
	void 움직이기() {
		System.out.println("개 같이 움직인다");
	}
	void 개만가지는기능() {
		System.out.println("개 기능");
	}
}
---------------
public class 고양이 {
	void 먹기() {
		System.out.println("고양이 같이 먹는다");
	}
	void 소리내기() {
		System.out.println("고양이 소리 낸다");
	}
	void 움직이기() {
		System.out.println("고양이 같이 움직인다");
	}
	void 개만가지는기능() {
		System.out.println("고양이 기능");
	}
}
-----------------
public class Main {
	개 dog = new 개();
	dog.움직이기();
	...
	
	고양이 cat = new 고양이();
	cat.움직이기();
	...
	
	//이렇게하면 class에서도 공통적으로 들어가는 게 많아서 비효율적 -> 추상화로 
}
```
```
//우리가 동물 그 자체가 먹는 소리, 움직이는거 소리내는거(공통적인부분들) 명확하게 정의 할 수가 없다. -> 상속받은 애들이 알아서구현해라 
public class Main {
	개 dog = new 개();
	dog.움직이기();
	...
	
	고양이 cat = new 고양이();
	cat.움직이기();
	...
	
	//다형성이용
	동물[] ani = new 동물[] { dog, cat}; //부모로 업캐스팅
	for(int i = 0; i<ani.length; i++) {
		ani[i].먹기();
		ani[i].소리내기();
		ani[i].움직이기();
		//개만가지는기능, 고양이만 가지는 기능은 쓸수없다.->다운캐스팅
		if(ani[i] instanceof 개) {
			개 tmp = (개)api[i];
			tmp.개만가지는기능();
		}
	}
}
----------------
public class 개 extends 동물{
	@Override
	void 먹기() {
		System.out.println("개 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("개 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("개 같이 움직인다");
	}
	void 개만가지는기능() {
		System.out.println("개 기능");
	}
}
---------------
public class 고양이 extends 동물{
	@Override
	void 먹기() {
		System.out.println("고양이 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("고양이 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("고양이 같이 움직인다");
	}
	void 개만가지는기능() {
		System.out.println("고양이 기능");
	}
}
------------------
public class 동물 {
	void 먹기() {}
	void 소리내기() {}
	void 움직이기() {}
}

```
```
public class Main {
	개 ob1 = new 개();
	고양이 ob2 = new 고양이();
	고래 ob3 = new 고래();
	상어 ob4 = new 상어();
	펭귄 ob5 = new 펭귄();
	독수리 ob6 = new 독수리();
	
	포유류[] 포 = new 포유류[] {ob1,ob2,ob3};
	어류 어 = ob4;
	조류[] 조 = new 조류[] {ob5,ob6};
	
	//다형성이용(동물에는 다 속하니까)
	동물[] ani = new 동물[] { ob1, ob2,ob3,ob4,ob5,ob6};
	//또는
	동물[] ani2 = new 동물[] {포[0], 포[1], 포[2], 어, 조[0], 조[1]};
	
	for(int i = 0; i<ani.length; i++) {
		ani[i].먹기(); //자식요소쓸려면 다운캐스팅
		ani[i].소리내기();
		ani[i].움직이기();
		//개만가지는기능, 고양이만 가지는 기능은 쓸수없다.->다운캐스팅
		if(ani[i] instanceof 개) {
			개 tmp = (개)api[i];
			tmp.개만가지는기능();
		}
	}
}
----------------
public class 개 extends 포유류{ //동물 + 포유류의 추상메서드를 구현해야한다. 만약에 포유류에서 추상메서드가 정의되있으면 @Override안해도된다.
	@Override
	void 먹기() {
		System.out.println("개 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("개 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("개 같이 움직인다");
	}
	void 개만가지는기능() {
		System.out.println("개 기능");
	}
	//이렇게 해도되고 아니면 포유류 class에서 포유류특징 메서드를 정의하면 된다.
	@Override
	void 포유류특징() {
		
	}
}
--------------
public class 고양이 extends 포유류{
	@Override
	void 먹기() {
		System.out.println("고양이 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("고양이 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("고양이 같이 움직인다");
	}
	void 고양이만가지는기능() {
		System.out.println("고양이 기능");
	}
}
-------------
public class 고래 extends 포유류{
	@Override
	void 먹기() {
		System.out.println("고래 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("고래 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("고래 같이 움직인다");
	}
	void 고래만가지는기능() {
		System.out.println("고래 기능");
	}
}
----------------
public class 독수리 extends 조류{
	@Override
	void 먹기() {
		System.out.println("독수리 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("독수리 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("독수리 같이 움직인다");
	}
	void 독수리만가지는기능() {
		System.out.println("독수리 기능");
	}
}
---------------------
public class 상어 extends 어류{
	@Override
	void 먹기() {
		System.out.println("상어 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("상어 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("상어 같이 움직인다");
	}
	void 상어만가지는기능() {
		System.out.println("상어 기능");
	}
}
-------------------------
public class 펭귄 extends 조류 implements 물생활{
	@Override
	void 먹기() {
		System.out.println("펭귄 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("펭귄 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("펭귄 같이 움직인다");
	}
	void 펭귄만가지는기능() {
		System.out.println("펭귄 기능");
	}
	public void 물에서동작() {
		System.out.println("펭귄이 물에서 생활");
	}
}
----------------------------
public abstract class 조류 extends 동물{ 
	void 조류특징() {
		System.out.println("날개짓을 한다.");
	}
}
----------------------------
public abstract class 포유류 extends 동물{
	abstract void 포유류특징();
	//void 포유류특징() {  //이렇게하면 Override안해도된다.
	//	System.out.println("새끼를 낳는다");
	//}
}
------------------------------
public abstract class 어류 extends 동물{
	void 어류특징() {
		System.out.println("물에서 산다");
	}
}
//하지만 동물자체는 객체를 생성하면 안된다. 동물이라는 객체는 세상에 없다. 동물의 특성을 가지는 애들이 있을뿐이지.(개,고양이 등)
public abstract class 동물 {
	abstract void 먹기(); //동물이 어떻게 먹는지 모르기때문에 추상메서드
	abstract void 소리내기();
	abstract void 움직이기();
}
------------------
또 보니까 물생활은 따로 묶어도되겠네? -> interface로 제공 
public interface 물생활 {
	public abstract void 물에서동작();
}

그러면 main에서
//서로관련은 없지만 묶을 수 있다.
물생활[] 물 = new 물생활[] {
	ob3,ob4,ob5
};
for(int i = 0; i<물.length; i++) {
	물[i].물에서동작();
}
```
```
객체지향프로그래밍의 반대 개념으로는, 절차적프로그래밍이 있다.
즉, 함수를 이용해서 정리정돈하는 프로그래밍 기법이다. C언어

즉, 함수를 이용해서 작은 부픔을 만들고 이것을 결합해서 더큰 프로그램을 만들어가는 것

하지만 복잡한 어플리케이션을 위해서는 실제세계처럼 더 밀접한 모델링 방식이 필요했다.

그래서 서로연관된함수, 변수를 모아서 정리정돈한게 class이다.
이런 클래스 중심으로 프로그램의 구조를 만들어가는 프로그래밍 방법론이 객체지향프로그래밍이다.

```
```
#)추상화
- 보통알고는 있지만 정확하게 표현하기 힘든것들을 중요한부분이나 특징점을 잡아 설명하는 것을
"추상적으로 표현한다, 추상화한다" 라고 말하는것이다.

- 객체지향프로그래밍의 추상화는 크게 두가지로 나뉘는데
1. 객체의 관련 속멍만 표시 - 데이터 추상화
2. 불필요한 세부정보는 숨긴다 - 제어 추상화
```
```
#)제어추상화
- 어떤 클래스의 메소드를 사용하는 사용자에게 해당 메소드의 작동방식과 같은 내부로직을 숨기는 것이다

예를들어 소비자가 자동차를 운전할 때 시동,정지 이러한 동작만 쓸수있으면 되지,
실제 거기에 대한 프로세스를 알필요가 없다.

핵심은 보다 프로그래밍을 빠르게 설계하고 구현하기 위해 추상화를 사용하는 것이다.

실제 자바에서 달력 클래스를 보면
CountryCalendar.getInstance("countryName") 이렇게쓰는데

사용자는 getInstance 메서드가 내부에서 어떤로직으로 각 나라의 달력을 구분해 계산하는지
알필요가 없이 결과값만 얻으면 된다.

즉, 메서드만 쓰면 되는것이라는 것이다.
즉, 구체적이지 않고 추상적으로 메서드 동작을 가늠해 결과값만 받고 끝낸다라는 뜻
실제 우리가 많이 쓰는 for, while 도 제어추상화한것이라 볼수있다.
```
```
#)데이터 추상화
대상을 간단한 개념으로 일반화하는 과정

삼각형,사각형,원이라는 객체가 있을때, 이 객체들을 하나로 묶을 때 객체들의 공통특징인
도형으로 묶어 이름을 붙이는 것을 데이터 추상화라고 보면된다.

이처럼 추상화를 하면 할 수록 객체의 디테일함이 사라지고 공통된 특징만 남게된다.

예를들어 아이폰 객체를 추상화를 통해 객체정보를 분리할 때
아이폰 -> 휴대폰 -> 통신기기 -> 전자제품으로 추상화가 이어질수있다.


abstract class 전자제품 {
}

abstract class 통신기기 {
}

abstract class 휴대폰 {
}

class 아이폰 {
}


그리고 이렇게 추상화한 상위요소부터 각 요소에 맞는 기능들을 정의한다.
전자제품은 전원기능을, 통신기기는 통화기능, 휴대폰은 카메라,게임기능, 아이폰은 애플앱을
이용 할 수 있는 연동기능을 요소마다 속성을 배치한다.

그리고 마지막으로 상위요소가 가진 내용들을 가질 수 있도록 상속관계를 설정하여 이어준다.

이렇게 공통된 기능들은 상위요소에서 미리 구현하기 때문에 아이폰을 만들 때 아이폰만의 고유기능
위주로 개발할 수 있게된다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/1.PNG" width="650" height="300" /><br><br>
```
abstract class 전자제품 {
    전원기능();
}

abstract class 통신기기 extends 전자제품 {
    통화기능();
}

abstract class 휴대폰 extends 통신기기 {
    카메라기능();
    게임기능();
}

class 아이폰 extends 휴대폰 {
    전원기능() { ... }
    통화기능() { ... }
    카메라기능() { ... }
    게임기능() { ... }
    애플 제품 연동기능() { ... }
}
// → 최종적으로 아이폰 class는 전원, 통화, 카메라, 게임, 애플 연동 5가지 기능을 정의하여 설계된다
```
```
아이폰 제품하나만 만들때는 비효율적으로 보일수있지만 제품종류가 늘어날 수록 장점으로 작용된다.

공통 기능을 미리 개발해두면, 기능 상속을 통해 빠르게 구조를 확장 할 수 있기 때문이다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/2.PNG" width="650" height="300" /><br><br>

```
#)상속
- 위의 아이폰 예시에서 추상개념(abstract)들을 서로이었는데(extends) 이것이 바로 상속이다.

즉, 그대로 물려받는것이다.
// super 클래스
class Parent {
    String name;
    String age;
    
    public void say() {
    	System.out.println(name + age);
    }
    
}

// sub 클래스 (상속 받음)
class Child extend Parent{
	String hair;
    
    public void myHair() {
    	System.out.println(hair);
    }
    
}

// 상속받은 자식클래스는 부모클래스의 속성들을 이용이 가능하다.
Child c = new Child();
c.name = "풍성한";
c.age = 17;
c.say();
c.hair = "M자형.."
c.myHair();
```
```
상속기능을 이용하게 되면, 상위클래스의 특징을 하위클래스에서 상속받아 코드의 중복제거,코드재사용
효과도 있다.

//아래는 상속을 쓰지않았을 때다.
class Dog {
    int teethCount; // 중복된 속성들
    int legCount; // 중복된 속성들
    int tailCount; // 중복된 속성들
    void bark();
}

class Cat {
    int teethCount; // 중복된 속성들
    int legCount; // 중복된 속성들
    int tailCount; // 중복된 속성들
    void meow();
}

class Lion {
    int teethCount; // 중복된 속성들
    int legCount; // 중복된 속성들
    int tailCount; // 중복된 속성들
    void roar();
}
```
```
//상속을 통한 코드절약
class Animal {
    int teethCount; 
    int legCount; 
    int tailCount; 
}

class Dog extends Animal { // 상속을 통해 중복 코드를 제거
    void bark();
}

class Cat extends Animal { // 상속을 통해 중복 코드를 제거
    void meow();
}

class Lion extends Animal { // 상속을 통해 중복 코드를 제거
    void roar();
}
```
```
#)다형성
같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질
자바에선 대표적으로 오버로딩, 오버라이딩,업캐스팅, 다운캐스팅,인터페이스,추상메소드,추상클래스 
방법모두 다형성에 속한다고 생각하면된다.

즉, 다형성은 클래스가 상속관계에 있을 때 나타나는 다채로운 성질인 것이다.

예를들어 일반 TV클래스와 SmartTv 클래스가 상속관계를 맺었다고 가정하자

TV클래스에는 전원,볼륨,채널 켜기/끄기 기능 밖에 없고, 스마트 TV클래스에는 기본 TV동작 메서드를
상속하고 추가적으로 AI기능과 쇼핑기능이 있다.

class TV {
    void powerOn_Off() {} //전원 켜기/끄기
    void volumeOn_Off() {} //볼륨 켜기/끄기
    void channelOn_Off() {} //채널 돌리기
}

class SmartTV extends TV {
    void AI_Assistance() {} //인공지능 기능
    void shopping() {} //쇼핑하기
}

//여기서 보통우리는 일반적으로 동일한 클래스 타입의 참조변수를 생성해 초기화하여 사용해왔었다.
TV tv_remotecontrol = new TV();
SmartTV smart_remotecontrol = new SmartTV();


//그렇지만 만일 부모 자식 상속관계에 있으면 다음과 같이 부모타입으로 자식클래스타입을 받아
초기화 할 수 있다.

TV tv_remoteControl = new SmartTV();
//SmartTV의 인스턴스를 생성하고, 이 인스턴스의 주소값을 참조변수 remoteControl에 대입한다.
//마치 일반TV 리모콘으로 스마트티비를 사용할수있다. poweronoff,volumn,channel
//하지만 스마트 TV의 기능은 쇼핑하기,인공지능 기능은 안된다!!!!!!!!
```

```
#)upcasting, downcasting
기본형 타입을 서로 형변환 할 수 있듯이, 자바의 상속관계에 있는 부모와 자식클래스 간에는
서로간의 형변환이 가능하다.
클래스는 reference타입으로 분류되니 이를 참조형캐스팅이라고 불린다.

class Parent {
	String name;
    int age;
}

class Child extends Parent {
	/*
    String name;
    int age;
    */
	int number;
}

Parent p = new Parent(); 
Child c = new Child();

Child c = new Parent(); //에러가난다. c.name = "dd" 
 
 //이클립스 에디터에는 에러가 안나지만 실행하면 에러가난다.
chile c = (Child) new Parent;

Parent p2 = (Parent)c; // 업캐스팅 - 자식에서 부모로
Child c2 = (Child)p2; // 다운캐스팅 - 부모에서 자식으로
```
```
다운캐스팅은 괄호를 생략할 수 없다.
다운캐스팅의 진정한 의미는 부모클래스로 업 캐스팅된 자식클래스를 복구하는 것이다.
즉, 원래있던 기능을 찾겠다는 의미

//원래 부모인애를 다운캐스팅하면 당연히 안된다. (에디터에는 에러가 안뜸)		
Parent p1 = new Parent();
Child c1 = (Child)p1;

//그럼 다운캐스팅이 되냐??
//원래의 값이 중요하다 - 자식이 원래의 값이여야된다. 자식 -> (업) -> 부모 -> (다운) -> 자식
//원래의 값이 부모이면 - 부모 -> (다운) -> ? 어디로가야하오
Child c = new Child();
Parent p = (Parent)c;
c = (Child)p;
c.name="dd";

```
```
#) 아래는 위와 비슷해보이지만 된다.
원래의 값이 중요하다.

class Unit {
    public void attack() {
        System.out.println("유닛 공격");
    }
}

class Zealot extends Unit {
    public void attack() {
        System.out.println("찌르기");
    }

    public void teleportation() {
        System.out.println("프로토스 워프");
    }
}

public class ByteLegth {

	public static void main(String[] args) throws UnsupportedEncodingException {
		String a = "!@#$^&*()_+#'-=";
		a = URLDecoder.decode(a, "UTF-8");
		System.out.println(a);
		
		Unit unit_up;
        Zealot zealot = new Zealot();

        unit_up = zealot; // 업캐스팅(new로 만든게 원래의값이다. 본질)

        //원래는 여기서 다운캐스팅할때 에러가나는데 new로 만든게 본질이라서 가능
        Zealot unit_down = (Zealot) unit_up; // 캐스팅 연산자는 생략 불가능. 반드시 기재
        unit_down.attack(); // "찌르기"
        unit_down.teleportation(); // "프로토스 워프"
		
	}
}
```



```
이러한 참조형 캐스팅의 대표적인 ArrayList 자료형의 선언문을 볼 수있다
이것도 업캐스팅이다.
업캐스팅은 캐스팅 연산자 괄호를 생략할 수 있다.
업캐스팅을하고 메소드를 실행할 때, 만일 자식 클래스에서 오버라이딩한 메서드가 있을 경우,
부모클래스의 메서드가 아닌 오버라이딩된 메서드가 실행되게 된다.

List<int> l = new ArrayList()<>;
```
```
class Unit {
    public void attack() {
        System.out.println("유닛 공격");
    }
}

class Zealot extends Unit {
    public void attack() {
        System.out.println("찌르기");
    }

    public void teleportation() {
        System.out.println("프로토스 워프");
    }
}

public class Main {
    public static void main(String[] args) {
    
        Unit unit_up;
        Zealot zealot = new Zealot();
        
        // * 업캐스팅(upcasting)
		unit_up = (Unit) zealot;
		unit_up = zealot; // 업캐스팅은 형변환 괄호 생략 가능
    }
}
```
```
#)업캐스팅 멤버제한
부모를 상속해서 멤버가 많은 자식 클래스에서 부모클래스로 업캐스팅했으니 당연히 멤버갯수가 감소한다.
이는 실행할 수 있는 속성과 메서드가 제한된다는 뜻이다.
근데, 부모에 attack함수가있고 자식에도 attack함수가 오버라이딩되있으면 쓸수있다.
단, 자식에만 attack이 있으면 못쓴다.
```
```
#) 그럼 반대상황을 보자
SmartTV smart_remotecontrol = new TV(); 
즉, 스마트티비 리모콘으로 일반TV를 다루는 것이다.

그런데 만일 스마트티비에서만 가능한 버튼을 누르면 어떻게될까??
일반티비에는 해당 메서드(스마트티비메소드)가 없기 때문에 수신하면 오류를 일으킬것이다.

근데 이렇게 오류를 일으켜서 망가지면 서비스센터가 터질것이니까

그냥 스마트 TV리모콘으로는 일반 TV를 다루지 못하게 원천차단하는 것이 효율적이다.

따라서 개발자의 부주의로 인한 프로그램에러를 원천차단하기 위해서 일반적으로 자바에서는
아래 코드는 옳지 않다하여 에러가 나오게된다.

public class Main2 {
    public static void main(String[] args) {
        TV remoteControl = new SmartTV(); //이거는 정상

        SmartTV smart_remoteControl = new TV() //빨간불이뜬다.
    }
}


하지만 아무리 생각해도 스마트 TV 리모콘으로 일반TV를 아예 못다룬다는 것은 뭔가 불만이다.
안그러면 일반리모콘을 사야되기 때문이다.

그게 업,다운케스팅이다.

```

```
#)자료형 다형성

TV tv = new SmartTV() //이렇게 쓰는 것이 다형성인데 왜 쓰는 걸까?
핵심은 '타입묶음"이다.

//아래는 다형성을 안썻을때다.
그래서 뭔가 계속 반복되는 느낌이 있다.
class Rectangle {
}

class Triangle {
}

class Circle {
}

ArrayList<Rectangle> rectangles = new ArrayList<>();
rectangles.add(new Rectangle(1,2,3,4));
rectangles.add(new Rectangle(10,20,30,40));
rectangles.forEach(each -> System.out.println(each));

ArrayList<Triangle> triangles = new ArrayList<>();
triangles.add(new Triangle(1,2,3));
triangles.add(new Triangle(10,20,30));
triangles.forEach(each -> System.out.println(each));

ArrayList<Circle> circles = new ArrayList<>();
circles.add(new Circle());
circles.add(new Circle());
circles.forEach(each -> System.out.println(each));

```

```
#) 다형성 사용
shape라는 자료형으로 묶어 코드를 압축
class Shape {
}

class Rectangle extends Shape {
}

class Triangle extends Shape {
}

class Circle extends Shape {
}

ArrayList<Shape> shapes = new ArrayList<>();
shapes.add(new Rectangle(1,2,3,4));
shapes.add(new Rectangle(10,20,30,40));
shapes.add(new Triangle(1,2,3));
shapes.add(new Triangle(10,20,30));
shapes.add(new Circle());
shapes.add(new Circle());
shapes.forEach(each -> System.out.println(each));

만일 각 자식클래스에서 특수한 전용 메서드를 사용해야한다고 하면
오버라이딩을 통해하거나, 따로 그 요소만 빼서 다운캐스팅을 시켜 메서드 실행해주면된다.
```

```
#) 매개변수로 다형성을 사용하지 않은 예

bark메서드에 매개변수로 새로운 객체 타입을 전달 
class Tiger {
    String lang = "어흥";
}

class Lion {
    String lang = "으르렁";
}

class Dog {
    String lang = "멍멍";
}

class Bark {
	// 메소드 오버로딩
    void bark(Tiger tiger) {
        System.out.println(tiger.lang);
    }

    void bark(Lion lion) {
        System.out.println(lion.lang);
    }

    void bark(Dog dog) {
        System.out.println(dog.lang);
    }
}

public class Main2 {
    public static void main(String[] args) {

        Tiger tiger = new Tiger();
        Lion lion = new Lion();
        Dog dog = new Dog();

        Bark command = new Bark();
        command.bark(tiger); // 어흥
        command.bark(lion); // 으르렁
        command.bark(dog); // 멍멍
    }
}

//해당방법의 문제점은 Cat클래스가 추가되면 class Bark에 또 메소드 cat을 추가, 삭제도 마찬가지
그래서 번거롭다.
```

```
#) 그래서 Animal 인터페이스를 셍성하고 각 클래스마다 인터페이스를 구현하도록 하면된다.

interface Animal {
    void start();
}

class Tiger implements Animal {
    String lang = "어흥";

    public void start() {
        System.out.println(this.lang);
    }
}

class Lion implements Animal {
    String lang = "으르렁";

    public void start() {
        System.out.println(this.lang);
    }
}

class Dog implements Animal {
    String lang = "멍멍";

    public void start() {
        System.out.println(this.lang);
    }
}

class Bark {
    void bark(Animal animal) {
        animal.start();
    }
}

public class Main2 {
    public static void main(String[] args) {

        Tiger tiger = new Tiger();
        Lion lion = new Lion();
        Dog dog = new Dog();

        Bark command = new Bark();
        command.bark(tiger); // 어흥
        command.bark(lion); // 으르렁
        command.bark(dog); // 멍멍
    }
}
```

```
꼭 객체 타입관점에서 뿐만 아니라 메서드를 확장하거나 재정의하는 오버로딩,오버라이딩도 메소드가
다형해지기 때문에 자바의 다형성 특징 중 하나에 속한다고 볼 수 있다.

class Parent {
	// 오버로딩
	public void print(int value) {
		System.out.println("숫자 출력 = " + value);
	}
   	// 오버로딩
	public void print(String value) {
		System.out.println("문자 출력 = " + value);
	}
    
    public void add(int x, int y) {
		System.out.println(x + y);
	}
}

class Child extends Parent {
	// 오버라이딩
	public void add(int x, int y) {
		System.out.println((x + y) * 2);
	}
}

class Main{
	public void main(String[]args) {
		Parent p = new Parent();
        p.print(100);     // 결과 : 숫자 출력 = 100 (오버로딩)
		p.print("test");   // 결과 : 문자 출력 = "test" (오버로딩)
        p.add(1,2); // 결과 : 3
        
        Parent p2 = new Child();
        p2.add(1,2); // 결과 : 6 (오버라이딩)
	}
}
```

```
class Time {
    private int hour; // hour는 외부에서 접근하지 못하게private으로 선언한다.
	
    // Setter
    public void setHour(int hour) {
        if (hour < 0 || hour > 24) { // hour에 대한 유효성 검사
            return;
        } else {
            this.hour = hour;
        }
    }
	
    // Getter
    public int getHour() {
        return hour;
    }
}

public class Main {
    public static void main(String[] args) {
        MyTime time = new MyTime();
        
        // 유효하지 않은 parameter 입력
        time.setHour(25); 
        System.out.println("Hour: " + time.getHour()); // 0
		
        // 유효한 parameter 입력
        time.setHour(13); 
        System.out.println("Hour: " + time.getHour()); // 13
    } 
}

위의 코드는 시간을 메서드로 입력받고, 출력하는 아주 간단한 캡슐화 예제이다.
여기서 클래스의 hour 멤버변수는 private로 선언함으로써 다른클래스에서의 접근을 제한해 두었다.

그리고 private hour 변수를 다루기 위해서는 setter, getter의 호출을 통해서만 가능하다.
```

<h3>String 의 특징</h3>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/3.PNG" width="650" height="300" /><br><br>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/4.PNG" width="650" height="300" /><br><br>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/5.PNG" width="650" height="300" /><br><br>

```
#)그렇다면 왜 불변으로 설계되었을까

첫번째는 JVM(자바 가싱 머신) 에서는 따로 String Constant Pool 이라는 독립적인 영역을 만들고 문자열들을 Constant 화 하여 다른 변수 혹은 객체들과 공유하게 되는데, 이 과정에서 데이터 캐싱이 일어나고 그 만큼 성능적 이득을 취할 수 있기 때문이다.


두번째는 데이터가 불변(immutable) 하다면 Multi-Thread 환경에서 동기화 문제가 발생하지 않기 때문에 더욱 safe 한 결과를 낼 수 있기 때문이다.


세번째는 보안(Security) 적인 측면을 들 수 있다.
예를 들어 데이터베이스 사용자 이름, 암호는 데이터베이스 연결을 수신하기 위해 문자열로 전달되는데, 만일 번지수의 문자열 값이 변경이 가능하다면 해커가 참조 값을 변경하여 애플리케이션에 보안 문제를 일으킬 수 있다.
```

```
#)자바 String 주소할당 방식
자바에서 String 변수를 선언하는 방법은 대표적으로 두가지 방식이 있다.
1. 리터럴을 이용한 방식
2. new 연산자를 이용한 방식

String str1 = "Hello" //문자열 리터럴을 이용한 방식
String str2 = "Hello"

String str3 = new String("Hello"); //new 연산자 이용
String str4 = new String("Hello");

이 둘의 차이는 뭘까??/

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/6.PNG" width="650" height="300" /><br><br>

> 여기서 봐야할 것은 문자열 리터럴 값으로 할당한 두 변수 str1,str2 이다<br>
같은 메모리 주소를 가리킨다는 것이다.

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/7.PNG" width="650" height="300" /><br><br>

---
<h3>문자열 비교, ==, equals() 차이</h3>

```
String str1 = "Hello";
String str2 = "Hello";

String str3 = new String("Hello");
String str4 = new String("Hello");

str1 == str2 (true)

str3 == str4 (false) 서로다른 주소

str3.equals(str4) //문자열비교는 이렇게해야한다

str1 == str3 //false
str3.equals(str1) //true
```
```
#)정보은닉(OOP의 핵심)
객체지향 언어적 요소를 활용하여 객체에 대한 구체적인 정보를 노출시키지 않도록 하는
기법을 칭한다.

캡슐화 == 정보은닉 보다는 정보은닉 기법중 하나가 캡슐화라는 것이다.

자바프로그램의 정보은닉기법은 대표적으로 3가지가 있다.
1. 객체의 구체적인 타입은닉(=업캐스팅)
2. 객체의 필드 및 메소드 은닉(=캡슐화)
3. 구현은닉(=인터페이스 & 추상클래스)

업캐스팅과 인터페이스 구현역시 정보은닉 측면에 포함된다.
부모클래스타입으로 통합을 하거나 인터페이스 타입을 사용하는 것 역시
구체적인 클래스 타입을 은닉함으로써 다형하게 사용할 수 있기 때문이다.

정보 은닉 이라는 단어를 보자면 무언가 정보를 은닉하여 보안적인 효과를 얻는 것 같다.
그러나 보안적인 측면 뿐만 아니라, 은닉되어 알필요가 없어 덜 알아도 되어 덜 공부하여도 간편하게 사용할 수 있게 해주는 의미도 내포한다.
우리가 자동차를 몰때 엔진이 어떻게 구동되어 바퀴가 굴러가는지 지식 필요없이 페달만 밟으면 자동차가 굴러간다.
이것이 자동차 원리 설계 정보를 은닉함으로서 경쟁사로부터 제품내부를 알지못하게 보안하는 효과도 있지만 소비자가 페달만 밟으면 작동하도록 단순화 한것도 포함한다. 이는 추상화 개념도 연결되는 대목이기도 하다.
 
객체 지향 언어를 통해 만들어진 디자인 패턴과 같이 좋은 설계를 대표 할만한 것들은, 사실 거슬러 올라기자면 정보 은닉 기법을 통해 얻는 이득을 극대화 하기 위해 만들어진 것들이다.
객체지향의 설계 원칙(SOLID)Visit Website 과 각종 객체지향 설계에 관련된 격언들도 역시 정보 은닉에 기반을 두었다고 해도 과언이 아니다.
따라서 정보 은닉 개념을 잘 알고 있다면, 그에 파생된 oop 패턴 기법들에 대해 왜 이런 패턴이 생겨났는지 그로 인해 어떠한 이득을 얻을 수 있는지 자연스럽게 이해할 수 있게 된다.
```

```
#)객체의 은닉타입(업캐스팅)
사실 자식 객체의 타입을 부모 객체의 타입으로 형변환하는 업캐스팅도 일종의 정보은닉이다
왜냐하면 구체적인 자식객체의 타입을 은닉함으로써 얻는 효과가 있기때문이다(다형성)

예를들어 아래와 같이 Rectangle클래스를 직접 정의하여 메인메소드에서 사용핟나면, 결국 이것은 Rectangle이라는 객체에 전적으로 의존하는 코드가 된다.

만일 Rectangle클래스 구성에 무슨 문제가 생기면 메인메소드도 영향을 받는다.

class Rectangle{
    public void rectangle() {
        System.out.println("rectangle");
    }
}
class Myclass {
    public void method() {
        Rectangle rectangle = new Recatangle();
        rectangle.rectangle(); //Myclass 클래스는 Rectangle 클래스에 의존적인 코드
    }
}


만약 Rectangle과 유사한 기능을 하는 객체 Square나 Triangle을 추가로 구현한다고 가정
그리고 기획이 바뀌어 Rectangle 대신 Triangle을 사용하도록 설계서가 바뀌었다고 하자
현재 상태로서는 메인메소드에 있는 초기화코드부터 메서드 사용코드를 통째로 바꿔야한다.
```

```
따라서 Rectangle, Triangle 등 클래스 타입을 하나의 타입으로 통합 할 수 있는 Shape이라는
추상클래스를 만들어 다형성의 효과를 이용해 구현해준다.
추상메소드 draw()를 구현떠넘기기

abstract class Shape { //즉, 이걸 상속받으면 아래있는걸 구현해야한다.
    //하나의 공통 메소드로 각자식 클래스 고유의 메서드동작이 실행되도록 추상화
    abstract public void draw()
}

class Rectangle extends Shape {
    //오버라이딩이랑 비슷
    public void draw() {
        rectangle();
    }
    private void rectangle() {
        System.out.println("rectangle");
    }
}

class Triangle extends Shape {
    public void draw() {
        triangle();
    }
    private void triangle() {
        System.out.println("triangle");
    }
}

public class Myclass {
    public void method() {
        Shape shape = new Rectangle();

        shape.draw();//알아서 찾아간다.
        
        이렇게하면서 생성 이후에는 Shape 클래스의 draw()메소드만을 호출함으로써,
        Rectangle클래스와 관련된 메소드 private void rectangle() 가 간접적으로
        호출된다. 결국 객체타입과 메서드를 은닉한 것이다.
    }
}
```
```
#) 이러한 은닉을 통해 얻을 수 있는 이점은
Rectangle의 생성코드(new) 이후에는 어떤 코드도 Recangle클래스에 의존하지 않는다.
Shape 클래스로 묶었으니까 Shape 클래스만 신경쓰면된다.

따라서 Rectangle 대신에 Triangle을 사용하고 싶어졌을 때에는 new Rectangle() 대신 new Triangle()을 생성하도록 변수 할당문을 수정 해주기만 하면 된다. 

그러면 그 이후의 코드들은 전혀 수정될 필요가 없다. (결국 정보 은닉의 효과로 다형성의 효과를 누리게 되는 것과 같다)


public class Myclass {
    public void method() {
        Shape shape = new Triangle(); //변수할당부분만 바꿔주면 draw를 안바꿔도된다.
        shape.draw(); //출력: triangle
    }
}
```
```
만약에 완전히 객체를 Triangle로 변경하는게 아닌 Rectangle을 사용하다가 아주 잠시 메서드를 실행하기 위해 Triangle을 사용해야 할 경우도 발생할 수 있다.

이때는 다운캐스팅(downcasting)을 통해 동적으로 기능을 교체하면된다.

즉, 이미 선언되어 있는 shape 참조 변수에 (Triangle) 캐스팅만 해주면 기능 전환도 동적으로 쉽게 할 수 있다.

public class Myclass {
    public void method() {
        Shape shape = new Rectangle();
        shape.draw();  //출력: rectangle

        //다운캐스팅을하고 메서드 실행
        ((Triangle) shape).draw(); 
    }
}

```
```
#)더욱 더 객체를 은닉해라(디자인패턴)
위의 코드도 사실 완벽한 것은 아니다.
좀더 리팩토링해줘야하는데 그게 디자인패턴이다.

다음코드는 간략하게 리팩토링 해본 디자인패턴(팩토리패턴) 코드의 예제이다.


abstract class Shape{
    abstract public void draw();
}

class Rectangle extends Shape{
    public void draw(){ 
    	rectangle();
    }   
    private void rectangle(){ 
    	System.out.println("rectangle"); 
    }
}

class Triangle extends Shape{
    public void draw(){ 
    	triangle();
    }   
    private void triangle(){ 
    	System.out.println("triangle"); 
    }
}

// Shape에 연관된 자식 객체들을 찍어내는 팩토리라는 클래스를 새로 만든다.
class ShapeFactory{
    public Shape create_R() { // 리턴 타입이 Shape
    	return new Rectangle(); 
    }
    public Shape create_T() { // 리턴 타입이 Shape
    	return new Triangle(); 
    }
}

public class Myclass {
    public void method() {
        ShapeFactory factory = new ShapeFactory();
    
        Shape shape = factory.create_T(); 

        shape.draw(); //출력: triangle
    }
}

이렇게하면 오로지 Shape 클래스와 ShapeFactory 클래스만으로 Rectangle, Triangle 클래스를 생성할 수 있게 된다.

즉, 완변히 구체적인 객체에 대한 정보 은닉을 한것이다.
```

```
또 다른 은닉 기술인 객체의 필드 & 메소드 은닉이다.

class Process {
    public void init(){}
    public void process(){}
    public void release(){}
}

동작 메소드가 모두 public 으로 지정되어있다.
이말은 외부에서 이 클래스의 객체를 사용하는 코드에 대해서는 모두 3개의
메소드에 의존하게 된다는 말이다.

이는 혹시라도 의존되어있는 Process객체를 수정하거나 제거를 하는 등의 수정이 발생했을 때, Process 클래스 자원을 사용하는 클래스에서 방대하 코드 수정을 해야한다.

또한 불필요하게 많은 수의 메소드를 노출시키되면, 호출 순서에 대해 연관관계를 유추하는데 어려움이 생기고 ,어느 메서드가 중요한지 중요도를 유추하는데 있어 어려움이 생긴다.
 
그래서 프로세스의 동작에 관한 메서드들을 모두 private화 하여 은닉시키고 work() 라는 퍼블릭 메서드를 추가해 안에다 메서드 실행을 해줌으로써 극복 할 수 있다.

class Process{
    private void init(){} // 은닉 메서드

    private void process(){} // 은닉 메서드

    private void release(){} // 은닉 메서드

    public void work(){ // 공개 메서드
        init(); // 은닉한 메서드 실행
        process();
        release();
    }
}

이를 통해 적절한 수준에서 메소드들이 공개(work)와 비공개로 나누어져 있기 때문에 어떤 메소드를 우선 살펴야 할지를 알 수 있으며, 또한 개별 메소드들의 호출 순서를 work() 메소드에서 정해주고 있기 때문에 Process 객체 사용에 대한 사용법을 적은 학습량으로 쉽게 사용이 가능해 진다.

그리고 메서드들을 은닉 함으로써 객체의 세부 내용을 덜 노출시키게 되어 보안에도 효과가 있게 된다.
 
이렇게 공개 메서드와 은닉 메서드를 구분하고 공개 메소드의 갯수를 최소화 시키는 이유가 바로 다음에 이어질 구현 은닉을 위한 설계이며 자바에서 인터페이스 라는 것을 사용하는 이유이기도 하다.
```
```
#)구현은닉(인터페이스)
위의 정보 은닉 멘토를 잘 받아들여, 변수를 private으로 선언하고 꼭 필요한 공개 메소드를 잘 구축한 좋은 클래스를 구성했다고 가정하자.

이렇게 클래스 구성을 해 놓으면 객체간에 의존성은 오직 공개 메소드에 의해서만 발생하게 된다.

그리고 이러한 공개 메소드를 은닉 메소드들과 구분하고 통합적으로 관리하기 위해서, 자바에서는 클래스와 유사하게 상속 가능한 타입이면서 구체적인 구현을 베제한 인터페이스(Interface)를 만들어 메소드 추상화를 통해 상속 시킬 공개 메서드를 통합적으로 관리하게 하였다.

이것이 왜 인터페이스(Interface)를 구현하여 추상 메소드를 정의하여 implements를 통해 재정의 규약을 설정하는, 우리가 지금까지 배우고 써먹었던 객체 지향적 프로그래밍의 이유가 바로 이것이다.

interface InterProcess {
    public void work(); // 추상 메소드
}

class Process implements InterProcess {
    private void init(){} // 은닉 메서드
    private void process(){} // 은닉 메서드
    private void release(){} // 은닉 메서드

    public void work(){ // 공개 메서드 + 메소드 구체화
        init(); 
        process();
        release();
    }
}

public class Main {
    public static void main(String[] args) {
        InterProcess c = new Process(); // 인터페이스 역시 상위 클래스 타입 처럼 이용될 수 있다
        c.work();
    }
}

인터페이스 역시 자바 참조 타입의 다형성의 원리를 그대로 이용할 수 있다.
그래서 Process 타입의 객체를 InterProcess 인터페이스 타입으로 할당 할 수 있는 것이다.

그리고 캡슐화를 통해 최소한으로 줄인 공개 메서드를 인터페이스의 추상 메소드와 연동이 되면서, Process 클래스의 기능 동작을 하는데 있어 업캐스팅으로 인한 멤버 제한과 같은 제한 요소는 없어진다.

이밖에 인터페이스를 이용하면 실질적 클래스 간의 의존 관계가 없어지면서 기능 확장에 있어 제약이 줄어들게 된다.

추가적으로 자바의 인터페이스에 대해 자세하고 확실하게 알고 싶다면 다음 포스팅을 참고하길 바란다.

```

```
인터페이스는 추상화와 상속과 더불어 다형성이라는 객체지향의 특징을 구현하는 핵심이다.

객체의 인스턴스 메소드를 이용하는 사용자 입장에서 그 객체의 내부 구현이 어떻든 깊이
학습할 필요없이 원하는 메서드만 호출하고 결과값을 받게 해주는 간편한 상호작용기능이다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/8.PNG" width="650" height="400" /><br><br>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/9.PNG" width="650" height="400" /><br><br>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/10.PNG" width="650" height="400" /><br><br>


```
#)인터페이스 일부구현일때
만일 클래스가 구현하는 인터페이스의 메서드중 일부만 구현한다면 abstract를 붙여서
추상클래스로 선언해야한다.

어찌보면 당연한게 인터페이스의 추상 메서드 멤버를 그대로 상속받기 때문에,
인터페이스를 상속한 클래스에서 메서드 구현을 안한다면,
곧 추상메서드를 가진 추상 클래스가 되기 때문이다.

interface Animal {
    void walk();
    void run();
    void breed();
}

//Animal 인터페이스를 일부만 구현하는 포유류 추상클래스
abstract class Mammamia implements Animal {
    public void walk() { ... }
    public void run() { ... }

    // public void breed() 는 자식 클래스에서 구체적으로 구현하도록 일부로 구현하지 않음 (추상 메서드로 처리)
}

class Lion extends Mammalia {
    @Override
    public void breed() { ... }
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/11.PNG" width="650" height="400" /><br><br>


```
interface Changeable {
    //채널을 바꾸는 기능의 메서드
    void change();
}

interface Powerable {
    //전원을 껐다 켰다 하는 메서드
    void power(boolean b)
};


//채널기능과 전원기능을 가진 인터페이스들을 하나의 인터페이스로 통합 상속
interface Controlable extends Changeable, Powerable {
    //인터페이스끼리 다중 상속하면 그대로 추상 멤버들을 물려받음
}

//클래스에 통합된 인터페이스를 그대로 상속
class MyObject implements Controlable {
    public void change() {
        System.out.println("채널을 바꾸는 기능");
    }
    public void power(boolean b) {
        System.out.println("전원을 껐다 켰다 하는 기능");
    }
}

public class Main {
    public static void main(String[] args) {
        //인터페이스 다형성(인터페이스를 타입으로 취급해서 업캐스팅가능)
        Controlable[] o = {new MyObject(), new MyObject()};
        o[0].change();
        o[0].power(true);

        // 각각 단일 인터페이스로도 타입으로 사용이 가능하다. (그러나 지니고 있는 추상 메서드만 사용이 가능하다)
        Changeable inter1 = new Changeable();
        inter1.change(); 

        Powerable inter2 = new Powerable();
        inter2.power(true);
    }
}
```
```
[info]
[인터페이스의 extends는 상속이 아니다]
인터페이스는 하나의 타입이나 규격일 뿐이지 그 자체가 하나의 객체가 되는 것이 아니다. 따라서 엄밀히 말하자면, 인터페이스의 상속은 클래스의 상속처럼 부모의 속성과 동작을 물려받는 것이 아니다. 
정확히 말하면, 인터페이스의 상속은 규격이나 스펙 자체 혹은 기능 자체의 선언을 물려받은 것이다. 규격이나 스펙을 물려받아서 새로운 스펙을 만든다면 기존 여러 개의 스펙을 조합해서 하나로 묶거나 기존의 스펙을 고스란히 물려받은 후에 다시 추가적인 기능을 가지게 하는 것이다.
```

```
#) 인터페이스 상수 필드 상속관계
클래스의 상속일 경우 클래스 필드 멤버끼리 상속되어 덮어씌워지지만,
인터페이스의 필드들은 모두 public static final 이기에, 서로 상속을 해도 독립적으로 운용


interface Iflower {
    int ex = 10; //앞에 public static final 생략 
}
interface IPlant extends Iflower {
    int ex = 20; //앞에 public static final 생략
}

class Tulip implements IPlant {
    int ex = 30; //그냥 인스턴스 변수
}

public class Main {
	public static void main(String[] args) {
        // 클래스 타입 객체로 ex 멤버에 접근하면, 클래스 인스턴스 변수로 접근
        Tulip t =  new Tulip();
        System.out.println(t.ex); // 30

        // 인터페이스 타입 객체로 멤버에 접근하면, 인터페이스 static 상수로 접근
        Iflower a = new Tulip();
        System.out.println(a.ex); // 10 - 좋지않은 방법
        System.out.println(Iflower.ex); // 10 - 클래스 static 처럼 '인터페이스.멤버' 로 접근

        IPlant b = new Tulip();
        System.out.println(b.ex); // 20 - 좋지않은 방법
        System.out.println(IPlant.ex); // 20 - 클래스 static 처럼 '인터페이스.멤버' 로 접근
    }
}
```
```
#)default 메서드
등장이유: 기존 인터페이스에 추상메서드를 추가해버리면, implements 시에 하나더 구현해야하므로 모든 클래스에 수정이 필요해지기때문에 추상메서드 대신에 디폴트메서드를
추가하여 해결했다고 보면된다.

- 디폴트 메서드는 앞에 키워드 default를 붙이며 구현부(몸체)가 있어야한다.
- 디폴트 메서드 역시 접근제어저가 public 이며 생략가능
- 자식클래스(구현체)에서 default 메소드를 오버라이딩하여 재정의 가능
- 보통 인터페이스를 구현한 이후, 수정과정에서 인터페이스 모든 구현체에게 수정 없이 광역으로 함수를 만들어주고 싶을 때 사용된다. (대신 모든 구현체가 원하는 값을 return 하게 보장하기 위해 @implSpec 자바 doc 태그를 사용해 문서화 해줘야 한다)
-주의해야할점은 인터페이스는 Object 클래스를 상속받지 않기 때문에, Object클래스가
제공하는 (equals,hashCode 등)는 따로 직접 정의해야한다.

interface Calculator {
    int plus(int i, int j);
    int multiple(int i, int j);

    //default로 선언함으로 메소드를 구현할 수 있다.
    default int sub(int i, int j) {
        return i-j;
    }
}

// Calculator인터페이스를 구현한 MyCalculator클래스
class MyCalculator implements Calculator {
    // 추상 메서드만 구현해줌
    @Override
    public int plus(int i, int j) { return i + j; }
    @Override
    public int multiple(int i, int j) { return i * j; }
}

public class Main {
    public static void main(String[] args){
        MyCalculator mycal = new MyCalculator();
        
        // 인터페이스 타입으로 업캐스팅
        Calculator cal = (Calculator) mycal; // 괄호 생략해도 됨

        // 인스턴스의 인터페이스 디폴트 메서드 호출
        int value = cal.sub(5, 10);
        System.out.println(value); // -5
    }
}

#)Tip
인터페이스의 디폴트 메서드를 호출하기 위해선, 객체의 타입이 반드시 인터페이스 타입으로
업캐스팅해야한다!!!
```
```
#) @implSpec 어노테이션
위에처럼 default method를 interface단에서 생성하는 것은 구현체모르게
추가기능을 만드는 것이기때문에 컴파일 에러가 아니더라도 런타임에러가 발생할 수 있는
리스크가 존재한다.

이러한 리스크를 조금이나마 감소시키기 위해 문서화작업이 필요하고
이때, 사용되는 어노테이션이 @implSpec

public interface CommonInterface{
	// 기존 요청사항에 따른 선언부
	void getName();

	/**
	* @implSpec name변수로 받은 값에 대해 대문자로 변환해주는 func
	*/
	default String getNameToUpperCase(){
		return getName().toUpperCase();
	}


//위와 같이 주석에 @implSpec을 통해 해당 method가 어떤 역할로 사용되는지
작성해주면 된다.
default method, static method는 모두 사용하는 방법은 동일하기 때문에 위에선 default method 위주로 테스트 코드를 작성했지만 static method도 동일한 방식으로 작성 및 사용하면 된다.
```
```
#) default 메소드 다중상속 문제
1. 다중 인터페이스들 간의 디폴트 메소드 충돌
- 애초에 똑같은 리폴트 메서드를 가진 두 인터페이스를 하나의 클래스에 구현하고 아무런
조치를 취하지 않으면 컴파일 자체가 되지 않는다.

- 인터페이스를 구현한 클래스에서 디폴트 메소드를 오버라이딩하여 하나로 통합한다.

interface A1{
    public void styleA();

    // 메소드 시그니처가 같은 디폴트 메서드
    default public void styleSame(){
        System.out.println("A1 인터페이스의 디폴트 메서드 입니다.");
    }
}

interface B1{
    public void styleB();

    // 메소드 시그니처가 같은 디폴트 메서드
    default public void styleSame(){
        System.out.println("B1 인터페이스의 디폴트 메서드 입니다.");
    }
}

class MultiInterface implements A1, B1 {
    @Override
    public void styleA() {}
    @Override
    public void styleB() {}

    // 두 인터페이스 디폴트 메서드중 A1 인터페이스의 디폴트 메서드를 오버라이딩 하여 구현
    default public void styleSame(){
        System.out.println("A1 인터페이스의 디폴트 메서드 입니다.");
    }
}

public class Main {
    public static void main(String[] args) {
        MultiInterface m1 = new MultiInterface();
        m1.styleSame(); // "A1 인터페이스의 디폴트 메서드 입니다."
    }
}
```
```
2. 인터페이스의 디폴트메소드와 부모클래스 메서드 간의 충돌

자식 클래스에서 인터페이스와 부모 클래스를 동시에 extends / implement 하였을때 디폴트 메서드와 인스턴스 메서드 간의 충돌을 가정한 상황이다.

이때는 부모 클래스의 메서드가 상속되고 디폴트 메서드는 무시된다.

만일 인터페이스 쪽의 디폴트 메서드를 사용할 필요가 있다면, 필요한 쪽의 메서드와 같은 내용으로 그냥 오버라이딩 해버리면 된다.


interface A1{
    public void styleA();

    // C1 클래스와 메소드 시그니처가 같은 디폴트 메서드
    default public void styleSame() {
        System.out.println("A1 인터페이스의 디폴트 메서드 입니다.");
    }
}

abstract class C1 {
    // A1 인터페이스와 메소드 시그니처가 같은 인스턴스 메서드
    public void styleSame() {
        System.out.println("C1 클래스의 인스턴스 메서드 입니다.");
    }
}

// 메서드 시그니처가 같은 두 추상화들을 동시에 상속
class MultiClassInterface extends C1 implements A1 {
    @Override
    public void styleA() {}
}

public class Main {
    public static void main(String[] args) {
        MultiClassInterface m1 = new MultiClassInterface();
        m1.styleSame(); // "C1 클래스의 인스턴스 메서드 입니다." - 클래스의 메서드 시그니처가 우선되어 적용됨

        // 마찬가지로 인터페이스 타입으로 다운캐스팅 해도 클래스 인스턴스 메서드로 호출 됨
        ((A1) m1).styleSame(); // "C1 클래스의 인스턴스 메서드 입니다."
    }
}
```
```
//디폴트메소드를 쓰고 싶을 경우
// 메서드 시그니처가 같은 두 추상화들을 동시에 상속
class MultiClassInterface extends C1 implements A1 {
    @Override
    public void styleA() {}
    //이게 위와 차이점이다.
    // 클래스의 인스턴스 메서드를 무시하고 인터페이스의 디폴트 메서드를 사용하기 위해 그대로 오버라이딩
    public void styleSame() {
        System.out.println("A1 인터페이스의 디폴트 메서드 입니다.");
    }
}

public class Main {
    public static void main(String[] args) {
        MultiClassInterface m1 = new MultiClassInterface();
        m1.styleSame(); // "A1 인터페이스의 디폴트 메서드 입니다."
    }
}
```
```
#) default 메소드의 super
상위 클래스를 상속하고 상위의 메소드를 오버라이딩하여 재정의하였을때, 만일 부모 메서드를 호출할 일이 생긴하면 super 키워드를 통해 부모 메서드를 호출할 수 있었다.

이와 같이 인터페이스도 디폴트 메서드를 구현한 클래스에서 오버라이딩 하였을때, super 키워드를 통해 인터페이스의 원래의 디폴트 메서드를 호출이 가능하다.

다만 문법이 클래스 방식과 약간 차이가 있다. 
인터페이스의 super는 다음과 같은 구성으로 호출된다. -> 인터페이스명.super.디폴트메서드

interface IPrint{
    default void print(){
        System.out.println("인터페이스의 디폴트 메서드 입니다.");
    }
}

class MyClass implements IPrint {
    @Override
    public void print() {
        IPrint.super.print(); // 인터페이스의 super 메서드를 호출
        System.out.println("인터페이스의 디폴트 메서드를 오버라이딩한 메서드 입니다.");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass cls = new MyClass();
        cls.print();
    }
}

//출력
인터페이스의 디폴트 메소드입니다.
인터페이스의 디폴트 메서드를 오버라이딩한 메소드입니다.
```
```
#)static 메소드
- 인스턴스 생성과 상관없이 인터페이스 타입으로 접근해 사용할 수 있는 메서드
- 인터페이스 전용 static 메소드라해서 특별한 것은없다.
  일반 클래스의 static 메서드와 다를 바 없다.(똑같이 취급하면 된다.)

interface Calculator {
    public int plus(int i, int j);
    public int multiple(int i, int j);

    // 디폴트 메서드
    default int sub(int i, int j){
        return i - j;
    }

    // 스태틱 메서드
    public static void explain(){
        System.out.println("interface static 메서드 입니다. 이 인터페이스는 pluc, multipe, sub 기능을 제공하는 메서드를 지니고 있습니다. (설명)");   
    }
}

class MyCalculator implements Calculator {
    @Override
    public int plus(int i, int j) {  return i + j; }
    @Override
    public int multiple(int i, int j) { return i * j; }
}

public class Main {
    public static void main(String[] args){
        // 클래스 처럼 static 메소드 호출 하면 된다.
        Calculator.explain(); // "interface static 메서드 입니다. 이 인터페이스는 plus, multiple, sub 기능을 제공하는 메서드를 지니고 있습니다. (설명)"
    }
}
```
```
#) private 메소드
- 자바 9버전에 추가된 메서드
- 인터페이스에 default, static 메서드가 생긴 이후, 이러한 메소드들의 로직을 공통화하고 재사용하기 위해 생김
- private 메서드도 구현부를 가져야한다.
- 단, private 메소드는 인터페이스 내부에서만 돌아가는 코드이다. (인터페이스를 구현한 클래스에서
사용하거나 재정의할 수 없음)
- 따라서 인터페이스 내부에서 private 메소드를 호출할때, default 메소드 내부에서 호출해야 하며,만일 private static 키워드를 붙인 메소드는 static 메소드에서만 호출이 가능하다.


#) Tip
어렵게 생각할 필요없이, 클래스에서도 private 접근제어자를 가진 메서드를 정의하였을때, 호출 메서드에서 private 내부 메서드를 호출하여 사용하는 식 이었던 것 처럼, 인터페이스도 어렵지 않게 똑같이 생각하면 된다.단, 인터페이스는 클래스가 아니기 때문에 this 키워드를 사용할순 없다.



interface Calculator {
    public int plus(int i, int j);
    public int multiple(int i, int j);

    // private 메서드
    private void printf() {
        System.out.println("private 메서드는 default 내부에서만 호출이 가능합니다.");
    }

    // private 스태틱 메서드
    private static void printfStatic() {
        System.out.println("private static 메서드는 static 메서드 내부에서만 호출이 가능합니다.");
    }

    // 디폴트 메서드
    default void callPrivate() {
        printf(); // private 메서드 호출
    }

    // 스태틱 메서드
    static void callPrivateStatic() {
        printfStatic(); // private 스태틱 메서드 호출
    }
}

class MyCalculator implements Calculator {
    @Override
    public int plus(int i, int j) {  return i + j; }
    @Override
    public int multiple(int i, int j) { return i * j; }
}

public class Main {
    public static void main(String[] args){
        // 인터페이스 디폴트 메서드를 통한 private 메서드 호출
        Calculator c = new MyCalculator(); // 인터페이스 타입으로 업캐스팅
        c.callPrivate(); // "private 메서드는 default 내부에서만 호출이 가능합니다."

        // 인터페이스 스태틱 메서드를 통한 private static 메서드 호출
        Calculator.callPrivateStatic(); // "private static 메서드는 static 메서드 내부에서만 호출이 가능합니다."
    }
}
```
```
#) info
인터페이스의 상수는 private으로 만들 수 없다.인터페이스는 실제 객체는 아니지만 서로 간의 약속으로 사용된다. 정해진 약속을 한 쪽에서 일방적으로 수정하게 되면 문제가 발생할 수 있다. 따라서 인터페이스에 선언하는 필드들은 자동으로 public static final 완벽한 상수가 된다.
```
```
#) 인터페이스의 활용도
1. 인터페이스 다형성

interface Keyboard { }

class Logitec_Keyboard implements Keyboard { }

class Samsung_Keyboard implements Keyboard { }

class Apple_Keyboard implements Keyboard { }

public class Main {
    public static void main(String[] args) {
    	// 인터페이스 타입 배열로 여러가지 클래스들을 한번에 타입 묶음을 할 수 있다.
        Keyboard[] k = {
                new Logitec_Keyboard(),
                new Samsung_Keyboard(),
                new Apple_Keyboard(),
        };
    }
}

또한 인터페이스를 자료형으로 쓰는 습관들이면 프로그램이 유용해진다고 하는데
그 의미가 객체는 클래스가 아닌 인터페이스로 참조하라는 의미이다.
```
```
예를들어 중복이 없는 집합 자료형을 사용하기 위해 LinkedHashSet 클래스를 초기화 하려할때,
이때 객체의 타입을 똑같이 LinkedHashSet으로 하지말고 인터페이스인 Set타입으로 설정하여 선언하는 것이다.

// 나쁜 예) 클래스를 바로 타입으로 사용했다.
LinkedHashSet<Object> s = new LinkedHashSet<>();

// 좋은 예) 인터페이스를 타입으로 사용했다.
Set<Object> s = new LinkedHashSet<>();


이런식으로 구현을 하면 변수에 담긴 구현 클래스를 다른 Set자료형 클래스로 교체하고자 할때
그저 새클래스의 생성자를 다시 호출해주기만 하면 된다.

// 본래 LinkedHashSet으로 구현하였다가 사정이 생겨 TreeSet클래스로 변경해야한다고 하면, 그냥 인터페이스 타입의 변수에 재할당만 하면 된다
Set<Object> s = new LinkedHashSet<>();
s = new TreeSet<>();
```
```
마지막으로 무엇보다 인터페이스의 다형성의 가장 큰 특징은 바로 다중 구현을 통한 자유로운 상속 관계를 만들어 클래스의 다형성보다 더욱 다채롭게 그리고 자유롭게 사용이 가능하다는 것이다.

아무래도 클래스의 다형성은 기본적으로 클래스의 상속에 기반을 두기 때문에, 클래스 상속은 한번밖에 안되며 또한 클래스끼리 의미있는 연관 관계가 있어야 되어 여러모로 제약이 많다. 그러나 인터페이스는 언제어디서나 마음대로 implements를 여러개 추가하거나 빼거나 할 수 있으니 제약으로부터 많이 자유로워 진다.

이를 이용한 예시가 바로 다음에 소개할 클래스끼리 형제 관계를 맺게 해주거나 상속을 넘어선 타입 제한도 가능하게 된다.
```

```
#)형제관계를 맺어줌
기본적으로 자바의 클래즈 상속구조는 부모-자식 관계로만 가능하다.
그래서, 사용하는 클래스들이 각기 다른 부모클래스를 상속하고있는 상황이면 위의 자료형 타입 통합 할수없다.

하지만 인터페이스는 클래스 상속관계와는 달리, 하나의 기능에 대한 약속이기때문에 어떤 객체이든
그 약속을 지키기만 한다면 필요한 곳에서 사용 가능

그리고 인터페이스는 다중 상속에 대해 제약을 받지 않기 때문에, 일부만 묶고 싶은 클래스들을 implements 키워드로 등록시키면, 각기 다른 부모클래스를 상속하고 있는 자식 클래스에 인터페이스를 구현(상속) 시켜줌으로써 형제 클래스 끼리 묶는 타입 통합을 이루어 낼수 있는 것이다.
즉, 아무 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어줄 수 있다. 
 
예를 들어 각기 다른 부모 클래스를 상속하고 있는 Soccer 클래스와 BassGuitar 클래스를 하나의 타입으로 묶어서 사용할 필요가 있을때, 인터페이스를 implements 함으로써 마치 Soccer 와 BassGuitar 클래스를 묶은 형제 클래스 타입 IBehavior 를 만든것과 같다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/12.PNG" width="650" height="400" /><br><br>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/13.PNG" width="650" height="500" /><br><br>

```
#)타입 접근제한
이외에도 인터페이스는 일종의 접근제한 역할도 할 수 있다.

이는 위의 형제 관계 역할과 매우 비슷한 개념인데, 만일 똑같은 부모를 상속하고 있는 3개의 자식들중, 2개의 자식 클래스 타입만 받을 수 있는 메서드를 구현한다고 했을때 이용된다.
다형성이랍시고 부모 클래스 타입으로 파라미터를 받아버리면, 모든 자식 클래스가 접근이 가능하지 때문에 제한이 되지 않기 때문이다.
 
이 부분은 바로 코드 예시를 보는 것이 훨씬 이해하기 쉬울 수 있다.
다음과 같이 스타크래프트를 구성하기 위해 Marine, SCV, Tank 클래스를 만들고 이들을 공통으로 묶을 부모 클래스 GroundUnit 클래스로 상속 관계를 맺어 주었다.
그리고 repair() 메서드에서 중복을 줄이기 위한 다형성 기법으로 매개변수 타입을 GroundUnit 부모 클래스 타입으로 받도록 설정 하였다.

class GroundUnit { }

class Marine extends GroundUnit{ }
class SCV extends GroundUnit{ }
class Tank extends GroundUnit{ }

public class Main {
    public static void main(String[] args) {   
        repair(new Marine());
    }
    
    static void repair(GroundUnit gu) { //타입이 마린도 들어갈수있네..
        // 마린은 기계가 아니기 때문에 수리는 불가능 하다. 하지만 상속 관계상 마린 클래스 타입이 들어와 실행될 수 있는 위험성이 존재한다.
    }
}

//그래서 3개의 자식중 2개의 자식만 머신이라는 타입으로 형제타입관계를 맺어주면서 동시에
다른 타입의 접근제할 역할도 해낸것이다.(마린이 못들어오게)

interface Machine { } // SCV, Tank 클래스를 통합한 타입으로 이용하는 인터페이스

class GroundUnit { }

class Marine extends GroundUnit{ }
class SCV extends GroundUnit implements Machine{ }
class Tank extends GroundUnit implements Machine{ }

public class Main {
    public static void main(String[] args) {
        repair(new Marine()); // ! ERROR
    }

    static void repair(Machine gu) {
        // SVG와 탱크 타입만 받을 수 있게 인터페이스를 타입으로 하여 다형성을 적용
    }
}
```
```
#)메서드 접근제한
이밖에도 객체에서 사용할 수 있는 메서드를 제한하는 효과도 있는데,
예를들어 A,B,C라는 인터페이스를 구현한 클래스를 반환할 때 A타입으로 반환하게되면 외부에서는
A인터페이스의 메소드만 보이게된다.
따라서 별도의 접근 제한을 이용하지 않고도 사용할 수 있는 메서드 접근 제한과 마찬가지 효과를 보게하는 방법

이런이유로 오히려 거꾸로 클래스에 여러가지 메소드를 만들어 둔 다음 인터페이스로 분리하는 작업을 진행하는 경우가 가끔있다.

interface PlayMovie {
    void play();
}
interface ViewImage {
    void view();
}
interface VolumeUpDown {
    void volume();
}

class MP3 implements PlayMovie, ViewImage, VolumeUpDown {
    public void play() {}
    public void view() {}
    public void volume() {}
}

public class Main {
    public static void main(String[] args) {
        PlayMovie mp3 = new MP3(); // 3개의 구현한 인터페이스중 하나로 객체 선언
        mp3.play(); // play() 이외의 메소드는 제한된다.
    }
}
```

```
#)인터페이스 타입으로 통신
ServiceLogic 클래스의 메소드 printInt() 를 보면 파라미터로 MapStore 클래스 타입을 받아 MapStore 클래스의 메서드를 실행해 값을 얻고 출력하는 로직으로 구성되어 있다.

이러한 형태를 ServiceLogic 클래스는 MapStore 클래스에 의존적이다 라고 말한다. 왜냐하면 MapStore 클래스가 잘못되면 ServiceLogic 클래스의 메서드는 동작하지 않을 것이기 때문이다. 

class ServiceLogic {
    // ServiceLogic 클래스의 메소드는 MapStore 클래스를 사용하기 때문에, ServiceLogic 는 MapStore 에 의존적이다.
    public void printInt(MapStore cls) { // 지정한 클래스 타입만 받음
        int num = cls.getNum() * 2;
        System.out.println(num);
    }
}

class MapStore {
    private int num = 10;

    public int getNum() {
        return this.num;
    }
}
```
```
따라서 이러한 의존성 관계를 없애기 위해 ClubStore 인터페이스를 만들고 MapStore 클래스에 implements 하여 구현한다. 그러면 ServiceLogic 클래스에서 만일 MapStore 객체 데이터를 사용할 일이 생길경우, 직접 MapStore 객체를 사용하는게 아닌 오로지 ClubStore 인터페이스를 이용해 통신함으로써 클래스 간의 의존성을 없앨 수 있는 것이다.
이것을 변경에 유리한 유연한 설계라고도 한다.

interface ClubStore {
    int getNum(); // 인터페이스 타입 상태의 객체에서 메서드를 사용하기 위해선 인터페이스에도 추상 메서드 형태로 넣어져 이썽야 한다.
}

class ServiceLogic {
    // ServiceLogic 클래스의 메소드는 ClubStore 인터페이스를 사용함으로써 클래스 간의 의존성을 없앴다.
    public void printInt(ClubStore cls) { 
        int num = cls.getNum() * 2;
        System.out.println(num);
    }
}

class MapStore implements ClubStore{
    private int num = 10;

    public int getNum() {
        return this.num;
    }
}
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/14.PNG" width="650" height="500" /><br><br>

```
#)마커인터페이스
빈껍데기 인터페이스를 말한다.
interface aaa {

}

인터페이스를 자유롭게 다중상속이 가능하다는 점에서 착안하여 사용
아무내용이 없어 쓸모가 없어보이지만, 마커인터페이스의 역할은 객체의 타입과 관련된 정보만을 제공

따라서 컴파일러와 JVM은 이 마커인터페이스를 통해 객체에 대한 추가적인 정보를 얻을 수 있다.

상위 클래스 Animal을 만들고 그 하위들로 Lion, Chicken, Snake ...등 여러가지 동물 클래스들을 만들어 상속 관계를 맺었다. 이때 born 이라는 메서드에서 Animal 타입의 매개변수를 받고 새끼를 낳는 동물인지 알을 낳는 동물인지 구분하기 위해 일일히 instanceof 연산자로 클래스 타입을 구분하였다.

class Animal {
    public static void born(Animal a) {
        if(a instanceof Lion) {
            System.out.println("새끼를 낳았습니다.");
        } else if(a instanceof Chicken) {
            System.out.println("알을 낳았습니다.");
        } else if(a instanceof Snake) {
            System.out.println("알을 낳았습니다.");
        }
        // ...
    }
}

class Lion extends Animal { }
class Chicken extends Animal { }
class Snake extends Animal { }

이러한방식은 자식클래스 개수가 많아지면 복잡해진다.

따라서 아무런 내용이 없는 빈 껍데기 인터페이스를 선언하고 적절한 클래스에 implements 시킴으로써, 추상화, 다형성 이런걸 떠나서 그냥 단순한 타입 체크용으로 사용하는 것이다.
그러면 조건문 코드도 다음과 같이 심플해질 수 있다.

// 새끼를 낮을 수 있다는 표식 역할을 해주는 마커 인터페이스
interface Breedable {}

class Animal {
    public static void born(Animal a) {
        if(a instanceof Breedable) {
            System.out.println("새끼를 낳았습니다.");
        } else {
            System.out.println("알을 낳았습니다.");
        }
    }
}

class Lion extends Animal implements Breedable { }
class Chicken extends Animal { }
class Snake extends Animal { }


TIP) 이러한 마커인터페이스의 대표적인 자바 인터페이스로는 Serializable, Cloneable이 있다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/14.PNG" width="650" height="500" /><br><br>

```
#)인터페이스 정리
- 내부의 모든메서드는 public abstract 로 정의 (default 메서드 제외)
- 내부의 모든 필드는 public static final 상수
- 클래스에 다중구현 지원
- 인터페이스끼리는 다중상속 지원
- 인터페이스에도 static, default, private 제어자를 붙여 클래스 같이 구체적인 메서드를 가질 수 있음.따라서 하위 멤버의 중복 메서드 통합을 어느정도 할수는 있겠지만, 필드는 상수이기 때문에 중복 필드 통합은 불가능
- 인터페이스는 부모 자식 관계인 상속에 얽매이지 않고, 공통 기능이 필요할 때마다 추상 메서드를 정의해놓고 구현(implement)하는 식으로 추상클래스보다 자유롭게 붙였다 땟다 사용
- 인터페이스는 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하는 것에 초점
- 다중 구현이 된다는 점을 이용해, 내부 멤버가 없는 빈 껍데기 인터페이스를 선언하여 마커 인터페이스 로서 이용 가능
- 보통 xxxable 이런 형식으로 인터페이스 네이밍 규칙을 따름
```
```
#)추상클래스 정리
- 추상클래스는 하위 클래스들의 공통점들을 모아 추상화하여 만든 클래스
- 추상클래스는 다중 상속이 불가능하여 단일 상속만 허용한다.
- 추상클래스는 추상 메소드 외에 일반클래스와 같이 일반적인 필드, 메서드, 생성자를 가질수 있다.
이러한 특징으로, 추상클래스는 추상화(추상 메서드)를 하면서 중복되는 클래스 멤버들을 통합 및 확장을 할 수 있다.
- 같은 추상화인 인터페이스와 다른점은, 추상클래스는 클래스간의 연관 관계를 구축하는 것에 초점을 둔다.
```

```
#)인터페이스 vs 추상화
인터페이스나 추상클래스나 둘이 똑같이 추상 메소드를 통해 상속/구현을 통한 메소드 강제 구현 규칙을 가지는 추상화 클래스이다.

다만 이 둘은 각각 고유의 몇몇 특징들을 가지고 있는데, 이러한 특징으로 인해 각각 사용처가 갈리게 된다. 또한 기능적인 부분 뿐만 아니라 인터페이스와 추상클래스가 내포하고있는 논리적인 의미로서도 사용처가 나뉜다.

예를들어 이 둘은 대표적으로 '다중 상속' 기능 여부의 차이가 있지만, 이것이 포인트가 아니라 이에 따른 사용 목적이 다르다는 것에 포인트를 맞춰야 한다.

인터페이스 : implements 라는 키워드처럼 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 기능을 구현하는 느낌

추상 클래스 : extends 키워드를 사용해서 자신의 기능들을 하위 클래스로 확장 시키는 느낌
```
```
#)추상클래스 사용하는 경우
- 상속 받을 클래스들이 공통으로 가지는 메소드와 필드가 많아 중복 멤버 통합을 할때
- 멤버에 public 이외의 접근자(protected, private) 선언이 필요한 경우
- non-static, non-final 필드 선언이 필요한 경우 (각 인스턴스에서 상태 변경을 위한 메소드가 필요한 경우)
- 요구사항과 함께 구현 세부 정보의 일부 기능만 지정했을 때
- 하위 클래스가 오버라이드하여 재정의하는 기능들을 공유하기 위한 상속 개념을 사용할 때
- 추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로, 상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 부모 클래스가 가진 기능들을 구현해야할 경우 사용한다.
```

```
#)중복멤버통합
중복되는 멤버를 통합해주는 기능은 본래 추상클래스의 기능이라기보다는 그냥 클래스자체의 기능이다.

근데, 인터페이스랑 차이가 있는것이 상수밖에 정의못하는 인터페이스에서는 할수없는 기능이 추상클래스
중복멤버통합이라고 보면된다.

class NewlecExam {
    int kor; // 중복되는 멤버
    int eng; // 중복되는 멤버
    int math; // 중복되는 멤버
    int com;

    void total(){} // 중복되는 멤버
    void avg(){} // 중복되는 멤버
}

class YBMExam{
    int kor; // 중복되는 멤버
    int eng; // 중복되는 멤버
    int math; // 중복되는 멤버
    int toeic;

    void total(){} // 중복되는 멤버
    void avg(){} // 중복되는 멤버
}
```
```
위의 국어,영어,수학 멤버필드를 상속을 통해 상위클래스로 묶고, 메서드도 통합하여 추상화해준다.
이러면 나중에 다른 종류의 Exam 클래스를 추가/확장하는데 있어 유연하다.

abstract class Exam {
    int kor;
    int eng;
    int math;

    abstract void total();
    abstract void avg();
}

class NewlecExam extends Exam {
    int com;

    void total(){}
    void avg(){}
}

class YBMExam extends Exam {
    int toeic;

    void total(){}
    void avg(){}
}
```
```
#)추상클래스의 다형성 이용설계
추상클래스의 다형성이나 인터페이스의 다형성이나 둘이 클래스 타입을 통합한다는 취지는 같다.

다만, 언제 상황에 다형성을 사용하느냐에 따른 순서차이다.

추상클래스는 클라이언트(ExamConsole)에서 자료형을 사용하기전에 미리 논리적인 클래스 상속구조를
만들어놓고 사용이 결정되는 느낌이다.

예를들어 위의 Exam주제의 논리적인 상속 구조의 객체들을 클라이언트(ExamConsole)에서 다형성으로
통합적으로 받아 사용할 때, 필드로 추상클래스타입으로 선언하고 생성자에서 매개변수로
new NewlectExam 또는 new YBMExam() 객체로 받아와 업캐스팅으로 초기화함으로써,
다양한 Exam 자식클래스들을 다형성으로 다룰 수 있게된다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/16.PNG" width="650" height="500" /><br><br>

```
#)명확한 계층 구조 추상화
단순한 중복 멤버 제거를 떠나서, 클래스끼리 명확한 계층구조가 필요할때도 추상클래스를 사용한다.

공통된 기능 구현이 필요하거나, 공통으로 지켜야 할 규칙도 있을때 상속을 통해 구조화 하여 재정의(overriding)을 통해 구현한다.

이는 기능이라기 보단 설계 원칙 이론에 가까운데, 아직 객체 지향의 추상화에 익숙하지 않으면, 인터페이스와의 차이점이 애매해 잘 와닿지 않은 부분일 수도 있다. (이론이란 원래 그런거니까)

기억해야 할 부분은 추상클래스나 인터페이스나 추상 메소드를 이용한 구현 원칙을 강제한다는 점은 같지만, 추상클래스는 '클래스로서' 클래스와 의미있는 연관 관계를 구축할때 사용된다라고 보면 된다.
의미있는 연관 관계란, 부모와 자식 간의 논리적으로 묶여있는 관계라고 보면 된다. 

삼각형, 원, 마름모를 도형이라는 관계로 묶거나, 사자, 호랑이, 고양이를 동물이라는 관계로 묶는, 단어 그 자체에 논리성과 의미성이 있는 연관 관계로 떠올리면 된다.
```

```
예를들어, 대용량 SMS sender를 구현하는데 여러 통신사들이 다른 통신탑(tower)을 갖고 있어서
접속하는데 있어 각각 다른 구현이 필요하며(establish Connection With Your Tower), 공통으로
지켜야할 규칙인 방해금지모드(check If Do Not Disturb Mode)도 있는 스펙일때 먼저 추상클래스로
공통분모들을 추상화로 구현하고, 상속을 통해 여러 통신사 클래스를 확장하여 구현하는 식으로 구성

/* SMS를 보내는 추상화된 코드 */
abstract class SMSSender {

	//상속받는 클래스마다 구현하는내용이 다르니까 추상화
    abstract public void establishConnectionWithYourTower();

    public void sendSMS() {
        establishConnectionWithYourTower();
        checkIfDoNotDisturbMode();
        // ...
        destroyConnectionWithYourTower();
    }

    abstract public void destroyConnectionWithYourTower();

    public void checkIfDoNotDisturbMode() {
        // 추상 클래스 안에서 구현(공통으로 지켜야할 함수니까 추상화안씀)
    }
}
/* SMSSender를 통신사 클래스들이 상속 */
class SKT extends SMSSender {
    @Override
    public void establishConnectionWithYourTower() {
        // SKT 방식으로 커넥션 맺기
    }

    @Override
    public void destroyConnectionWithYourTower() {
        // SKT 방식으로 커넥션 종료
    }
}

class LG extends SMSSender {
    @Override
    public void establishConnectionWithYourTower() {
        // LG 방식으로 커넥션 맺기
    }

    @Override
    public void destroyConnectionWithYourTower() {
        // LG 방식으로 커넥션 종료
    }
}
```
```
#)인터페이스를 사용하는 경우
- 어플리케이션의 기능을 정의해야 하지만 그 구현 방식이나 대상에 대해 추상화 할 때
- 서로 관련성이 없는 클래스들을 묶어 주고 싶을때 (형제 관계)
- 다중 상속(구현)을 통한 추상화 설계를 해야할때
- 특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우
- 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용

```
```
#)자유로운 타입 묶음
인터페이스의 가장 큰 특징은 상속에 구애 받지 않은 상속(구현) 가 가능하다는 것이다.

상속(extends)는 뭔가 클래스끼리 논리적인 타입 묶음의 의미가 있다면, 구현(implements)은 자유로운 타입 묶음의 의미이다. 그래서 서로 논리적이지 않고 관련이 적은 클래스끼리 필요에 의해 형제 타입 처럼 묶어 버릴 수 있다.
 
다음과 같이 Creature 라는 최상위 추상 클래스와 그 하위 추상 클래스인 Animal, Fish 가 있고, 각 추상 클래스를 구체적으로 의미 부여해 구현한 Parrot, Tiger, People 클래스와 Whale 클래스가 있다고 가정하자.

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/17.PNG" width="650" height="500" /><br><br>

```
위의 상속관계를 코드로 표현

// 추상 클래스 (조상 클래스)
abstract class Creature { }

// 추상 클래스 (부모 클래스)
abstract class Animal extends Creature { }
abstract class Fish extends Creature { }

// 자식 클래스
class Parrot extends Animal { }
class Tiger extends Animal { }
class People extends Animal { }

class Whale extends Fish { }

이렇게 상속 관계를 설정해 놓고 동작을 하는 메소드를 추가해야 하는데, 만일 수영 동작을 하는 swimming() 메소드를 각 자식 클래스에 추가해야 한다고 하자.

이때 나중에 확장을 위해 추상화 원칙을 따라야 한다고 한다. 그러면 부모나 조상 클래스에 추상 메소드를 추가해야 하는데, 수영은 고래(Whale) 과 사람(People)만 할수 있으니 이를 동시에 포함하는 Creature 추상 클래스에서 추상 메소드를 추가해야 한다. (호랑이와 앵무새는 수영을 못한다고 가정한다)
 
하지만 Creature 추상 클래스에 추상 메소드를 추가하면, 곧 이를 상속하는 모든 자손/자식 클래스에서 반드시 메소드를 구체화 해야한다는 규칙 때문에 실제로 수영을 못하는 호랑이(Tiger)와 앵무새(Parrot) 클래스에서도 메소드를 구현해야 하는 강제성이 생기게 된다.


// 추상 클래스 (조상 클래스)
abstract class Creature { 
	abstract void swimming(); // 수영 동작을 하는 추상 메소드
}

// 추상 클래스 (부모 클래스)
abstract class Animal extends Creature { }
abstract class Fish extends Creature { }

// 자식 클래스
class Parrot extends Animal {
	void swimming() {} // 앵무새는 수영을 할수 없지만 상속 관계로 인해 강제적으로 메소드를 구현해야하는 사태가 일어난다.
}
class Tiger extends Animal {
	void swimming() {} // 호랑이는 수영을 할수 없지만 상속 관계로 인해 강제적으로 메소드를 구현해야하는 사태가 일어난다.
}
class People extends Animal {
	void swimming() {
    	// ...
    } 
}

class Whale extends Fish {
	void swimming() {
		// ...
    } 
}

물론 메소드를 선언하기만하고 빈칸으로 놔두면 되기는 하지만,
이는 객체지향설계에 위반될 뿐만아니라 나중에 유지보수면에서도 힘들다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/18.PNG" width="650" height="500" /><br><br>

```
abstract class Creature {}

abstract class Animal extends Creature {}
abstract class Fish extends Creatrue {}

//수영 동작 추상메소드를 따로 인터페이스로 만들어 넣는다.
interface Swimmable {
	void swimming();
}

class Tiger extends Animal {}
class Parrot extends Animal {}
// 인터페이스를 구현함으로써 동작이 필요한 클래스에만 따로 상속에 구애받지않고 묶음
class People extends Animal implements Swimmable {
	@Override
	public void swimming() {}
}
class Whale extends Animal implements Swimmable {
	@Override
	public void swimming() {}
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/19.PNG" width="650" height="500" /><br><br>

```
abstract class Creature {}

abstract class Animal extends Creature {}
abstarct class Fish extends Creature {}

interface Flyable {
	void flying();
}

interface Talkable {
	void talking();
}

interface Swimmable {
	void swimming();
}

class Tiger extends Animal {}
class Parrot extends Animal implements Talkable {
	@Override
	public void talking() {

	}
}
class People extends Animal implements Talkable, Swimmable {
	@Override
	public void talking() {}

	@Override
	public void swimming() {}
}
class Whale extends Fish implements Swimmable{
    @Override
    public void swimming() {}
}
```
```
#)인터페이스 다형성 이용 설계
추상클래스는 클라이언트에서 자료형을 사용하기 전에 미리 논리적인 클래스 상속 구조를 만들어 놓고 사용이 결정되는 느낌이라면, 인터페이스는 반대로 먼저든 나중이든 그때 그때 필요에 따라 구현해서 자유롭게 붙였다 땟다하는 느낌으로 보면 된다.

외부파일에 데이터를 저장하는 라이브러리를 가져와 사용한다고 가정해보자

이 라이브러리안에는 Filesaver 클래스를 이용해 외부파일로 데이터를 저장한다.
이때 Filesaver 클래스를 보면 필드변수로 Storable 인터페이스 타입의 객체를
선언하여 save()메소드에서 인터페이스 타입갹체를 이용하는 것을 볼 수 있다.

즉, Filesaver 클래스는 구체적인 클래스타입으로 통신하는 것이 아닌 인터페이스라는
중개타입을 이용하여 통신하는 것이다.




```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/20.PNG" width="650" height="300" /><br><br>

```
//클래스 데이터를 외부파일로 저장가능하게 만드는 인터페이스
interface Storable {
	int getData();
}

//외부파일에 데이터를 저장하는 클래스
class FileSaver {
	Storable target;

	FileSaver(Storable target) {
		this.target = target;
	}
	int save() {
		//인터페이스 객체 필드의 메서드를 실행하여 값을 가져와 사용
		int data = target.getData();
		//...
	}
}

```
```
그래서 Exam, File, Rectangle 같은 전혀 연관 관계가 없는 클래스들을 FileSaver클래스에
전달해서 데이터를 파일로 저장하기 위해선, 인터페이스로 타입 통합하여 형제관계를 구성하여
FileSaver 클래스의 인터페이스 객체 필드로 넘기는 식으로, 상속에 얽매히지 않은 자유로운
인터페이스 다형성을 이용하는 것으로 볼 수 있는 것이다.



```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/21.PNG" width="650" height="300" /><br><br>

```
class Exam implements Storable { // 인터페이스를 구현함으로서 클래스끼리 형제 관계를 맺음 
    int kor;
    int eng;
    int math;

    void total(){}
    void avg(){}

    // 인터페이스 통신 메소드 구현
    int getData(){
        // ...
    }
}

class File implements Storable { // 인터페이스를 구현함으로서 클래스끼리 형제 관계를 맺음 
    String src;
    
    boolean isFile(){}
    void mkDir(){}
    
    // 인터페이스 통신 메소드 구현
    int getData(){
        // ...
    }
}
```
```
만일 분석 라이브러리를 사용한다고 했을때 Analyzer클래스에서 통신으로 사용되는
Calculateable 인터페이스 타입 객체 필드에 Exam클래스를 전달하기위해 역시 다중 구현이
가능하다는 점을 이용해 Calculateable 인터페이스를 implements만 하면 되는 일이다.

```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/222.PNG" width="650" height="300" /><br><br>

```
interface Calculateable {
	void total();
	void avg();
}
class Analyzer {
	Calculateable caculate;

	void result() {}
}

class Exam implements Storable, Calculateable {
	int kor;
	int eng;
	int math;

	void total() {}
	void avg() {}
	int getData() {}
}

정리하자면, 인터페이스의 다형성은 부모 자식 클래스와 달리 논리적으로 관련이 없는 별개의 클래스들을 다룬다는 점에서, 상속 관계에 얽매히지 않고 구현(implements)만 하면 자유롭게 다형성을 이용할 수 있다고 보면 된다.
```

```
#)인터페이스 + 추상클래스 조합
추상클래스의 중복멤버통합과 인터페이스의 다중 상속 기능을 동시에 사용하기 위해서다.
따라서, 이 둘을 같이 사용하는 여러가지 코드패턴들이 나왔고, 디자인패턴의 근간이 되었다.

추상 클래스에 인터페이스를 implements 하고, 인터페이스의 추상 메소드를 아예 구현하지 않거나, 혹은 일부만 구현하는 식으로 통합된 추상화 클래스를 만들수 있다.


```

